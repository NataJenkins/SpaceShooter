!(function (t, e) { typeof exports === 'object' && typeof module === 'object' ? module.exports = e() : typeof define === 'function' && define.amd ? define('Phaser', [], e) : typeof exports === 'object' ? exports.Phaser = e() : t.Phaser = e(); }(window, () => (function (t) { const e = {}; function i(n) { if (e[n]) return e[n].exports; const s = e[n] = { i: n, l: !1, exports: {} }; return t[n].call(s.exports, s, s.exports, i), s.l = !0, s.exports; } return i.m = t, i.c = e, i.d = function (t, e, n) { i.o(t, e) || Object.defineProperty(t, e, { configurable: !1, enumerable: !0, get: n }); }, i.r = function (t) { Object.defineProperty(t, '__esModule', { value: !0 }); }, i.n = function (t) { const e = t && t.__esModule ? function () { return t.default; } : function () { return t; }; return i.d(e, 'a', e), e; }, i.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e); }, i.p = '', i(i.s = 1066); }([function (t, e) { function i(t, e, i) { let n = i ? t[e] : Object.getOwnPropertyDescriptor(t, e); return !i && n.value && typeof n.value === 'object' && (n = n.value), !(!n || !(function (t) { return !!t.get && typeof t.get === 'function' || !!t.set && typeof t.set === 'function'; }(n))) && (void 0 === n.enumerable && (n.enumerable = !0), void 0 === n.configurable && (n.configurable = !0), n); } function n(t, e) { let i = Object.getOwnPropertyDescriptor(t, e); return !!i && (i.value && typeof i.value === 'object' && (i = i.value), !1 === i.configurable); } function s(t, e, s, r) { for (const a in e) if (e.hasOwnProperty(a)) { const h = i(e, a, s); if (!1 !== h) { if (n((r || t).prototype, a)) { if (o.ignoreFinals) continue; throw new Error(`cannot override final property '${a}', set Class.ignoreFinals = true to skip`); }Object.defineProperty(t.prototype, a, h); } else t.prototype[a] = e[a]; } } function r(t, e) { if (e) { Array.isArray(e) || (e = [e]); for (let i = 0; i < e.length; i++)s(t, e[i].prototype || e[i]); } } function o(t) { let e; let i; if (t || (t = {}), t.initialize) { if (typeof t.initialize !== 'function') throw new Error('initialize must be a function'); e = t.initialize, delete t.initialize; } else if (t.Extends) { const n = t.Extends; e = function () { n.apply(this, arguments); }; } else e = function () {}; t.Extends ? (e.prototype = Object.create(t.Extends.prototype), e.prototype.constructor = e, i = t.Extends, delete t.Extends) : e.prototype.constructor = e; let o = null; return t.Mixins && (o = t.Mixins, delete t.Mixins), r(e, o), s(e, t, !0, i), e; }o.extend = s, o.mixin = r, o.ignoreFinals = !1, t.exports = o; }, function (t, e) { t.exports = function (t, e, i) { const n = typeof t; return t && n !== 'number' && n !== 'string' && t.hasOwnProperty(e) && void 0 !== t[e] ? t[e] : i; }; }, function (t, e, i) {
  const n = i(0); const s = i(15); const r = i(79); const o = i(9); var a = new n({
    Extends: o, initialize(t, e) { o.call(this), this.scene = t, this.type = e, this.parentContainer = null, this.name = '', this.active = !0, this.tabIndex = -1, this.data = null, this.renderFlags = 15, this.cameraFilter = 0, this.input = null, this.body = null, this.ignoreDestroy = !1, t.sys.queueDepthSort(), t.sys.events.once('shutdown', this.destroy, this); }, setActive(t) { return this.active = t, this; }, setName(t) { return this.name = t, this; }, setDataEnabled() { return this.data || (this.data = new r(this)), this; }, setData(t, e) { return this.data || (this.data = new r(this)), this.data.set(t, e), this; }, getData(t) { return this.data || (this.data = new r(this)), this.data.get(t); }, setInteractive(t, e, i) { return this.scene.sys.input.enable(this, t, e, i), this; }, disableInteractive() { return this.input && (this.input.enabled = !this.input.enabled), this; }, removeInteractive() { return this.scene.sys.input.clear(this), this.input = void 0, this; }, update() {}, toJSON() { return s.ToJSON(this); }, willRender() { return a.RENDER_MASK === this.renderFlags; }, getIndexList() { for (var t = this, e = this.parentContainer, i = []; e && (i.unshift(e.getIndex(t)), t = e, e.parentContainer);)e = e.parentContainer; return i.unshift(this.scene.sys.displayList.getIndex(t)), i; }, destroy() { if (this.scene && !this.ignoreDestroy) { this.preDestroy && this.preDestroy.call(this), this.emit('destroy', this); const t = this.scene.sys; t.displayList.remove(this), t.updateList.remove(this), this.input && (t.input.clear(this), this.input = void 0), this.data && (this.data.destroy(), this.data = void 0), this.body && (this.body.destroy(), this.body = void 0), t.queueDepthSort(), this.active = !1, this.visible = !1, this.scene = void 0, this.parentContainer = void 0, this.removeAllListeners(); } },
  }); a.RENDER_MASK = 15, t.exports = a;
}, function (t, e) { t.exports = function () {}; }, function (t, e) { t.exports = function (t, e, i) { if (t && typeof t !== 'number') { if (t.hasOwnProperty(e)) return t[e]; if (e.indexOf('.')) { for (var n = e.split('.'), s = t, r = i, o = 0; o < n.length; o++) { if (!s.hasOwnProperty(n[o])) { r = i; break; }r = s[n[o]], s = s[n[o]]; } return r; } return i; } return i; }; }, function (t, e, i) { const n = new (i(0))({ initialize(t, e) { void 0 === t && (t = 0), void 0 === e && (e = t), this.x = t, this.y = e; }, setTo(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.x = t, this.y = e, this; } }); t.exports = n; }, function (t, e) { let i = {}; const n = { install(t) { for (const e in i)t[e] = i[e]; }, register(t, e) { i[t] = e; }, destroy() { i = {}; } }; t.exports = n; }, function (t, e, i) {
  var n = new (i(0))({
    initialize(t, e) { this.x = 0, this.y = 0, typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0) : (void 0 === e && (e = t), this.x = t || 0, this.y = e || 0); }, clone() { return new n(this.x, this.y); }, copy(t) { return this.x = t.x || 0, this.y = t.y || 0, this; }, setFromObject(t) { return this.x = t.x || 0, this.y = t.y || 0, this; }, set(t, e) { return void 0 === e && (e = t), this.x = t, this.y = e, this; }, setTo(t, e) { return this.set(t, e); }, setToPolar(t, e) { return e == null && (e = 1), this.x = Math.cos(t) * e, this.y = Math.sin(t) * e, this; }, equals(t) { return this.x === t.x && this.y === t.y; }, angle() { let t = Math.atan2(this.y, this.x); return t < 0 && (t += 2 * Math.PI), t; }, add(t) { return this.x += t.x, this.y += t.y, this; }, subtract(t) { return this.x -= t.x, this.y -= t.y, this; }, multiply(t) { return this.x *= t.x, this.y *= t.y, this; }, scale(t) { return isFinite(t) ? (this.x *= t, this.y *= t) : (this.x = 0, this.y = 0), this; }, divide(t) { return this.x /= t.x, this.y /= t.y, this; }, negate() { return this.x = -this.x, this.y = -this.y, this; }, distance(t) { const e = t.x - this.x; const i = t.y - this.y; return Math.sqrt(e * e + i * i); }, distanceSq(t) { const e = t.x - this.x; const i = t.y - this.y; return e * e + i * i; }, length() { const t = this.x; const e = this.y; return Math.sqrt(t * t + e * e); }, lengthSq() { const t = this.x; const e = this.y; return t * t + e * e; }, normalize() { const t = this.x; const e = this.y; let i = t * t + e * e; return i > 0 && (i = 1 / Math.sqrt(i), this.x = t * i, this.y = e * i), this; }, normalizeRightHand() { const t = this.x; return this.x = -1 * this.y, this.y = t, this; }, dot(t) { return this.x * t.x + this.y * t.y; }, cross(t) { return this.x * t.y - this.y * t.x; }, lerp(t, e) { void 0 === e && (e = 0); const i = this.x; const n = this.y; return this.x = i + e * (t.x - i), this.y = n + e * (t.y - n), this; }, transformMat3(t) { const e = this.x; const i = this.y; const n = t.val; return this.x = n[0] * e + n[3] * i + n[6], this.y = n[1] * e + n[4] * i + n[7], this; }, transformMat4(t) { const e = this.x; const i = this.y; const n = t.val; return this.x = n[0] * e + n[4] * i + n[12], this.y = n[1] * e + n[5] * i + n[13], this; }, reset() { return this.x = 0, this.y = 0, this; },
  }); n.ZERO = new n(), t.exports = n;
}, function (t, e) { t.exports = function (t) { if (typeof t !== 'object' || t.nodeType || t === t.window) return !1; try { if (t.constructor && !{}.hasOwnProperty.call(t.constructor.prototype, 'isPrototypeOf')) return !1; } catch (t) { return !1; } return !0; }; }, function (t, e, i) {
  const n = Object.prototype.hasOwnProperty; let s = '~'; function r() {} function o(t, e, i, n, r) { if (typeof i !== 'function') throw new TypeError('The listener must be a function'); const o = new function (t, e, i) { this.fn = t, this.context = e, this.once = i || !1; }(i, n || t, r); const a = s ? s + e : e; return t._events[a] ? t._events[a].fn ? t._events[a] = [t._events[a], o] : t._events[a].push(o) : (t._events[a] = o, t._eventsCount++), t; } function a(t, e) { --t._eventsCount == 0 ? t._events = new r() : delete t._events[e]; } function h() { this._events = new r(), this._eventsCount = 0; }Object.create && (r.prototype = Object.create(null), (new r()).__proto__ || (s = !1)), h.prototype.eventNames = function () { let t; let e; const i = []; if (this._eventsCount === 0) return i; for (e in t = this._events)n.call(t, e) && i.push(s ? e.slice(1) : e); return Object.getOwnPropertySymbols ? i.concat(Object.getOwnPropertySymbols(t)) : i; }, h.prototype.listeners = function (t) { const e = s ? s + t : t; const i = this._events[e]; if (!i) return []; if (i.fn) return [i.fn]; for (var n = 0, r = i.length, o = new Array(r); n < r; n++)o[n] = i[n].fn; return o; }, h.prototype.listenerCount = function (t) { const e = s ? s + t : t; const i = this._events[e]; return i ? i.fn ? 1 : i.length : 0; }, h.prototype.emit = function (t, e, i, n, r, o) { const a = s ? s + t : t; if (!this._events[a]) return !1; let h; let l; const u = this._events[a]; const c = arguments.length; if (u.fn) { switch (u.once && this.removeListener(t, u.fn, void 0, !0), c) { case 1: return u.fn.call(u.context), !0; case 2: return u.fn.call(u.context, e), !0; case 3: return u.fn.call(u.context, e, i), !0; case 4: return u.fn.call(u.context, e, i, n), !0; case 5: return u.fn.call(u.context, e, i, n, r), !0; case 6: return u.fn.call(u.context, e, i, n, r, o), !0; } for (l = 1, h = new Array(c - 1); l < c; l++)h[l - 1] = arguments[l]; u.fn.apply(u.context, h); } else { let d; const f = u.length; for (l = 0; l < f; l++) switch (u[l].once && this.removeListener(t, u[l].fn, void 0, !0), c) { case 1: u[l].fn.call(u[l].context); break; case 2: u[l].fn.call(u[l].context, e); break; case 3: u[l].fn.call(u[l].context, e, i); break; case 4: u[l].fn.call(u[l].context, e, i, n); break; default: if (!h) for (d = 1, h = new Array(c - 1); d < c; d++)h[d - 1] = arguments[d]; u[l].fn.apply(u[l].context, h); } } return !0; }, h.prototype.on = function (t, e, i) { return o(this, t, e, i, !1); }, h.prototype.once = function (t, e, i) { return o(this, t, e, i, !0); }, h.prototype.removeListener = function (t, e, i, n) { const r = s ? s + t : t; if (!this._events[r]) return this; if (!e) return a(this, r), this; const o = this._events[r]; if (o.fn)o.fn !== e || n && !o.once || i && o.context !== i || a(this, r); else { for (var h = 0, l = [], u = o.length; h < u; h++)(o[h].fn !== e || n && !o[h].once || i && o[h].context !== i) && l.push(o[h]); l.length ? this._events[r] = l.length === 1 ? l[0] : l : a(this, r); } return this; }, h.prototype.removeAllListeners = function (t) { let e; return t ? (e = s ? s + t : t, this._events[e] && a(this, e)) : (this._events = new r(), this._eventsCount = 0), this; }, h.prototype.off = h.prototype.removeListener, h.prototype.addListener = h.prototype.on, h.prefixed = s, h.EventEmitter = h, t.exports = h;
}, function (t, e, i) { const n = i(16); const s = i(4); t.exports = function (t, e, i) { const r = s(t, e, null); if (r === null) return i; if (Array.isArray(r)) return n.RND.pick(r); if (typeof r === 'object') { if (r.hasOwnProperty('randInt')) return n.RND.integerInRange(r.randInt[0], r.randInt[1]); if (r.hasOwnProperty('randFloat')) return n.RND.realInRange(r.randFloat[0], r.randFloat[1]); } else if (typeof r === 'function') return r(e); return r; }; }, function (t, e, i) {
  const n = i(0); const s = i(12); const r = new n({
    initialize(t) { this.scene = t, this.systems = t.sys, this.displayList, this.updateList, t.sys.events.once('boot', this.boot, this), t.sys.events.on('start', this.start, this); }, boot() { this.displayList = this.systems.displayList, this.updateList = this.systems.updateList, this.systems.events.once('destroy', this.destroy, this); }, start() { this.systems.events.once('shutdown', this.shutdown, this); }, existing(t) { return (t.renderCanvas || t.renderWebGL) && this.displayList.add(t), t.preUpdate && this.updateList.add(t), t; }, shutdown() { this.systems.events.off('shutdown', this.shutdown, this); }, destroy() { this.shutdown(), this.scene.sys.events.off('start', this.start, this), this.scene = null, this.systems = null, this.displayList = null, this.updateList = null; },
  }); r.register = function (t, e) { r.prototype.hasOwnProperty(t) || (r.prototype[t] = e); }, s.register('GameObjectFactory', r, 'add'), t.exports = r;
}, function (t, e) {
  const i = {}; const n = {}; const s = {
    register(t, e, n, s) { void 0 === s && (s = !1), i[t] = { plugin: e, mapping: n, custom: s }; }, registerCustom(t, e, i) { n[t] = { plugin: e, mapping: i }; }, hasCore(t) { return i.hasOwnProperty(t); }, hasCustom(t) { return n.hasOwnProperty(t); }, getCore(t) { return i[t]; }, getCustom(t) { return n[t]; }, getCustomClass(t) { return n.hasOwnProperty(t) ? n[t].plugin : null; }, remove(t) { i.hasOwnProperty(t) && delete i[t]; }, removeCustom(t) { n.hasOwnProperty(t) && delete n[t]; },
  }; t.exports = s;
}, function (t, e, i) {
  const n = i(0); const s = i(12); const r = new n({
    initialize(t) { this.scene = t, this.systems = t.sys, this.displayList, this.updateList, t.sys.events.once('boot', this.boot, this), t.sys.events.on('start', this.start, this); }, boot() { this.displayList = this.systems.displayList, this.updateList = this.systems.updateList, this.systems.events.once('destroy', this.destroy, this); }, start() { this.systems.events.once('shutdown', this.shutdown, this); }, shutdown() { this.systems.events.off('shutdown', this.shutdown, this); }, destroy() { this.shutdown(), this.scene.sys.events.off('start', this.start, this), this.scene = null, this.systems = null, this.displayList = null, this.updateList = null; },
  }); r.register = function (t, e) { r.prototype.hasOwnProperty(t) || (r.prototype[t] = e); }, s.register('GameObjectCreator', r, 'make'), t.exports = r;
}, function (t, e, i) {
  const n = i(0); const s = i(31); const r = i(132); const o = i(294); const a = i(95); const h = i(152); const l = new n({
    initialize(t, e, i, n) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this.x = t, this.y = e, this.width = i, this.height = n; }, contains(t, e) { return s(this, t, e); }, getPoint(t, e) { return r(this, t, e); }, getPoints(t, e, i) { return o(this, t, e, i); }, getRandomPoint(t) { return h(this, t); }, setTo(t, e, i, n) { return this.x = t, this.y = e, this.width = i, this.height = n, this; }, setEmpty() { return this.setTo(0, 0, 0, 0); }, setPosition(t, e) { return void 0 === e && (e = t), this.x = t, this.y = e, this; }, setSize(t, e) { return void 0 === e && (e = t), this.width = t, this.height = e, this; }, isEmpty() { return this.width <= 0 || this.height <= 0; }, getLineA(t) { return void 0 === t && (t = new a()), t.setTo(this.x, this.y, this.right, this.y), t; }, getLineB(t) { return void 0 === t && (t = new a()), t.setTo(this.right, this.y, this.right, this.bottom), t; }, getLineC(t) { return void 0 === t && (t = new a()), t.setTo(this.right, this.bottom, this.x, this.bottom), t; }, getLineD(t) { return void 0 === t && (t = new a()), t.setTo(this.x, this.bottom, this.x, this.y), t; }, left: { get() { return this.x; }, set(t) { t >= this.right ? this.width = 0 : this.width = this.right - t, this.x = t; } }, right: { get() { return this.x + this.width; }, set(t) { t <= this.x ? this.width = 0 : this.width = t - this.x; } }, top: { get() { return this.y; }, set(t) { t >= this.bottom ? this.height = 0 : this.height = this.bottom - t, this.y = t; } }, bottom: { get() { return this.y + this.height; }, set(t) { t <= this.y ? this.height = 0 : this.height = t - this.y; } }, centerX: { get() { return this.x + this.width / 2; }, set(t) { this.x = t - this.width / 2; } }, centerY: { get() { return this.y + this.height / 2; }, set(t) { this.y = t - this.height / 2; } },
  }); t.exports = l;
}, function (t, e, i) {
  t.exports = {
    Alpha: i(582), Animation: i(302), BlendMode: i(581), ComputedSize: i(580), Depth: i(579), Flip: i(578), GetBounds: i(577), Mask: i(576), MatrixStack: i(575), Origin: i(574), Pipeline: i(291), ScaleMode: i(573), ScrollFactor: i(572), Size: i(571), Texture: i(570), Tint: i(569), ToJSON: i(568), Transform: i(567), TransformMatrix: i(63), Visible: i(566),
  };
}, function (t, e, i) {
  const n = i(297); const s = {
    PI2: 2 * Math.PI, TAU: 0.5 * Math.PI, EPSILON: 1e-6, DEG_TO_RAD: Math.PI / 180, RAD_TO_DEG: 180 / Math.PI, RND: new n(),
  }; t.exports = s;
}, function (t, e) {
  t.exports = {
    LOADER_IDLE: 0, LOADER_LOADING: 1, LOADER_PROCESSING: 2, LOADER_COMPLETE: 3, LOADER_SHUTDOWN: 4, LOADER_DESTROYED: 5, FILE_PENDING: 10, FILE_LOADING: 11, FILE_LOADED: 12, FILE_FAILED: 13, FILE_PROCESSING: 14, FILE_ERRORED: 16, FILE_COMPLETE: 17, FILE_DESTROYED: 18, FILE_POPULATED: 19,
  };
}, function (t, e, i) { const n = i(8); var s = function () { let t; let e; let i; let r; let o; let a; let h = arguments[0] || {}; let l = 1; const u = arguments.length; let c = !1; for (typeof h === 'boolean' && (c = h, h = arguments[1] || {}, l = 2), u === l && (h = this, --l); l < u; l++) if ((t = arguments[l]) != null) for (e in t)i = h[e], h !== (r = t[e]) && (c && r && (n(r) || (o = Array.isArray(r))) ? (o ? (o = !1, a = i && Array.isArray(i) ? i : []) : a = i && n(i) ? i : {}, h[e] = s(c, a, r)) : void 0 !== r && (h[e] = r)); return h; }; t.exports = s; }, function (t, e, i) {
  const n = i(0); const s = i(17); const r = i(1); const o = i(106); const a = i(105); const h = i(166); const l = i(74); const u = new n({
    initialize(t, e) { this.loader = t, this.cache = r(e, 'cache', !1), this.type = r(e, 'type', !1), this.key = r(e, 'key', !1); const i = this.key; if (t.prefix && t.prefix !== '' && (this.key = t.prefix + i), !this.type || !this.key) throw new Error(`Error calling 'Loader.${this.type}' invalid key provided.`); this.url = r(e, 'url'), void 0 === this.url ? this.url = `${t.path + i}.${r(e, 'extension', '')}` : typeof this.url !== 'function' && (this.url = t.path + this.url), this.src = '', this.xhrSettings = l(r(e, 'responseType', void 0)), r(e, 'xhrSettings', !1) && (this.xhrSettings = a(this.xhrSettings, r(e, 'xhrSettings', {}))), this.xhrLoader = null, this.state = typeof this.url === 'function' ? s.FILE_POPULATED : s.FILE_PENDING, this.bytesTotal = 0, this.bytesLoaded = -1, this.percentComplete = -1, this.crossOrigin = void 0, this.data = void 0, this.config = r(e, 'config', {}), this.multiFile, this.linkFile; }, setLink(t) { this.linkFile = t, t.linkFile = this; }, resetXHR() { this.xhrLoader && (this.xhrLoader.onload = void 0, this.xhrLoader.onerror = void 0, this.xhrLoader.onprogress = void 0); }, load() { this.state === s.FILE_POPULATED ? this.loader.nextFile(this, !0) : (this.src = o(this, this.loader.baseURL), this.src.indexOf('data:') === 0 ? console.warn(`Local data URIs are not supported: ${this.key}`) : this.xhrLoader = h(this, this.loader.xhr)); }, onLoad(t, e) { let i = !(e.target && e.target.status !== 200); t.readyState === 4 && t.status >= 400 && t.status <= 599 && (i = !1), this.resetXHR(), this.loader.nextFile(this, i); }, onError() { this.resetXHR(), this.loader.nextFile(this, !1); }, onProgress(t) { t.lengthComputable && (this.bytesLoaded = t.loaded, this.bytesTotal = t.total, this.percentComplete = Math.min(this.bytesLoaded / this.bytesTotal, 1), this.loader.emit('fileprogress', this, this.percentComplete)); }, onProcess() { this.state = s.FILE_PROCESSING, this.onProcessComplete(); }, onProcessComplete() { this.state = s.FILE_COMPLETE, this.multiFile && this.multiFile.onFileComplete(this), this.loader.fileProcessComplete(this); }, onProcessError() { this.state = s.FILE_ERRORED, this.multiFile && this.multiFile.onFileFailed(this), this.loader.fileProcessComplete(this); }, hasCacheConflict() { return this.cache && this.cache.exists(this.key); }, addToCache() { this.cache && this.cache.add(this.key, this.data), this.pendingDestroy(); }, pendingDestroy(t) { void 0 === t && (t = this.data); const e = this.key; const i = this.type; this.loader.emit('filecomplete', e, i, t), this.loader.emit(`filecomplete_${i}_${e}`, e, i, t), this.loader.flagForRemoval(this); }, destroy() { this.loader = null, this.cache = null, this.xhrSettings = null, this.multiFile = null, this.linkFile = null, this.data = null; },
  }); u.createObjectURL = function (t, e, i) { if (typeof URL === 'function')t.src = URL.createObjectURL(e); else { const n = new FileReader(); n.onload = function () { t.removeAttribute('crossOrigin'), t.src = `data:${e.type || i};base64,${n.result.split(',')[1]}`; }, n.onerror = t.onerror, n.readAsDataURL(e); } }, u.revokeObjectURL = function (t) { typeof URL === 'function' && URL.revokeObjectURL(t.src); }, t.exports = u;
}, function (t, e, i) {
  const n = {
    VERSION: '3.9.0', BlendModes: i(50), ScaleModes: i(58), AUTO: 0, CANVAS: 1, WEBGL: 2, HEADLESS: 3, FOREVER: -1, NONE: 4, UP: 5, DOWN: 6, LEFT: 7, RIGHT: 8,
  }; t.exports = n;
}, function (t, e, i) { const n = i(1); t.exports = function (t, e, i, s, r, o) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = o.width), void 0 === s && (s = o.height); const a = n(r, 'isNotEmpty', !1); const h = n(r, 'isColliding', !1); const l = n(r, 'hasInterestingFace', !1); t < 0 && (i += t, t = 0), e < 0 && (s += e, e = 0), t + i > o.width && (i = Math.max(o.width - t, 0)), e + s > o.height && (s = Math.max(o.height - e, 0)); for (var u = [], c = e; c < e + s; c++) for (let d = t; d < t + i; d++) { const f = o.data[c][d]; if (f !== null) { if (a && f.index === -1) continue; if (h && !f.collides) continue; if (l && !f.hasInterestingFace) continue; u.push(f); } } return u; }; }, function (t, e, i) {
  let n; let s; let r; const o = i(20); const a = i(128); const h = []; let l = !1; t.exports = {
    create2D(t, e, i) { return n(t, e, i, o.CANVAS); }, create: n = function (t, e, i, n, r) { let u; void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === n && (n = o.CANVAS), void 0 === r && (r = !1); let c = s(n); return c === null ? (c = { parent: t, canvas: document.createElement('canvas'), type: n }, n === o.CANVAS && h.push(c), u = c.canvas) : (c.parent = t, u = c.canvas), r && (c.parent = u), u.width = e, u.height = i, l && n === o.CANVAS && a.disable(u.getContext('2d')), u; }, createWebGL(t, e, i) { return n(t, e, i, o.WEBGL); }, disableSmoothing() { l = !0; }, enableSmoothing() { l = !1; }, first: s = function (t) { if (void 0 === t && (t = o.CANVAS), t === o.WEBGL) return null; for (let e = 0; e < h.length; e++) { const i = h[e]; if (!i.parent && i.type === t) return i; } return null; }, free() { return h.length - r(); }, pool: h, remove(t) { const e = t instanceof HTMLCanvasElement; h.forEach((i) => { (e && i.canvas === t || !e && i.parent === t) && (i.parent = null, i.canvas.width = 1, i.canvas.height = 1); }); }, total: r = function () { let t = 0; return h.forEach((e) => { e.parent && t++; }), t; },
  };
}, function (t, e) { t.exports = function (t, e, i) { return Math.max(e, Math.min(i, t)); }; }, function (t, e, i) { const n = i(50); const s = i(10); const r = i(58); t.exports = function (t, e, i) { e.x = s(i, 'x', 0), e.y = s(i, 'y', 0), e.depth = s(i, 'depth', 0), e.flipX = s(i, 'flipX', !1), e.flipY = s(i, 'flipY', !1); const o = s(i, 'scale', null); typeof o === 'number' ? e.setScale(o) : o !== null && (e.scaleX = s(o, 'x', 1), e.scaleY = s(o, 'y', 1)); const a = s(i, 'scrollFactor', null); typeof a === 'number' ? e.setScrollFactor(a) : a !== null && (e.scrollFactorX = s(a, 'x', 1), e.scrollFactorY = s(a, 'y', 1)), e.rotation = s(i, 'rotation', 0); const h = s(i, 'angle', null); h !== null && (e.angle = h), e.alpha = s(i, 'alpha', 1); const l = s(i, 'origin', null); if (typeof l === 'number')e.setOrigin(l); else if (l !== null) { const u = s(l, 'x', 0.5); const c = s(l, 'y', 0.5); e.setOrigin(u, c); } return e.scaleMode = s(i, 'scaleMode', r.DEFAULT), e.blendMode = s(i, 'blendMode', n.NORMAL), e.visible = s(i, 'visible', !0), s(i, 'add', !0) && t.sys.displayList.add(e), e.preUpdate && t.sys.updateList.add(e), e; }; }, function (t, e) { t.exports = function (t, e, i, n, s, r) { let o; void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 1); let a = 0; const h = t.length; if (r === 1) for (o = s; o < h; o++)t[o][e] = i + a * n, a++; else for (o = s; o >= 0; o--)t[o][e] = i + a * n, a++; return t; }; }, function (t, e) {
  t.exports = {
    CSV: 0, TILED_JSON: 1, ARRAY_2D: 2, WELTMEISTER: 3,
  };
}, function (t, e) {
  t.exports = {
    getTintFromFloats(t, e, i, n) { return ((255 & (255 * n | 0)) << 24 | (255 & (255 * t | 0)) << 16 | (255 & (255 * e | 0)) << 8 | 255 & (255 * i | 0)) >>> 0; }, getTintAppendFloatAlpha(t, e) { return ((255 & (255 * e | 0)) << 24 | t) >>> 0; }, getTintAppendFloatAlphaAndSwap(t, e) { return ((255 & (255 * e | 0)) << 24 | (255 & (0 | t)) << 16 | (255 & (t >> 8 | 0)) << 8 | 255 & (t >> 16 | 0)) >>> 0; }, getFloatsFromUintRGB(t) { return [(255 & (t >> 16 | 0)) / 255, (255 & (t >> 8 | 0)) / 255, (255 & (0 | t)) / 255]; }, getComponentCount(t, e) { for (var i = 0, n = 0; n < t.length; ++n) { const s = t[n]; s.type === e.FLOAT ? i += s.size : i += 1; } return i; },
  };
}, function (t, e, i) {
  const n = i(0); const s = i(17); const r = i(19); const o = i(6); const a = i(1); const h = i(4); const l = i(8); const u = new n({
    Extends: r,
    initialize(t, e, i, n, o) {
      let u = 'json'; if (l(e)) { const c = e; e = a(c, 'key'), i = a(c, 'url'), n = a(c, 'xhrSettings'), u = a(c, 'extension', u), o = a(c, 'dataKey', o); } const d = {
        type: 'json', cache: t.cacheManager.json, extension: u, responseType: 'text', key: e, url: i, xhrSettings: n, config: o,
      }; r.call(this, t, d), l(i) && (this.data = o ? h(i, o) : i, this.state = s.FILE_POPULATED);
    },
    onProcess() { if (this.state !== s.FILE_POPULATED) { this.state = s.FILE_PROCESSING; const t = JSON.parse(this.xhrLoader.responseText); const e = this.config; this.data = typeof e === 'string' ? h(t, e, t) : t; } this.onProcessComplete(); },
  }); o.register('json', function (t, e, i, n) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new u(this, t[s])); else this.addFile(new u(this, t, e, n, i)); return this; }), t.exports = u;
}, function (t, e) { t.exports = function (t, e, i, n) { const s = t.length; if (e < 0 || e > s || e >= i || i > s || e + i > s) { if (n) throw new Error('Range Error: Values outside acceptable range'); return !1; } return !0; }; }, function (t, e, i) {
  const n = i(0); const s = i(150); const r = i(284); var o = new n({
    initialize(t, e, i, n) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 255), this.r = 0, this.g = 0, this.b = 0, this.a = 255, this.gl = [0, 0, 0, 1], this._color = 0, this._color32 = 0, this._rgba = '', this.setTo(t, e, i, n); }, transparent() { return this.red = 0, this.green = 0, this.blue = 0, this.alpha = 0, this.update(); }, setTo(t, e, i, n) { return void 0 === n && (n = 255), this.red = t, this.green = e, this.blue = i, this.alpha = n, this.update(); }, setGLTo(t, e, i, n) { return void 0 === n && (n = 1), this.redGL = t, this.greenGL = e, this.blueGL = i, this.alphaGL = n, this.update(); }, setFromRGB(t) { return this.red = t.r, this.green = t.g, this.blue = t.b, t.hasOwnProperty('a') && (this.alpha = t.a), this.update(); }, update() { return this._color = s(this.r, this.g, this.b), this._color32 = r(this.r, this.g, this.b, this.a), this._rgba = `rgba(${this.r},${this.g},${this.b},${this.a / 255})`, this; }, clone() { return new o(this.r, this.g, this.b, this.a); }, color: { get() { return this._color; } }, color32: { get() { return this._color32; } }, rgba: { get() { return this._rgba; } }, redGL: { get() { return this.gl[0]; }, set(t) { this.gl[0] = Math.min(Math.abs(t), 1), this.r = Math.floor(255 * this.gl[0]), this.update(); } }, greenGL: { get() { return this.gl[1]; }, set(t) { this.gl[1] = Math.min(Math.abs(t), 1), this.g = Math.floor(255 * this.gl[1]), this.update(); } }, blueGL: { get() { return this.gl[2]; }, set(t) { this.gl[2] = Math.min(Math.abs(t), 1), this.b = Math.floor(255 * this.gl[2]), this.update(); } }, alphaGL: { get() { return this.gl[3]; }, set(t) { this.gl[3] = Math.min(Math.abs(t), 1), this.a = Math.floor(255 * this.gl[3]), this.update(); } }, red: { get() { return this.r; }, set(t) { t = Math.floor(Math.abs(t)), this.r = Math.min(t, 255), this.gl[0] = t / 255, this.update(); } }, green: { get() { return this.g; }, set(t) { t = Math.floor(Math.abs(t)), this.g = Math.min(t, 255), this.gl[1] = t / 255, this.update(); } }, blue: { get() { return this.b; }, set(t) { t = Math.floor(Math.abs(t)), this.b = Math.min(t, 255), this.gl[2] = t / 255, this.update(); } }, alpha: { get() { return this.a; }, set(t) { t = Math.floor(Math.abs(t)), this.a = Math.min(t, 255), this.gl[3] = t / 255, this.update(); } },
  }); t.exports = o;
}, function (t, e) { t.exports = function (t, e, i) { return !(t.width <= 0 || t.height <= 0) && t.x <= e && t.x + t.width >= e && t.y <= i && t.y + t.height >= i; }; }, function (t, e) { t.exports = function (t, e, i) { return t.radius > 0 && e >= t.left && e <= t.right && i >= t.top && i <= t.bottom && (t.x - e) * (t.x - e) + (t.y - i) * (t.y - i) <= t.radius * t.radius; }; }, function (t, e) { t.exports = function (t) { const e = {}; for (const i in t)Array.isArray(t[i]) ? e[i] = t[i].slice(0) : e[i] = t[i]; return e; }; }, function (t, e, i) {
  const n = i(0); const s = i(15); const r = i(2); const o = i(549); const a = new n({
    Extends: r, Mixins: [s.Alpha, s.BlendMode, s.Depth, s.Flip, s.GetBounds, s.Mask, s.Origin, s.Pipeline, s.ScaleMode, s.ScrollFactor, s.Size, s.Texture, s.Tint, s.Transform, s.Visible, o], initialize(t, e, i, n, o) { r.call(this, t, 'Sprite'), this.anims = new s.Animation(this), this.setTexture(n, o), this.setPosition(e, i), this.setSizeToFrame(), this.setOriginFromFrame(), this.initPipeline('TextureTintPipeline'); }, preUpdate(t, e) { this.anims.update(t, e); }, play(t, e, i) { return this.anims.play(t, e, i), this; }, toJSON() { return s.ToJSON(this); },
  }); t.exports = a;
}, function (t, e) { t.exports = function (t, e, i, n, s, r) { let o; void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 1); let a = 0; const h = t.length; if (r === 1) for (o = s; o < h; o++)t[o][e] += i + a * n, a++; else for (o = s; o >= 0; o--)t[o][e] += i + a * n, a++; return t; }; }, function (t, e, i) {
  const n = new (i(0))({
    initialize(t, e, i, n) { this.loader = t, this.type = e, this.key = i, this.files = n, this.complete = !1, this.pending = n.length, this.failed = 0, this.config = {}; for (let s = 0; s < n.length; s++)n[s].multiFile = this; }, isReadyToProcess() { return this.pending === 0 && this.failed === 0 && !this.complete; }, addToMultiFile(t) { return this.files.push(t), t.multiFile = this, this.pending++, this.complete = !1, this; }, onFileComplete(t) { this.files.indexOf(t) !== -1 && this.pending--; }, onFileFailed(t) { this.files.indexOf(t) !== -1 && this.failed++; },
  }); t.exports = n;
}, function (t, e, i) {
  const n = i(0); const s = i(17); const r = i(19); const o = i(6); const a = i(1); const h = i(8); const l = new n({
    Extends: r,
    initialize: function t(e, i, n, s, o) {
      let l; let u = 'png'; if (h(i)) { const c = i; i = a(c, 'key'), n = a(c, 'url'), l = a(c, 'normalMap'), s = a(c, 'xhrSettings'), u = a(c, 'extension', u), o = a(c, 'frameConfig'); }Array.isArray(n) && (l = n[1], n = n[0]); const d = {
        type: 'image', cache: e.textureManager, extension: u, responseType: 'blob', key: i, url: n, xhrSettings: s, config: o,
      }; if (r.call(this, e, d), l) { const f = new t(e, this.key, l, s, o); f.type = 'normalMap', this.setLink(f), e.addFile(f); }
    },
    onProcess() { this.state = s.FILE_PROCESSING, this.data = new Image(), this.data.crossOrigin = this.crossOrigin; const t = this; this.data.onload = function () { r.revokeObjectURL(t.data), t.onProcessComplete(); }, this.data.onerror = function () { r.revokeObjectURL(t.data), t.onProcessError(); }, r.createObjectURL(this.data, this.xhrLoader.response, 'image/png'); },
    addToCache() { let t; const e = this.linkFile; e && e.state === s.FILE_COMPLETE ? (t = this.type === 'image' ? this.cache.addImage(this.key, this.data, e.data) : this.cache.addImage(e.key, e.data, this.data), this.pendingDestroy(t), e.pendingDestroy(t)) : e || (t = this.cache.addImage(this.key, this.data), this.pendingDestroy(t)); },
  }); o.register('image', function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new l(this, t[n])); else this.addFile(new l(this, t, e, i)); return this; }), t.exports = l;
}, function (t, e, i) { const n = i(16); t.exports = function (t) { return t * n.DEG_TO_RAD; }; }, function (t, e) { t.exports = function (t, e, i) { const n = i - e; return e + ((t - e) % n + n) % n; }; }, function (t, e, i) { const n = i(137); const s = i(21); t.exports = function (t, e, i, r, o) { for (let a = null, h = null, l = null, u = null, c = s(t, e, i, r, null, o), d = 0; d < c.length; d++) { const f = c[d]; f && (f.collides ? (a = n(f.x, f.y - 1, !0, o), h = n(f.x, f.y + 1, !0, o), l = n(f.x - 1, f.y, !0, o), u = n(f.x + 1, f.y, !0, o), f.faceTop = !a || !a.collides, f.faceBottom = !h || !h.collides, f.faceLeft = !l || !l.collides, f.faceRight = !u || !u.collides) : f.resetFaces()); } }; }, function (t, e) { t.exports = function (t, e) { return t.y = e + t.height * t.originY, t; }; }, function (t, e) { t.exports = function (t) { return t.y - t.height * t.originY; }; }, function (t, e) { t.exports = function (t, e) { return t.x = e - t.width + t.width * t.originX, t; }; }, function (t, e) { t.exports = function (t) { return t.x + t.width - t.width * t.originX; }; }, function (t, e) { t.exports = function (t, e) { return t.x = e + t.width * t.originX, t; }; }, function (t, e) { t.exports = function (t) { return t.x - t.width * t.originX; }; }, function (t, e) { t.exports = function (t, e) { return t.y = e - t.height + t.height * t.originY, t; }; }, function (t, e) { t.exports = function (t) { return t.y + t.height - t.height * t.originY; }; }, function (t, e) { const i = {}; t.exports = i, (function () { i._nextId = 0, i._seed = 0, i._nowStartTime = +new Date(), i.extend = function (t, e) { let n; let s; typeof e === 'boolean' ? (n = 2, s = e) : (n = 1, s = !0); for (let r = n; r < arguments.length; r++) { const o = arguments[r]; if (o) for (const a in o)s && o[a] && o[a].constructor === Object ? t[a] && t[a].constructor !== Object ? t[a] = o[a] : (t[a] = t[a] || {}, i.extend(t[a], s, o[a])) : t[a] = o[a]; } return t; }, i.clone = function (t, e) { return i.extend({}, e, t); }, i.keys = function (t) { if (Object.keys) return Object.keys(t); const e = []; for (const i in t)e.push(i); return e; }, i.values = function (t) { const e = []; if (Object.keys) { for (let i = Object.keys(t), n = 0; n < i.length; n++)e.push(t[i[n]]); return e; } for (const s in t)e.push(t[s]); return e; }, i.get = function (t, e, i, n) { e = e.split('.').slice(i, n); for (let s = 0; s < e.length; s += 1)t = t[e[s]]; return t; }, i.set = function (t, e, n, s, r) { const o = e.split('.').slice(s, r); return i.get(t, e, 0, -1)[o[o.length - 1]] = n, n; }, i.shuffle = function (t) { for (let e = t.length - 1; e > 0; e--) { const n = Math.floor(i.random() * (e + 1)); const s = t[e]; t[e] = t[n], t[n] = s; } return t; }, i.choose = function (t) { return t[Math.floor(i.random() * t.length)]; }, i.isElement = function (t) { return t instanceof HTMLElement; }, i.isArray = function (t) { return Object.prototype.toString.call(t) === '[object Array]'; }, i.isFunction = function (t) { return typeof t === 'function'; }, i.isPlainObject = function (t) { return typeof t === 'object' && t.constructor === Object; }, i.isString = function (t) { return Object.prototype.toString.call(t) === '[object String]'; }, i.clamp = function (t, e, i) { return t < e ? e : t > i ? i : t; }, i.sign = function (t) { return t < 0 ? -1 : 1; }, i.now = function () { if (window.performance) { if (window.performance.now) return window.performance.now(); if (window.performance.webkitNow) return window.performance.webkitNow(); } return new Date() - i._nowStartTime; }, i.random = function (e, i) { return e = void 0 !== e ? e : 0, i = void 0 !== i ? i : 1, e + t() * (i - e); }; var t = function () { return i._seed = (9301 * i._seed + 49297) % 233280, i._seed / 233280; }; i.colorToNumber = function (t) { return (t = t.replace('#', '')).length == 3 && (t = t.charAt(0) + t.charAt(0) + t.charAt(1) + t.charAt(1) + t.charAt(2) + t.charAt(2)), parseInt(t, 16); }, i.logLevel = 1, i.log = function () { console && i.logLevel > 0 && i.logLevel <= 3 && console.log.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments))); }, i.info = function () { console && i.logLevel > 0 && i.logLevel <= 2 && console.info.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments))); }, i.warn = function () { console && i.logLevel > 0 && i.logLevel <= 3 && console.warn.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments))); }, i.nextId = function () { return i._nextId++; }, i.map = function (t, e) { if (t.map) return t.map(e); for (var i = [], n = 0; n < t.length; n += 1)i.push(e(t[n])); return i; }, i.topologicalSort = function (t) { const i = []; const n = []; const s = []; for (const r in t)n[r] || s[r] || e(r, n, s, t, i); return i; }; var e = function (t, i, n, s, r) { const o = s[t] || []; n[t] = !0; for (let a = 0; a < o.length; a += 1) { const h = o[a]; n[h] || (i[h] || e(h, i, n, s, r)); }n[t] = !1, i[t] = !0, r.push(t); }; i.chain = function () { for (var t = [], e = 0; e < arguments.length; e += 1) { const i = arguments[e]; i._chained ? t.push.apply(t, i._chained) : t.push(i); } const n = function () { for (var e, i = new Array(arguments.length), n = 0, s = arguments.length; n < s; n++)i[n] = arguments[n]; for (n = 0; n < t.length; n += 1) { const r = t[n].apply(e, i); void 0 !== r && (e = r); } return e; }; return n._chained = t, n; }, i.chainPathBefore = function (t, e, n) { return i.set(t, e, i.chain(n, i.get(t, e))); }, i.chainPathAfter = function (t, e, n) { return i.set(t, e, i.chain(i.get(t, e), n)); }; }()); }, function (t, e) {
  t.exports = {
    SKIP_CHECK: -1, NORMAL: 0, ADD: 1, MULTIPLY: 2, SCREEN: 3, OVERLAY: 4, DARKEN: 5, LIGHTEN: 6, COLOR_DODGE: 7, COLOR_BURN: 8, HARD_LIGHT: 9, SOFT_LIGHT: 10, DIFFERENCE: 11, EXCLUSION: 12, HUE: 13, SATURATION: 14, COLOR: 15, LUMINOSITY: 16,
  };
}, function (t, e) { t.exports = function (t, e, i, n) { void 0 === e && (e = !0); let s = n.baseTileHeight; const r = n.tilemapLayer; return r && (void 0 === i && (i = r.scene.cameras.main), t -= r.y + i.scrollY * (1 - r.scrollFactorY), s *= r.scaleY), e ? Math.floor(t / s) : t / s; }; }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === e && (e = !0); let s = n.baseTileWidth; const r = n.tilemapLayer; return r && (void 0 === i && (i = r.scene.cameras.main), t -= r.x + i.scrollX * (1 - r.scrollFactorX), s *= r.scaleX), e ? Math.floor(t / s) : t / s; }; }, function (t, e) { t.exports = function (t, e, i) { if (t.width <= 0 || t.height <= 0) return !1; let n = (e - t.x) / t.width; let s = (i - t.y) / t.height; return (n *= n) + (s *= s) < 0.25; }; }, function (t, e) {
  t.exports = {
    PENDING: 0, INIT: 1, START: 2, LOADING: 3, CREATING: 4, RUNNING: 5, PAUSED: 6, SLEEPING: 7, SHUTDOWN: 8, DESTROYED: 9,
  };
}, function (t, e) { t.exports = function (t, e) { if (!(e >= t.length)) { for (var i = t.length - 1, n = t[e], s = e; s < i; s++)t[s] = t[s + 1]; return t.length = i, n; } }; }, function (t, e, i) {
  (function (e) {
    const i = {
      android: !1, chromeOS: !1, cocoonJS: !1, cocoonJSApp: !1, cordova: !1, crosswalk: !1, desktop: !1, ejecta: !1, electron: !1, iOS: !1, iOSVersion: 0, iPad: !1, iPhone: !1, kindle: !1, linux: !1, macOS: !1, node: !1, nodeWebkit: !1, pixelRatio: 1, webApp: !1, windows: !1, windowsPhone: !1,
    }; t.exports = (function () { const t = navigator.userAgent; /Windows/.test(t) ? i.windows = !0 : /Mac OS/.test(t) ? i.macOS = !0 : /Linux/.test(t) ? i.linux = !0 : /Android/.test(t) ? i.android = !0 : /iP[ao]d|iPhone/i.test(t) ? (i.iOS = !0, navigator.appVersion.match(/OS (\d+)/), i.iOSVersion = parseInt(RegExp.$1, 10)) : /Kindle/.test(t) || /\bKF[A-Z][A-Z]+/.test(t) || /Silk.*Mobile Safari/.test(t) ? i.kindle = !0 : /CrOS/.test(t) && (i.chromeOS = !0), (/Windows Phone/i.test(t) || /IEMobile/i.test(t)) && (i.android = !1, i.iOS = !1, i.macOS = !1, i.windows = !0, i.windowsPhone = !0); const n = /Silk/.test(t); if ((i.windows || i.macOS || i.linux && !n || i.chromeOS) && (i.desktop = !0), (i.windowsPhone || /Windows NT/i.test(t) && /Touch/i.test(t)) && (i.desktop = !1), navigator.standalone && (i.webApp = !0), void 0 !== window.cordova && (i.cordova = !0), e && e.versions && e.versions.node && (i.node = !0), i.node && typeof e.versions === 'object' && (i.nodeWebkit = !!e.versions['node-webkit'], i.electron = !!e.versions.electron), navigator.isCocoonJS) { i.cocoonJS = !0; try { i.cocoonJSApp = typeof CocoonJS !== 'undefined'; } catch (t) { i.cocoonJSApp = !1; } } return void 0 !== window.ejecta && (i.ejecta = !0), /Crosswalk/.test(t) && (i.crosswalk = !0), i.iPhone = t.toLowerCase().indexOf('iphone') !== -1, i.iPad = t.toLowerCase().indexOf('ipad') !== -1, i.pixelRatio = window.devicePixelRatio || 1, i; }());
  }).call(this, i(530));
}, function (t, e) { t.exports = function (t, e, i, n) { const s = t - i; const r = e - n; return Math.sqrt(s * s + r * r); }; }, function (t, e) { t.exports = { DEFAULT: 0, LINEAR: 0, NEAREST: 1 }; }, function (t, e) { t.exports = function (t, e, i) { const n = t.x3 - t.x1; const s = t.y3 - t.y1; const r = t.x2 - t.x1; const o = t.y2 - t.y1; const a = e - t.x1; const h = i - t.y1; const l = n * n + s * s; const u = n * r + s * o; const c = n * a + s * h; const d = r * r + o * o; const f = r * a + o * h; const p = l * d - u * u; const g = p === 0 ? 0 : 1 / p; const v = (d * c - u * f) * g; const y = (l * f - u * c) * g; return v >= 0 && y >= 0 && v + y < 1; }; }, function (t, e) {
  t.exports = {
    CREATED: 0, INIT: 1, DELAY: 2, OFFSET_DELAY: 3, PENDING_RENDER: 4, PLAYING_FORWARD: 5, PLAYING_BACKWARD: 6, HOLD_DELAY: 7, REPEAT_DELAY: 8, COMPLETE: 9, PENDING_ADD: 20, PAUSED: 21, LOOP_DELAY: 22, ACTIVE: 23, COMPLETE_DELAY: 24, PENDING_REMOVE: 25, REMOVED: 26,
  };
}, function (t, e) { t.exports = function (t, e, i) { return t && t.hasOwnProperty(e) ? t[e] : i; }; }, function (t, e, i) { const n = i(440); t.exports = function (t, e) { if (typeof t === 'string' && n.hasOwnProperty(t)) { if (e) { const i = e.slice(0); return i.unshift(0), function (e) { return i[0] = e, n[t].apply(this, i); }; } return n[t]; } return typeof t === 'function' ? t : (Array.isArray(t) && t.length, n.Power0); }; }, function (t, e, i) {
  const n = new (i(0))({
    initialize(t, e, i, n, s, r) {
      void 0 === t && (t = 1), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 1), void 0 === s && (s = 0), void 0 === r && (r = 0), this.matrix = new Float32Array([t, e, i, n, s, r, 0, 0, 1]), this.decomposedMatrix = {
        translateX: 0, translateY: 0, scaleX: 1, scaleY: 1, rotation: 0,
      };
    },
    a: { get() { return this.matrix[0]; }, set(t) { this.matrix[0] = t; } },
    b: { get() { return this.matrix[1]; }, set(t) { this.matrix[1] = t; } },
    c: { get() { return this.matrix[2]; }, set(t) { this.matrix[2] = t; } },
    d: { get() { return this.matrix[3]; }, set(t) { this.matrix[3] = t; } },
    tx: { get() { return this.matrix[4]; }, set(t) { this.matrix[4] = t; } },
    ty: { get() { return this.matrix[5]; }, set(t) { this.matrix[5] = t; } },
    rotation: { get() { return Math.acos(this.a / this.scaleX) * (Math.atan(-this.c / this.a) < 0 ? -1 : 1); } },
    scaleX: { get() { return Math.sqrt(this.a * this.a + this.c * this.c); } },
    scaleY: { get() { return Math.sqrt(this.b * this.b + this.d * this.d); } },
    loadIdentity() { const t = this.matrix; return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, this; },
    translate(t, e) { const i = this.matrix; return i[4] = i[0] * t + i[2] * e + i[4], i[5] = i[1] * t + i[3] * e + i[5], this; },
    scale(t, e) { const i = this.matrix; return i[0] *= t, i[1] *= t, i[2] *= e, i[3] *= e, this; },
    rotate(t) { const e = Math.sin(t); const i = Math.cos(t); const n = this.matrix; const s = n[0]; const r = n[1]; const o = n[2]; const a = n[3]; return n[0] = s * i + o * e, n[1] = r * i + a * e, n[2] = s * -e + o * i, n[3] = r * -e + a * i, this; },
    multiply(t) { const e = this.matrix; const i = t.matrix; const n = e[0]; const s = e[1]; const r = e[2]; const o = e[3]; const a = e[4]; const h = e[5]; const l = i[0]; const u = i[1]; const c = i[2]; const d = i[3]; const f = i[4]; const p = i[5]; return e[0] = l * n + u * r, e[1] = l * s + u * o, e[2] = c * n + d * r, e[3] = c * s + d * o, e[4] = f * n + p * r + a, e[5] = f * s + p * o + h, this; },
    transform(t, e, i, n, s, r) { const o = this.matrix; const a = o[0]; const h = o[1]; const l = o[2]; const u = o[3]; const c = o[4]; const d = o[5]; return o[0] = t * a + e * l, o[1] = t * h + e * u, o[2] = i * a + n * l, o[3] = i * h + n * u, o[4] = s * a + r * l + c, o[5] = s * h + r * u + d, this; },
    transformPoint(t, e, i) { void 0 === i && (i = { x: 0, y: 0 }); const n = this.matrix; const s = n[0]; const r = n[1]; const o = n[2]; const a = n[3]; const h = n[4]; const l = n[5]; return i.x = t * s + e * o + h, i.y = t * r + e * a + l, i; },
    invert() { const t = this.matrix; const e = t[0]; const i = t[1]; const n = t[2]; const s = t[3]; const r = t[4]; const o = t[5]; const a = e * s - i * n; return t[0] = s / a, t[1] = -i / a, t[2] = -n / a, t[3] = e / a, t[4] = (n * o - s * r) / a, t[5] = -(e * o - i * r) / a, this; },
    setTransform(t, e, i, n, s, r) { const o = this.matrix; return o[0] = t, o[1] = e, o[2] = i, o[3] = n, o[4] = s, o[5] = r, this; },
    decomposeMatrix() { const t = this.decomposedMatrix; const e = this.matrix; const i = e[0]; const n = e[1]; const s = e[2]; const r = e[3]; const o = i * i; const a = n * n; const h = s * s; const l = r * r; const u = Math.sqrt(o + h); const c = Math.sqrt(a + l); return t.translateX = e[4], t.translateY = e[5], t.scaleX = u, t.scaleY = c, t.rotation = Math.acos(i / u) * (Math.atan(-s / i) < 0 ? -1 : 1), t; },
    applyITRS(t, e, i, n, s) { const r = this.matrix; const o = Math.sin(i); const a = Math.cos(i); return r[4] = t, r[5] = e, r[0] = a * n, r[1] = o * n, r[2] = -o * s, r[3] = a * s, this; },
    destroy() { this.matrix = null, this.decomposedMatrix = null; },
  }); t.exports = n;
}, function (t, e, i) { const n = i(23); t.exports = function (t, e, i) { return (i - e) * (t = n(t, 0, 1)); }; }, function (t, e, i) {
  const n = i(0); const s = i(15); const r = i(376); const o = new n({
    Mixins: [s.Alpha, s.Flip, s.Visible], initialize(t, e, i, n, s, r, o, a) { this.layer = t, this.index = e, this.x = i, this.y = n, this.width = s, this.height = r, this.baseWidth = void 0 !== o ? o : s, this.baseHeight = void 0 !== a ? a : r, this.pixelX = 0, this.pixelY = 0, this.updatePixelXY(), this.properties = {}, this.rotation = 0, this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.faceLeft = !1, this.faceRight = !1, this.faceTop = !1, this.faceBottom = !1, this.collisionCallback = null, this.collisionCallbackContext = this, this.tint = 16777215, this.physics = {}; }, containsPoint(t, e) { return !(t < this.pixelX || e < this.pixelY || t > this.right || e > this.bottom); }, copy(t) { return this.index = t.index, this.alpha = t.alpha, this.properties = t.properties, this.visible = t.visible, this.setFlip(t.flipX, t.flipY), this.tint = t.tint, this.rotation = t.rotation, this.collideUp = t.collideUp, this.collideDown = t.collideDown, this.collideLeft = t.collideLeft, this.collideRight = t.collideRight, this.collisionCallback = t.collisionCallback, this.collisionCallbackContext = t.collisionCallbackContext, this; }, getCollisionGroup() { return this.tileset ? this.tileset.getTileCollisionGroup(this.index) : null; }, getTileData() { return this.tileset ? this.tileset.getTileData(this.index) : null; }, getLeft(t) { const e = this.tilemapLayer; return e ? e.tileToWorldX(this.x, t) : this.x * this.baseWidth; }, getRight(t) { const e = this.tilemapLayer; return e ? this.getLeft(t) + this.width * e.scaleX : this.getLeft(t) + this.width; }, getTop(t) { const e = this.tilemapLayer; return e ? e.tileToWorldY(this.y, t) - (this.height - this.baseHeight) * e.scaleY : this.y * this.baseHeight - (this.height - this.baseHeight); }, getBottom(t) { const e = this.tilemapLayer; return e ? this.getTop(t) + this.height * e.scaleY : this.getTop(t) + this.height; }, getBounds(t, e) { return void 0 === e && (e = new r()), e.x = this.getLeft(), e.y = this.getTop(), e.width = this.getRight() - e.x, e.height = this.getBottom() - e.y, e; }, getCenterX(t) { return this.getLeft(t) + this.width / 2; }, getCenterY(t) { return this.getTop(t) + this.height / 2; }, destroy() { this.collisionCallback = void 0, this.collisionCallbackContext = void 0, this.properties = void 0; }, intersects(t, e, i, n) { return !(i <= this.pixelX || n <= this.pixelY || t >= this.right || e >= this.bottom); }, isInteresting(t, e) { return t && e ? this.canCollide || this.hasInterestingFace : t ? this.collides : !!e && this.hasInterestingFace; }, resetCollision(t) { (void 0 === t && (t = !0), this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1, t) && (this.tilemapLayer && this.tilemapLayer.calculateFacesAt(this.x, this.y)); return this; }, resetFaces() { return this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1, this; }, setCollision(t, e, i, n, s) { (void 0 === e && (e = t), void 0 === i && (i = t), void 0 === n && (n = t), void 0 === s && (s = !0), this.collideLeft = t, this.collideRight = e, this.collideUp = i, this.collideDown = n, this.faceLeft = t, this.faceRight = e, this.faceTop = i, this.faceBottom = n, s) && (this.tilemapLayer && this.tilemapLayer.calculateFacesAt(this.x, this.y)); return this; }, setCollisionCallback(t, e) { return t === null ? (this.collisionCallback = void 0, this.collisionCallbackContext = void 0) : (this.collisionCallback = t, this.collisionCallbackContext = e), this; }, setSize(t, e, i, n) { return void 0 !== t && (this.width = t), void 0 !== e && (this.height = e), void 0 !== i && (this.baseWidth = i), void 0 !== n && (this.baseHeight = n), this.updatePixelXY(), this; }, updatePixelXY() { return this.pixelX = this.x * this.baseWidth, this.pixelY = this.y * this.baseHeight - (this.height - this.baseHeight), this; }, canCollide: { get() { return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback; } }, collides: { get() { return this.collideLeft || this.collideRight || this.collideUp || this.collideDown; } }, hasInterestingFace: { get() { return this.faceTop || this.faceBottom || this.faceLeft || this.faceRight; } }, tileset: { get() { const t = this.tilemapLayer; return t ? t.tileset : null; } }, tilemapLayer: { get() { return this.layer.tilemapLayer; } }, tilemap: { get() { const t = this.tilemapLayer; return t ? t.tilemap : null; } },
  }); t.exports = o;
}, function (t, e) { t.exports = function (t, e) { e ? t.setCollision(!0, !0, !0, !0, !1) : t.resetCollision(!1); }; }, function (t, e) {
  t.exports = {
    DYNAMIC_BODY: 0, STATIC_BODY: 1, GROUP: 2, TILEMAPLAYER: 3, FACING_NONE: 10, FACING_UP: 11, FACING_DOWN: 12, FACING_LEFT: 13, FACING_RIGHT: 14,
  };
}, function (t, e, i) {
  const n = i(0); const s = i(59); const r = i(226); const o = i(225); const a = i(95); const h = i(151); const l = new n({
    initialize(t, e, i, n, s, r) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 0), this.x1 = t, this.y1 = e, this.x2 = i, this.y2 = n, this.x3 = s, this.y3 = r; }, contains(t, e) { return s(this, t, e); }, getPoint(t, e) { return r(this, t, e); }, getPoints(t, e, i) { return o(this, t, e, i); }, getRandomPoint(t) { return h(this, t); }, setTo(t, e, i, n, s, r) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 0), this.x1 = t, this.y1 = e, this.x2 = i, this.y2 = n, this.x3 = s, this.y3 = r, this; }, getLineA(t) { return void 0 === t && (t = new a()), t.setTo(this.x1, this.y1, this.x2, this.y2), t; }, getLineB(t) { return void 0 === t && (t = new a()), t.setTo(this.x2, this.y2, this.x3, this.y3), t; }, getLineC(t) { return void 0 === t && (t = new a()), t.setTo(this.x3, this.y3, this.x1, this.y1), t; }, left: { get() { return Math.min(this.x1, this.x2, this.x3); }, set(t) { let e = 0; e = this.x1 <= this.x2 && this.x1 <= this.x3 ? this.x1 - t : this.x2 <= this.x1 && this.x2 <= this.x3 ? this.x2 - t : this.x3 - t, this.x1 -= e, this.x2 -= e, this.x3 -= e; } }, right: { get() { return Math.max(this.x1, this.x2, this.x3); }, set(t) { let e = 0; e = this.x1 >= this.x2 && this.x1 >= this.x3 ? this.x1 - t : this.x2 >= this.x1 && this.x2 >= this.x3 ? this.x2 - t : this.x3 - t, this.x1 -= e, this.x2 -= e, this.x3 -= e; } }, top: { get() { return Math.min(this.y1, this.y2, this.y3); }, set(t) { let e = 0; e = this.y1 <= this.y2 && this.y1 <= this.y3 ? this.y1 - t : this.y2 <= this.y1 && this.y2 <= this.y3 ? this.y2 - t : this.y3 - t, this.y1 -= e, this.y2 -= e, this.y3 -= e; } }, bottom: { get() { return Math.max(this.y1, this.y2, this.y3); }, set(t) { let e = 0; e = this.y1 >= this.y2 && this.y1 >= this.y3 ? this.y1 - t : this.y2 >= this.y1 && this.y2 >= this.y3 ? this.y2 - t : this.y3 - t, this.y1 -= e, this.y2 -= e, this.y3 -= e; } },
  }); t.exports = l;
}, function (t, e, i) { const n = i(0); const s = i(15); const r = i(2); const o = i(448); const a = new n({ Extends: r, Mixins: [s.Alpha, s.BlendMode, s.Depth, s.Flip, s.GetBounds, s.Mask, s.Origin, s.Pipeline, s.ScaleMode, s.ScrollFactor, s.Size, s.Texture, s.Tint, s.Transform, s.Visible, o], initialize(t, e, i, n, s) { r.call(this, t, 'Image'), this.setTexture(n, s), this.setPosition(e, i), this.setSizeToFrame(), this.setOriginFromFrame(), this.initPipeline('TextureTintPipeline'); } }); t.exports = a; }, function (t, e, i) {
  var n = new (i(0))({
    initialize(t) { if (this.entries = [], Array.isArray(t)) for (let e = 0; e < t.length; e++) this.set(t[e]); }, set(t) { return this.entries.indexOf(t) === -1 && this.entries.push(t), this; }, get(t, e) { for (let i = 0; i < this.entries.length; i++) { const n = this.entries[i]; if (n[t] === e) return n; } }, getArray() { return this.entries.slice(0); }, delete(t) { const e = this.entries.indexOf(t); return e > -1 && this.entries.splice(e, 1), this; }, dump() { console.group('Set'); for (let t = 0; t < this.entries.length; t++) { const e = this.entries[t]; console.log(e); }console.groupEnd(); }, each(t, e) { let i; const n = this.entries.slice(); const s = n.length; if (e) for (i = 0; i < s && !1 !== t.call(e, n[i], i); i++);else for (i = 0; i < s && !1 !== t(n[i], i); i++);return this; }, iterate(t, e) { let i; const n = this.entries.length; if (e) for (i = 0; i < n && !1 !== t.call(e, this.entries[i], i); i++);else for (i = 0; i < n && !1 !== t(this.entries[i], i); i++);return this; }, iterateLocal(t) { let e; const i = []; for (e = 1; e < arguments.length; e++)i.push(arguments[e]); const n = this.entries.length; for (e = 0; e < n; e++) { const s = this.entries[e]; s[t].apply(s, i); } return this; }, clear() { return this.entries.length = 0, this; }, contains(t) { return this.entries.indexOf(t) > -1; }, union(t) { const e = new n(); return t.entries.forEach((t) => { e.set(t); }), this.entries.forEach((t) => { e.set(t); }), e; }, intersect(t) { const e = new n(); return this.entries.forEach((i) => { t.contains(i) && e.set(i); }), e; }, difference(t) { const e = new n(); return this.entries.forEach((i) => { t.contains(i) || e.set(i); }), e; }, size: { get() { return this.entries.length; }, set(t) { return this.entries.length = t; } },
  }); t.exports = n;
}, function (t, e) { t.exports = function (t) { return Math.sqrt((t.x2 - t.x1) * (t.x2 - t.x1) + (t.y2 - t.y1) * (t.y2 - t.y1)); }; }, function (t, e, i) { const n = i(99); const s = i(10); const r = i(61); const o = i(62); const a = i(73); const h = i(161); const l = i(101); const u = i(4); const c = i(100); const d = i(98); const f = i(97); t.exports = function (t, e, i) { void 0 === i && (i = n); for (var p = i.targets ? i.targets : l(e), g = h(e), v = a(e, 'delay', i.delay), y = a(e, 'duration', i.duration), m = u(e, 'easeParams', i.easeParams), x = o(u(e, 'ease', i.ease), m), w = a(e, 'hold', i.hold), b = a(e, 'repeat', i.repeat), T = a(e, 'repeatDelay', i.repeatDelay), S = r(e, 'yoyo', i.yoyo), A = r(e, 'flipX', i.flipX), C = r(e, 'flipY', i.flipY), M = [], _ = 0; _ < g.length; _++) for (let E = g[_].key, P = g[_].value, L = 0; L < p.length; L++) { const F = c(E, P); const k = f(p[L], E, F.getEnd, F.getStart, o(u(P, 'ease', x), m), a(P, 'delay', v), a(P, 'duration', y), r(P, 'yoyo', S), a(P, 'hold', w), a(P, 'repeat', b), a(P, 'repeatDelay', T), r(P, 'flipX', A), r(P, 'flipY', C)); M.push(k); } const R = new d(t, M, p); R.offset = s(e, 'offset', null), R.completeDelay = s(e, 'completeDelay', 0), R.loop = Math.round(s(e, 'loop', 0)), R.loopDelay = Math.round(s(e, 'loopDelay', 0)), R.paused = r(e, 'paused', !1), R.useFrames = r(e, 'useFrames', !1); for (let O = u(e, 'callbackScope', R), B = [R, null], D = d.TYPES, I = 0; I < D.length; I++) { const z = D[I]; const Y = u(e, z, !1); if (Y) { const X = u(e, `${z}Scope`, O); const N = u(e, `${z}Params`, []); R.setCallback(z, Y, B.concat(N), X); } } return R; }; }, function (t, e) { t.exports = function (t, e, i) { let n; n = t.hasOwnProperty(e) ? typeof t[e] === 'function' ? function (i, n, s) { return t[e](i, n, s); } : function () { return t[e]; } : typeof i === 'function' ? i : function () { return i; }; return n; }; }, function (t, e) {
  t.exports = function (t, e, i, n, s) {
    return void 0 === t && (t = ''), void 0 === e && (e = !0), void 0 === i && (i = ''), void 0 === n && (n = ''), void 0 === s && (s = 0), {
      responseType: t, async: e, user: i, password: n, timeout: s, header: void 0, headerValue: void 0, requestedWith: !1, overrideMimeType: void 0,
    };
  };
}, function (t, e, i) { const n = i(113); const s = i(173); t.exports = function (t, e) { if (void 0 === e && (e = 90), !n(t)) return null; if (typeof e !== 'string' && (e = (e % 360 + 360) % 360), e === 90 || e === -270 || e === 'rotateLeft')(t = s(t)).reverse(); else if (e === -90 || e === 270 || e === 'rotateRight')t.reverse(), t = s(t); else if (Math.abs(e) === 180 || e === 'rotate180') { for (let i = 0; i < t.length; i++)t[i].reverse(); t.reverse(); } return t; }; }, function (t, e, i) {
  const n = i(0); const s = i(9); const r = i(18); const o = i(3); const a = new n({
    Extends: s,
    initialize(t, e, i) {
      s.call(this), this.manager = t, this.key = e, this.isPlaying = !1, this.isPaused = !1, this.totalRate = 1, this.duration = this.duration || 0, this.totalDuration = this.totalDuration || 0, this.config = {
        mute: !1, volume: 1, rate: 1, detune: 0, seek: 0, loop: !1, delay: 0,
      }, this.currentConfig = this.config, this.config = r(this.config, i), this.markers = {}, this.currentMarker = null, this.pendingRemove = !1;
    },
    addMarker(t) {
      return !(!t || !t.name || typeof t.name !== 'string') && (this.markers[t.name] ? (console.error(`addMarker ${t.name} already exists in Sound`), !1) : (t = r(!0, {
        name: '',
        start: 0,
        duration: this.totalDuration - (t.start || 0),
        config: {
          mute: !1, volume: 1, rate: 1, detune: 0, seek: 0, loop: !1, delay: 0,
        },
      }, t), this.markers[t.name] = t, !0));
    },
    updateMarker(t) { return !(!t || !t.name || typeof t.name !== 'string') && (this.markers[t.name] ? (this.markers[t.name] = r(!0, this.markers[t.name], t), !0) : (console.warn(`Audio Marker: ${t.name} missing in Sound: ${this.key}`), !1)); },
    removeMarker(t) { const e = this.markers[t]; return e ? (this.markers[t] = null, e) : null; },
    play(t, e) { if (void 0 === t && (t = ''), typeof t === 'object' && (e = t, t = ''), typeof t !== 'string') return !1; if (t) { if (!this.markers[t]) return console.warn(`Marker: ${t} missing in Sound: ${this.key}`), !1; this.currentMarker = this.markers[t], this.currentConfig = this.currentMarker.config, this.duration = this.currentMarker.duration; } else this.currentMarker = null, this.currentConfig = this.config, this.duration = this.totalDuration; return this.resetConfig(), this.currentConfig = r(this.currentConfig, e), this.isPlaying = !0, this.isPaused = !1, !0; },
    pause() { return !(this.isPaused || !this.isPlaying) && (this.isPlaying = !1, this.isPaused = !0, !0); },
    resume() { return !(!this.isPaused || this.isPlaying) && (this.isPlaying = !0, this.isPaused = !1, !0); },
    stop() { return !(!this.isPaused && !this.isPlaying) && (this.isPlaying = !1, this.isPaused = !1, this.resetConfig(), !0); },
    applyConfig() { this.mute = this.currentConfig.mute, this.volume = this.currentConfig.volume, this.rate = this.currentConfig.rate, this.detune = this.currentConfig.detune, this.loop = this.currentConfig.loop; },
    resetConfig() { this.currentConfig.seek = 0, this.currentConfig.delay = 0; },
    update: o,
    calculateRate() { const t = this.currentConfig.detune + this.manager.detune; const e = Math.pow(1.0005777895065548, t); this.totalRate = this.currentConfig.rate * this.manager.rate * e; },
    destroy() { this.pendingRemove || (this.emit('destroy', this), this.pendingRemove = !0, this.manager = null, this.key = '', this.removeAllListeners(), this.isPlaying = !1, this.isPaused = !1, this.config = null, this.currentConfig = null, this.markers = null, this.currentMarker = null); },
  }); t.exports = a;
}, function (t, e, i) {
  const n = i(0); const s = i(33); const r = i(9); const o = i(3); const a = new n({
    Extends: r,
    initialize(t) { r.call(this), this.game = t, this.jsonCache = t.cache.json, this.sounds = [], this.mute = !1, this.volume = 1, this.pauseOnBlur = !0, this._rate = 1, this._detune = 0, this.locked = this.locked || !1, this.unlocked = !1, t.events.on('blur', function () { this.pauseOnBlur && this.onBlur(); }, this), t.events.on('focus', function () { this.pauseOnBlur && this.onFocus(); }, this), t.events.on('prestep', this.update, this), t.events.once('destroy', this.destroy, this); },
    add: o,
    addAudioSprite(t, e) {
      void 0 === e && (e = {}); const i = this.add(t, e); for (const n in i.spritemap = this.jsonCache.get(t).spritemap, i.spritemap) {
        if (i.spritemap.hasOwnProperty(n)) {
          const r = s(e); const o = i.spritemap[n]; r.loop = !!o.hasOwnProperty('loop') && o.loop, i.addMarker({
            name: n, start: o.start, duration: o.end - o.start, config: r,
          });
        }
      } return i;
    },
    play(t, e) { const i = this.add(t); return i.once('ended', i.destroy, i), e ? e.name ? (i.addMarker(e), i.play(e.name)) : i.play(e) : i.play(); },
    playAudioSprite(t, e, i) { const n = this.addAudioSprite(t); return n.once('ended', n.destroy, n), n.play(e, i); },
    remove(t) { const e = this.sounds.indexOf(t); return e !== -1 && (t.destroy(), this.sounds.splice(e, 1), !0); },
    removeByKey(t) { for (var e = 0, i = this.sounds.length - 1; i >= 0; i--) { const n = this.sounds[i]; n.key === t && (n.destroy(), this.sounds.splice(i, 1), e++); } return e; },
    pauseAll() { this.forEachActiveSound((t) => { t.pause(); }), this.emit('pauseall', this); },
    resumeAll() { this.forEachActiveSound((t) => { t.resume(); }), this.emit('resumeall', this); },
    stopAll() { this.forEachActiveSound((t) => { t.stop(); }), this.emit('stopall', this); },
    unlock: o,
    onBlur: o,
    onFocus: o,
    update(t, e) { this.unlocked && (this.unlocked = !1, this.locked = !1, this.emit('unlocked', this)); for (let i = this.sounds.length - 1; i >= 0; i--) this.sounds[i].pendingRemove && this.sounds.splice(i, 1); this.sounds.forEach((i) => { i.update(t, e); }); },
    destroy() { this.removeAllListeners(), this.forEachActiveSound((t) => { t.destroy(); }), this.sounds.length = 0, this.sounds = null, this.game = null; },
    forEachActiveSound(t, e) { const i = this; this.sounds.forEach((n, s) => { n.pendingRemove || t.call(e || i, n, s, i.sounds); }); },
    setRate(t) { return this.rate = t, this; },
    rate: { get() { return this._rate; }, set(t) { this._rate = t, this.forEachActiveSound((t) => { t.calculateRate(); }), this.emit('rate', this, t); } },
    setDetune(t) { return this.detune = t, this; },
    detune: { get() { return this._detune; }, set(t) { this._detune = t, this.forEachActiveSound((t) => { t.calculateRate(); }), this.emit('detune', this, t); } },
  }); t.exports = a;
}, function (t, e, i) {
  let n; const s = i(56); const r = {
    chrome: !1, chromeVersion: 0, edge: !1, firefox: !1, firefoxVersion: 0, ie: !1, ieVersion: 0, mobileSafari: !1, opera: !1, safari: !1, safariVersion: 0, silk: !1, trident: !1, tridentVersion: 0,
  }; t.exports = (n = navigator.userAgent, /Edge\/\d+/.test(n) ? r.edge = !0 : /Chrome\/(\d+)/.test(n) && !s.windowsPhone ? (r.chrome = !0, r.chromeVersion = parseInt(RegExp.$1, 10)) : /Firefox\D+(\d+)/.test(n) ? (r.firefox = !0, r.firefoxVersion = parseInt(RegExp.$1, 10)) : /AppleWebKit/.test(n) && s.iOS ? r.mobileSafari = !0 : /MSIE (\d+\.\d+);/.test(n) ? (r.ie = !0, r.ieVersion = parseInt(RegExp.$1, 10)) : /Opera/.test(n) ? r.opera = !0 : /Safari/.test(n) && !s.windowsPhone ? r.safari = !0 : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(n) && (r.ie = !0, r.trident = !0, r.tridentVersion = parseInt(RegExp.$1, 10), r.ieVersion = parseInt(RegExp.$3, 10)), /Silk/.test(n) && (r.silk = !0), r);
}, function (t, e, i) {
  const n = new (i(0))({
    initialize(t, e) { this.parent = t, this.events = e, e || (this.events = t.events ? t.events : t), this.list = {}, this.blockSet = !1, this._frozen = !1, !t.hasOwnProperty('sys') && this.events && this.events.once('destroy', this.destroy, this); }, get(t) { return this.list[t]; }, getAll() { const t = {}; for (const e in this.list) this.list.hasOwnProperty(e) && (t[e] = this.list[e]); return t; }, query(t) { const e = {}; for (const i in this.list) this.list.hasOwnProperty(i) && i.match(t) && (e[i] = this.list[i]); return e; }, set(t, e) { if (this._frozen) return this; if (this.events.listenerCount('changedata') > 0) { this.blockSet = !1; const i = this; if (this.events.emit('changedata', this.parent, t, e, (e) => { i.blockSet = !0, i.list[t] = e, i.events.emit('setdata', i.parent, t, e); }), this.blockSet) return this; } return this.list[t] = e, this.events.emit('setdata', this.parent, t, e), this; }, each(t, e) { for (var i = [this.parent, null, void 0], n = 1; n < arguments.length; n++)i.push(arguments[n]); for (const s in this.list)i[1] = s, i[2] = this.list[s], t.apply(e, i); return this; }, merge(t, e) { for (const i in void 0 === e && (e = !0), t)t.hasOwnProperty(i) && (e || !e && !this.has(i)) && (this.list[i] = t[i]); return this; }, remove(t) { if (!this._frozen && this.has(t)) { const e = this.list[t]; delete this.list[t], this.events.emit('removedata', this, t, e); } return this; }, pop(t) { let e = void 0; return !this._frozen && this.has(t) && (e = this.list[t], delete this.list[t], this.events.emit('removedata', this, t, e)), e; }, has(t) { return this.list.hasOwnProperty(t); }, setFreeze(t) { return this._frozen = t, this; }, reset() { for (const t in this.list) delete this.list[t]; return this.blockSet = !1, this._frozen = !1, this; }, destroy() { this.reset(), this.events.off('changedata'), this.events.off('setdata'), this.events.off('removedata'), this.parent = null; }, freeze: { get() { return this._frozen; }, set(t) { this._frozen = !!t; } }, count: { get() { let t = 0; for (const e in this.list) void 0 !== this.list[e] && t++; return t; } },
  }); t.exports = n;
}, function (t, e, i) {
  const n = {}; t.exports = n; const s = i(140); const r = i(123); const o = i(331); const a = i(49); const h = i(139); const l = i(675); !(function () {
    n._inertiaScale = 4, n._nextCollidingGroupId = 1, n._nextNonCollidingGroupId = -1, n._nextCategory = 1, n.create = function (e) {
      const i = {
        id: a.nextId(),
        type: 'body',
        label: 'Body',
        gameObject: null,
        parts: [],
        plugin: {},
        angle: 0,
        vertices: s.fromPath('L 0 0 L 40 0 L 40 40 L 0 40'),
        position: { x: 0, y: 0 },
        force: { x: 0, y: 0 },
        torque: 0,
        positionImpulse: { x: 0, y: 0 },
        previousPositionImpulse: { x: 0, y: 0 },
        constraintImpulse: { x: 0, y: 0, angle: 0 },
        totalContacts: 0,
        speed: 0,
        angularSpeed: 0,
        velocity: { x: 0, y: 0 },
        angularVelocity: 0,
        isSensor: !1,
        isStatic: !1,
        isSleeping: !1,
        ignoreGravity: !1,
        ignorePointer: !1,
        motion: 0,
        sleepThreshold: 60,
        density: 0.001,
        restitution: 0,
        friction: 0.1,
        frictionStatic: 0.5,
        frictionAir: 0.01,
        collisionFilter: { category: 1, mask: 4294967295, group: 0 },
        slop: 0.05,
        timeScale: 1,
        render: {
          visible: !0,
          opacity: 1,
          sprite: {
            xScale: 1, yScale: 1, xOffset: 0, yOffset: 0,
          },
          lineWidth: 0,
        },
        events: null,
        bounds: null,
        chamfer: null,
        circleRadius: 0,
        positionPrev: null,
        anglePrev: 0,
        parent: null,
        axes: null,
        area: 0,
        mass: 0,
        inertia: 0,
        _original: null,
      }; const n = a.extend(i, e); return t(n, e), n;
    }, n.nextGroup = function (t) { return t ? n._nextNonCollidingGroupId-- : n._nextCollidingGroupId++; }, n.nextCategory = function () { return n._nextCategory <<= 1, n._nextCategory; }; var t = function (t, e) {
      e = e || {}, n.set(t, {
        bounds: t.bounds || h.create(t.vertices), positionPrev: t.positionPrev || r.clone(t.position), anglePrev: t.anglePrev || t.angle, vertices: t.vertices, parts: t.parts || [t], isStatic: t.isStatic, isSleeping: t.isSleeping, parent: t.parent || t,
      }), s.rotate(t.vertices, t.angle, t.position), l.rotate(t.axes, t.angle), h.update(t.bounds, t.vertices, t.velocity), n.set(t, {
        axes: e.axes || t.axes, area: e.area || t.area, mass: e.mass || t.mass, inertia: e.inertia || t.inertia,
      }); const i = t.isStatic ? '#2e2b44' : a.choose(['#006BA6', '#0496FF', '#FFBC42', '#D81159', '#8F2D56']); t.render.fillStyle = t.render.fillStyle || i, t.render.strokeStyle = t.render.strokeStyle || '#000', t.render.sprite.xOffset += -(t.bounds.min.x - t.position.x) / (t.bounds.max.x - t.bounds.min.x), t.render.sprite.yOffset += -(t.bounds.min.y - t.position.y) / (t.bounds.max.y - t.bounds.min.y);
    }; n.set = function (t, e) { let i; let s; for (i in typeof e === 'string' && (i = e, (e = {})[i] = s), e) if (e.hasOwnProperty(i)) switch (s = e[i], i) { case 'isStatic': n.setStatic(t, s); break; case 'isSleeping': o.set(t, s); break; case 'mass': n.setMass(t, s); break; case 'density': n.setDensity(t, s); break; case 'inertia': n.setInertia(t, s); break; case 'vertices': n.setVertices(t, s); break; case 'position': n.setPosition(t, s); break; case 'angle': n.setAngle(t, s); break; case 'velocity': n.setVelocity(t, s); break; case 'angularVelocity': n.setAngularVelocity(t, s); break; case 'parts': n.setParts(t, s); break; default: t[i] = s; } }, n.setStatic = function (t, e) {
      for (let i = 0; i < t.parts.length; i++) {
        const n = t.parts[i]; n.isStatic = e, e ? (n._original = {
          restitution: n.restitution, friction: n.friction, mass: n.mass, inertia: n.inertia, density: n.density, inverseMass: n.inverseMass, inverseInertia: n.inverseInertia,
        }, n.restitution = 0, n.friction = 1, n.mass = n.inertia = n.density = 1 / 0, n.inverseMass = n.inverseInertia = 0, n.positionPrev.x = n.position.x, n.positionPrev.y = n.position.y, n.anglePrev = n.angle, n.angularVelocity = 0, n.speed = 0, n.angularSpeed = 0, n.motion = 0) : n._original && (n.restitution = n._original.restitution, n.friction = n._original.friction, n.mass = n._original.mass, n.inertia = n._original.inertia, n.density = n._original.density, n.inverseMass = n._original.inverseMass, n.inverseInertia = n._original.inverseInertia, n._original = null);
      }
    }, n.setMass = function (t, e) { const i = t.inertia / (t.mass / 6); t.inertia = i * (e / 6), t.inverseInertia = 1 / t.inertia, t.mass = e, t.inverseMass = 1 / t.mass, t.density = t.mass / t.area; }, n.setDensity = function (t, e) { n.setMass(t, e * t.area), t.density = e; }, n.setInertia = function (t, e) { t.inertia = e, t.inverseInertia = 1 / t.inertia; }, n.setVertices = function (t, e) { e[0].body === t ? t.vertices = e : t.vertices = s.create(e, t), t.axes = l.fromVertices(t.vertices), t.area = s.area(t.vertices), n.setMass(t, t.density * t.area); const i = s.centre(t.vertices); s.translate(t.vertices, i, -1), n.setInertia(t, n._inertiaScale * s.inertia(t.vertices, t.mass)), s.translate(t.vertices, t.position), h.update(t.bounds, t.vertices, t.velocity); }, n.setParts = function (t, i, r) { let o; for (i = i.slice(0), t.parts.length = 0, t.parts.push(t), t.parent = t, o = 0; o < i.length; o++) { const a = i[o]; a !== t && (a.parent = t, t.parts.push(a)); } if (t.parts.length !== 1) { if (r = void 0 === r || r) { let h = []; for (o = 0; o < i.length; o++)h = h.concat(i[o].vertices); s.clockwiseSort(h); const l = s.hull(h); const u = s.centre(l); n.setVertices(t, l), s.translate(t.vertices, u); } const c = e(t); t.area = c.area, t.parent = t, t.position.x = c.centre.x, t.position.y = c.centre.y, t.positionPrev.x = c.centre.x, t.positionPrev.y = c.centre.y, n.setMass(t, c.mass), n.setInertia(t, c.inertia), n.setPosition(t, c.centre); } }, n.setPosition = function (t, e) { const i = r.sub(e, t.position); t.positionPrev.x += i.x, t.positionPrev.y += i.y; for (let n = 0; n < t.parts.length; n++) { const o = t.parts[n]; o.position.x += i.x, o.position.y += i.y, s.translate(o.vertices, i), h.update(o.bounds, o.vertices, t.velocity); } }, n.setAngle = function (t, e) { const i = e - t.angle; t.anglePrev += i; for (let n = 0; n < t.parts.length; n++) { const o = t.parts[n]; o.angle += i, s.rotate(o.vertices, i, t.position), l.rotate(o.axes, i), h.update(o.bounds, o.vertices, t.velocity), n > 0 && r.rotateAbout(o.position, i, t.position, o.position); } }, n.setVelocity = function (t, e) { t.positionPrev.x = t.position.x - e.x, t.positionPrev.y = t.position.y - e.y, t.velocity.x = e.x, t.velocity.y = e.y, t.speed = r.magnitude(t.velocity); }, n.setAngularVelocity = function (t, e) { t.anglePrev = t.angle - e, t.angularVelocity = e, t.angularSpeed = Math.abs(t.angularVelocity); }, n.translate = function (t, e) { n.setPosition(t, r.add(t.position, e)); }, n.rotate = function (t, e, i) { if (i) { const s = Math.cos(e); const r = Math.sin(e); const o = t.position.x - i.x; const a = t.position.y - i.y; n.setPosition(t, { x: i.x + (o * s - a * r), y: i.y + (o * r + a * s) }), n.setAngle(t, t.angle + e); } else n.setAngle(t, t.angle + e); }, n.scale = function (t, i, r, o) { o = o || t.position; for (let a = 0; a < t.parts.length; a++) { const u = t.parts[a]; u.position.x = o.x + (u.position.x - o.x) * i, u.position.y = o.y + (u.position.y - o.y) * r, s.scale(u.vertices, i, r, o), u.axes = l.fromVertices(u.vertices), t.isStatic || (u.area = s.area(u.vertices), n.setMass(u, t.density * u.area), s.translate(u.vertices, { x: -u.position.x, y: -u.position.y }), n.setInertia(u, s.inertia(u.vertices, u.mass)), s.translate(u.vertices, { x: u.position.x, y: u.position.y })), h.update(u.bounds, u.vertices, t.velocity); } if (t.circleRadius && (i === r ? t.circleRadius *= i : t.circleRadius = null), !t.isStatic) { const c = e(t); t.area = c.area, n.setMass(t, c.mass), n.setInertia(t, c.inertia); } }, n.update = function (t, e, i, n) { const o = Math.pow(e * i * t.timeScale, 2); const a = 1 - t.frictionAir * i * t.timeScale; const u = t.position.x - t.positionPrev.x; const c = t.position.y - t.positionPrev.y; t.velocity.x = u * a * n + t.force.x / t.mass * o, t.velocity.y = c * a * n + t.force.y / t.mass * o, t.positionPrev.x = t.position.x, t.positionPrev.y = t.position.y, t.position.x += t.velocity.x, t.position.y += t.velocity.y, t.angularVelocity = (t.angle - t.anglePrev) * a * n + t.torque / t.inertia * o, t.anglePrev = t.angle, t.angle += t.angularVelocity, t.speed = r.magnitude(t.velocity), t.angularSpeed = Math.abs(t.angularVelocity); for (let d = 0; d < t.parts.length; d++) { const f = t.parts[d]; s.translate(f.vertices, t.velocity), d > 0 && (f.position.x += t.velocity.x, f.position.y += t.velocity.y), t.angularVelocity !== 0 && (s.rotate(f.vertices, t.angularVelocity, t.position), l.rotate(f.axes, t.angularVelocity), d > 0 && r.rotateAbout(f.position, t.angularVelocity, t.position, f.position)), h.update(f.bounds, f.vertices, t.velocity); } }, n.applyForce = function (t, e, i) { t.force.x += i.x, t.force.y += i.y; const n = e.x - t.position.x; const s = e.y - t.position.y; t.torque += n * i.y - s * i.x; }; var e = function (t) {
      for (var e = {
          mass: 0, area: 0, inertia: 0, centre: { x: 0, y: 0 },
        }, i = t.parts.length === 1 ? 0 : 1; i < t.parts.length; i++) { const n = t.parts[i]; const s = n.mass !== 1 / 0 ? n.mass : 1; e.mass += n.mass, e.area += n.area, e.inertia += n.inertia, e.centre = r.add(e.centre, r.mult(n.position, s)); } return e.centre = r.div(e.centre, e.mass), e;
    };
  }());
}, function (t, e) { t.exports = function (t) { return Math.atan2(t.y2 - t.y1, t.x2 - t.x1); }; }, function (t, e, i) { !(function () { const e = function (t, e) { return i(t.slice(), e); }; function i(t, e) { typeof e !== 'function' && (e = function (t, e) { return String(t).localeCompare(e); }); const i = t.length; if (i <= 1) return t; for (let s = new Array(i), r = 1; r < i; r *= 2) { n(t, e, r, s); const o = t; t = s, s = o; } return t; }e.inplace = function (t, e) { const s = i(t, e); return s !== t && n(s, null, t.length, t), t; }; var n = function (t, e, i, n) { let s; let r; let o; let a; let h; const l = t.length; let u = 0; const c = 2 * i; for (s = 0; s < l; s += c) for (o = (r = s + i) + i, r > l && (r = l), o > l && (o = l), a = s, h = r; ;) if (a < r && h < o)e(t[a], t[h]) <= 0 ? n[u++] = t[a++] : n[u++] = t[h++]; else if (a < r)n[u++] = t[a++]; else { if (!(h < o)) break; n[u++] = t[h++]; } }; t.exports = e; }()); }, function (t, e, i) {
  const n = i(0); const s = i(27); const r = new n({
    initialize(t) { this.name = 'WebGLPipeline', this.game = t.game, this.view = t.game.canvas, this.resolution = t.game.config.resolution, this.width = t.game.config.width * this.resolution, this.height = t.game.config.height * this.resolution, this.gl = t.gl, this.vertexCount = 0, this.vertexCapacity = t.vertexCapacity, this.renderer = t.renderer, this.vertexData = t.vertices ? t.vertices : new ArrayBuffer(t.vertexCapacity * t.vertexSize), this.vertexBuffer = this.renderer.createVertexBuffer(t.vertices ? t.vertices : this.vertexData.byteLength, this.gl.STREAM_DRAW), this.program = this.renderer.createProgram(t.vertShader, t.fragShader), this.attributes = t.attributes, this.vertexSize = t.vertexSize, this.topology = t.topology, this.bytes = new Uint8Array(this.vertexData), this.vertexComponentCount = s.getComponentCount(t.attributes, this.gl), this.flushLocked = !1; },
    addAttribute(t, e, i, n, s) {
      return this.attributes.push({
        name: t, size: e, type: this.renderer.glFormats[i], normalized: n, offset: s,
      }), this;
    },
    shouldFlush() { return this.vertexCount >= this.vertexCapacity; },
    resize(t, e, i) { return this.width = t * i, this.height = e * i, this; },
    bind() { const t = this.gl; const e = this.vertexBuffer; const i = this.attributes; const n = this.program; const s = this.renderer; const r = this.vertexSize; s.setProgram(n), s.setVertexBuffer(e); for (let o = 0; o < i.length; ++o) { const a = i[o]; const h = t.getAttribLocation(n, a.name); h >= 0 ? (t.enableVertexAttribArray(h), t.vertexAttribPointer(h, a.size, a.type, a.normalized, r, a.offset)) : t.disableVertexAttribArray(h); } return this; },
    onBind() { return this; },
    onPreRender() { return this; },
    onRender() { return this; },
    onPostRender() { return this; },
    flush() { if (this.flushLocked) return this; this.flushLocked = !0; const t = this.gl; const e = this.vertexCount; const i = this.topology; const n = this.vertexSize; if (e !== 0) return t.bufferSubData(t.ARRAY_BUFFER, 0, this.bytes.subarray(0, e * n)), t.drawArrays(i, 0, e), this.vertexCount = 0, this.flushLocked = !1, this; this.flushLocked = !1; },
    destroy() { const t = this.gl; return t.deleteProgram(this.program), t.deleteBuffer(this.vertexBuffer), delete this.program, delete this.vertexBuffer, delete this.gl, this; },
    setFloat1(t, e) { return this.renderer.setFloat1(this.program, t, e), this; },
    setFloat2(t, e, i) { return this.renderer.setFloat2(this.program, t, e, i), this; },
    setFloat3(t, e, i, n) { return this.renderer.setFloat3(this.program, t, e, i, n), this; },
    setFloat4(t, e, i, n, s) { return this.renderer.setFloat4(this.program, t, e, i, n, s), this; },
    setInt1(t, e) { return this.renderer.setInt1(this.program, t, e), this; },
    setInt2(t, e, i) { return this.renderer.setInt2(this.program, t, e, i), this; },
    setInt3(t, e, i, n) { return this.renderer.setInt3(this.program, t, e, i, n), this; },
    setInt4(t, e, i, n, s) { return this.renderer.setInt4(this.program, t, e, i, n, s), this; },
    setMatrix2(t, e, i) { return this.renderer.setMatrix2(this.program, t, e, i), this; },
    setMatrix3(t, e, i) { return this.renderer.setMatrix3(this.program, t, e, i), this; },
    setMatrix4(t, e, i) { return this.renderer.setMatrix4(this.program, t, e, i), this; },
  }); t.exports = r;
}, function (t, e) { t.exports = function (t, e) { return t > 0 && (t & t - 1) == 0 && e > 0 && (e & e - 1) == 0; }; }, function (t, e, i) {
  const n = i(0); const s = i(274); const r = i(14); const o = i(7); const a = new n({
    initialize(t) { this.type = t, this.defaultDivisions = 5, this.arcLengthDivisions = 100, this.cacheArcLengths = [], this.needsUpdate = !0, this.active = !0, this._tmpVec2A = new o(), this._tmpVec2B = new o(); }, draw(t, e) { return void 0 === e && (e = 32), t.strokePoints(this.getPoints(e)); }, getBounds(t, e) { t || (t = new r()), void 0 === e && (e = 16); const i = this.getLength(); e > i && (e = i / 2); const n = Math.max(1, Math.round(i / e)); return s(this.getSpacedPoints(n), t); }, getDistancePoints(t) { const e = this.getLength(); const i = Math.max(1, e / t); return this.getSpacedPoints(i); }, getEndPoint(t) { return void 0 === t && (t = new o()), this.getPointAt(1, t); }, getLength() { const t = this.getLengths(); return t[t.length - 1]; }, getLengths(t) { if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; let e; const i = []; const n = this.getPoint(0, this._tmpVec2A); let s = 0; i.push(0); for (let r = 1; r <= t; r++)s += (e = this.getPoint(r / t, this._tmpVec2B)).distance(n), i.push(s), n.copy(e); return this.cacheArcLengths = i, i; }, getPointAt(t, e) { const i = this.getUtoTmapping(t); return this.getPoint(i, e); }, getPoints(t) { void 0 === t && (t = this.defaultDivisions); for (var e = [], i = 0; i <= t; i++)e.push(this.getPoint(i / t)); return e; }, getRandomPoint(t) { return void 0 === t && (t = new o()), this.getPoint(Math.random(), t); }, getSpacedPoints(t) { void 0 === t && (t = this.defaultDivisions); for (var e = [], i = 0; i <= t; i++) { const n = this.getUtoTmapping(i / t, null, t); e.push(this.getPoint(n)); } return e; }, getStartPoint(t) { return void 0 === t && (t = new o()), this.getPointAt(0, t); }, getTangent(t, e) { void 0 === e && (e = new o()); let i = t - 1e-4; let n = t + 1e-4; return i < 0 && (i = 0), n > 1 && (n = 1), this.getPoint(i, this._tmpVec2A), this.getPoint(n, e), e.subtract(this._tmpVec2A).normalize(); }, getTangentAt(t, e) { const i = this.getUtoTmapping(t); return this.getTangent(i, e); }, getTFromDistance(t, e) { return t <= 0 ? 0 : this.getUtoTmapping(0, t, e); }, getUtoTmapping(t, e, i) { let n; const s = this.getLengths(i); let r = 0; const o = s.length; n = e ? Math.min(e, s[o - 1]) : t * s[o - 1]; for (var a, h = 0, l = o - 1; h <= l;) if ((a = s[r = Math.floor(h + (l - h) / 2)] - n) < 0)h = r + 1; else { if (!(a > 0)) { l = r; break; }l = r - 1; } if (s[r = l] === n) return r / (o - 1); const u = s[r]; return (r + (n - u) / (s[r + 1] - u)) / (o - 1); }, updateArcLengths() { this.needsUpdate = !0, this.getLengths(); },
  }); t.exports = a;
}, function (t, e, i) {
  var n = new (i(0))({
    initialize(t, e, i) { this.x = 0, this.y = 0, this.z = 0, typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0); }, up() { return this.x = 0, this.y = 1, this.z = 0, this; }, clone() { return new n(this.x, this.y, this.z); }, crossVectors(t, e) { const i = t.x; const n = t.y; const s = t.z; const r = e.x; const o = e.y; const a = e.z; return this.x = n * a - s * o, this.y = s * r - i * a, this.z = i * o - n * r, this; }, equals(t) { return this.x === t.x && this.y === t.y && this.z === t.z; }, copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z || 0, this; }, set(t, e, i) { return typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0), this; }, add(t) { return this.x += t.x, this.y += t.y, this.z += t.z || 0, this; }, subtract(t) { return this.x -= t.x, this.y -= t.y, this.z -= t.z || 0, this; }, multiply(t) { return this.x *= t.x, this.y *= t.y, this.z *= t.z || 1, this; }, scale(t) { return isFinite(t) ? (this.x *= t, this.y *= t, this.z *= t) : (this.x = 0, this.y = 0, this.z = 0), this; }, divide(t) { return this.x /= t.x, this.y /= t.y, this.z /= t.z || 1, this; }, negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this; }, distance(t) { const e = t.x - this.x; const i = t.y - this.y; const n = t.z - this.z || 0; return Math.sqrt(e * e + i * i + n * n); }, distanceSq(t) { const e = t.x - this.x; const i = t.y - this.y; const n = t.z - this.z || 0; return e * e + i * i + n * n; }, length() { const t = this.x; const e = this.y; const i = this.z; return Math.sqrt(t * t + e * e + i * i); }, lengthSq() { const t = this.x; const e = this.y; const i = this.z; return t * t + e * e + i * i; }, normalize() { const t = this.x; const e = this.y; const i = this.z; let n = t * t + e * e + i * i; return n > 0 && (n = 1 / Math.sqrt(n), this.x = t * n, this.y = e * n, this.z = i * n), this; }, dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z; }, cross(t) { const e = this.x; const i = this.y; const n = this.z; const s = t.x; const r = t.y; const o = t.z; return this.x = i * o - n * r, this.y = n * s - e * o, this.z = e * r - i * s, this; }, lerp(t, e) { void 0 === e && (e = 0); const i = this.x; const n = this.y; const s = this.z; return this.x = i + e * (t.x - i), this.y = n + e * (t.y - n), this.z = s + e * (t.z - s), this; }, transformMat3(t) { const e = this.x; const i = this.y; const n = this.z; const s = t.val; return this.x = e * s[0] + i * s[3] + n * s[6], this.y = e * s[1] + i * s[4] + n * s[7], this.z = e * s[2] + i * s[5] + n * s[8], this; }, transformMat4(t) { const e = this.x; const i = this.y; const n = this.z; const s = t.val; return this.x = s[0] * e + s[4] * i + s[8] * n + s[12], this.y = s[1] * e + s[5] * i + s[9] * n + s[13], this.z = s[2] * e + s[6] * i + s[10] * n + s[14], this; }, transformCoordinates(t) { const e = this.x; const i = this.y; const n = this.z; const s = t.val; const r = e * s[0] + i * s[4] + n * s[8] + s[12]; const o = e * s[1] + i * s[5] + n * s[9] + s[13]; const a = e * s[2] + i * s[6] + n * s[10] + s[14]; const h = e * s[3] + i * s[7] + n * s[11] + s[15]; return this.x = r / h, this.y = o / h, this.z = a / h, this; }, transformQuat(t) { const e = this.x; const i = this.y; const n = this.z; const s = t.x; const r = t.y; const o = t.z; const a = t.w; const h = a * e + r * n - o * i; const l = a * i + o * e - s * n; const u = a * n + s * i - r * e; const c = -s * e - r * i - o * n; return this.x = h * a + c * -s + l * -o - u * -r, this.y = l * a + c * -r + u * -s - h * -o, this.z = u * a + c * -o + h * -r - l * -s, this; }, project(t) { const e = this.x; const i = this.y; const n = this.z; const s = t.val; const r = s[0]; const o = s[1]; const a = s[2]; const h = s[3]; const l = s[4]; const u = s[5]; const c = s[6]; const d = s[7]; const f = s[8]; const p = s[9]; const g = s[10]; const v = s[11]; const y = s[12]; const m = s[13]; const x = s[14]; const w = 1 / (e * h + i * d + n * v + s[15]); return this.x = (e * r + i * l + n * f + y) * w, this.y = (e * o + i * u + n * p + m) * w, this.z = (e * a + i * c + n * g + x) * w, this; }, unproject(t, e) { const i = t.x; const n = t.y; const s = t.z; const r = t.w; const o = this.x - i; const a = r - this.y - 1 - n; const h = this.z; return this.x = 2 * o / s - 1, this.y = 2 * a / r - 1, this.z = 2 * h - 1, this.project(e); }, reset() { return this.x = 0, this.y = 0, this.z = 0, this; },
  }); t.exports = n;
}, function (t, e, i) {
  const n = i(0); const s = i(32); const r = i(298); const o = i(296); const a = i(155); const h = new n({
    initialize(t, e, i) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), this.x = t, this.y = e, this._radius = i, this._diameter = 2 * i; }, contains(t, e) { return s(this, t, e); }, getPoint(t, e) { return r(this, t, e); }, getPoints(t, e, i) { return o(this, t, e, i); }, getRandomPoint(t) { return a(this, t); }, setTo(t, e, i) { return this.x = t, this.y = e, this._radius = i, this._diameter = 2 * i, this; }, setEmpty() { return this._radius = 0, this._diameter = 0, this; }, setPosition(t, e) { return void 0 === e && (e = t), this.x = t, this.y = e, this; }, isEmpty() { return this._radius <= 0; }, radius: { get() { return this._radius; }, set(t) { this._radius = t, this._diameter = 2 * t; } }, diameter: { get() { return this._diameter; }, set(t) { this._diameter = t, this._radius = 0.5 * t; } }, left: { get() { return this.x - this._radius; }, set(t) { this.x = t + this._radius; } }, right: { get() { return this.x + this._radius; }, set(t) { this.x = t - this._radius; } }, top: { get() { return this.y - this._radius; }, set(t) { this.y = t + this._radius; } }, bottom: { get() { return this.y + this._radius; }, set(t) { this.y = t - this._radius; } },
  }); t.exports = h;
}, function (t, e) { t.exports = function (t) { return t.y - t.height * t.originY + 0.5 * t.height; }; }, function (t, e) { t.exports = function (t, e) { const i = t.height * t.originY; return t.y = e + i - 0.5 * t.height, t; }; }, function (t, e) { t.exports = function (t, e) { const i = t.width * t.originX; return t.x = e + i - 0.5 * t.width, t; }; }, function (t, e) { t.exports = function (t) { return t.x - t.width * t.originX + 0.5 * t.width; }; }, function (t, e, i) {
  const n = i(146); const s = i(0); const r = i(3); const o = i(82); const a = new s({
    initialize(t) { this.parent = t, this.list = [], this.position = 0, this.addCallback = r, this.removeCallback = r, this._sortKey = ''; }, add(t, e) { return e ? n.Add(this.list, t) : n.Add(this.list, t, 0, this.addCallback, this); }, addAt(t, e, i) { return i ? n.AddAt(this.list, t, e) : n.AddAt(this.list, t, e, 0, this.addCallback, this); }, getAt(t) { return this.list[t]; }, getIndex(t) { return this.list.indexOf(t); }, sort(t) { return t && (this._sortKey = t, o.inplace(this.list, this.sortHandler)), this; }, sortHandler(t, e) { return t[this._sortKey] - e[this._sortKey]; }, getByName(t) { return n.GetFirst(this.list, 'name', t); }, getRandom(t, e) { return n.GetRandom(this.list, t, e); }, getFirst(t, e, i, s) { return n.GetFirstElement(this.list, t, e, i, s); }, getAll(t, e, i, s) { return n.GetAll(this.list, t, e, i, s); }, count(t, e) { return n.CountAllMatching(this.list, t, e); }, swap(t, e) { n.Swap(this.list, t, e); }, moveTo(t, e) { return n.MoveTo(this.list, t, e); }, remove(t, e) { return e ? n.Remove(this.list, t) : n.Remove(this.list, t, this.removeCallback, this); }, removeAt(t, e) { return e ? n.RemoveAt(this.list, t) : n.RemoveAt(this.list, t, this.removeCallback, this); }, removeBetween(t, e, i) { return i ? n.RemoveBetween(this.list, t, e) : n.RemoveBetween(this.list, t, e, this.removeCallback, this); }, removeAll(t) { for (let e = this.list.length; e--;) this.remove(this.list[e], t); return this; }, bringToTop(t) { return n.BringToTop(this.list, t); }, sendToBack(t) { return n.SendToBack(this.list, t); }, moveUp(t) { return n.MoveUp(this.list, t), t; }, moveDown(t) { return n.MoveDown(this.list, t), t; }, reverse() { return this.list.reverse(), this; }, shuffle() { return n.Shuffle(this.list), this; }, replace(t, e) { return n.Replace(this.list, t, e); }, exists(t) { return this.list.indexOf(t) > -1; }, setAll(t, e, i, s) { return n.SetAll(this.list, t, e, i, s), this; }, each(t, e) { for (var i = [null], n = 2; n < arguments.length; n++)i.push(arguments[n]); for (n = 0; n < this.list.length; n++)i[0] = this.list[n], t.apply(e, i); }, shutdown() { this.removeAll(), this.list = []; }, destroy() { this.removeAll(), this.parent = null, this.addCallback = null, this.removeCallback = null; }, length: { get() { return this.list.length; } }, first: { get() { return this.position = 0, this.list.length > 0 ? this.list[0] : null; } }, last: { get() { return this.list.length > 0 ? (this.position = this.list.length - 1, this.list[this.position]) : null; } }, next: { get() { return this.position < this.list.length ? (this.position++, this.list[this.position]) : null; } }, previous: { get() { return this.position > 0 ? (this.position--, this.list[this.position]) : null; } },
  }); t.exports = a;
}, function (t, e, i) { const n = i(33); t.exports = function (t, e) { const i = n(t); for (const s in e)i.hasOwnProperty(s) || (i[s] = e[s]); return i; }; }, function (t, e) { t.exports = function (t) { for (let e = t.length - 1; e > 0; e--) { const i = Math.floor(Math.random() * (e + 1)); const n = t[e]; t[e] = t[i], t[i] = n; } return t; }; }, function (t, e, i) {
  const n = i(0); const s = i(293); const r = i(154); const o = i(153); const a = i(7); const h = new n({
    initialize(t, e, i, n) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this.x1 = t, this.y1 = e, this.x2 = i, this.y2 = n; }, getPoint(t, e) { return s(this, t, e); }, getPoints(t, e, i) { return r(this, t, e, i); }, getRandomPoint(t) { return o(this, t); }, setTo(t, e, i, n) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this.x1 = t, this.y1 = e, this.x2 = i, this.y2 = n, this; }, getPointA(t) { return void 0 === t && (t = new a()), t.set(this.x1, this.y1), t; }, getPointB(t) { return void 0 === t && (t = new a()), t.set(this.x2, this.y2), t; }, left: { get() { return Math.min(this.x1, this.x2); }, set(t) { this.x1 <= this.x2 ? this.x1 = t : this.x2 = t; } }, right: { get() { return Math.max(this.x1, this.x2); }, set(t) { this.x1 > this.x2 ? this.x1 = t : this.x2 = t; } }, top: { get() { return Math.min(this.y1, this.y2); }, set(t) { this.y1 <= this.y2 ? this.y1 = t : this.y2 = t; } }, bottom: { get() { return Math.max(this.y1, this.y2); }, set(t) { this.y1 > this.y2 ? this.y1 = t : this.y2 = t; } },
  }); t.exports = h;
}, function (t, e) { t.exports = function (t) { return 2 * (t.width + t.height); }; }, function (t, e) {
  t.exports = function (t, e, i, n, s, r, o, a, h, l, u, c, d) {
    return {
      target: t,
      key: e,
      getEndValue: i,
      getStartValue: n,
      ease: s,
      duration: 0,
      totalDuration: 0,
      delay: 0,
      yoyo: a,
      hold: 0,
      repeat: 0,
      repeatDelay: 0,
      flipX: c,
      flipY: d,
      progress: 0,
      elapsed: 0,
      repeatCounter: 0,
      start: 0,
      current: 0,
      end: 0,
      t1: 0,
      t2: 0,
      gen: {
        delay: r, duration: o, hold: h, repeat: l, repeatDelay: u,
      },
      state: 0,
    };
  };
}, function (t, e, i) {
  const n = i(0); const s = i(13); const r = i(11); const o = i(60); const a = new n({
    initialize(t, e, i) {
      this.parent = t, this.parentIsTimeline = t.hasOwnProperty('isTimeline'), this.data = e, this.totalData = e.length, this.targets = i, this.totalTargets = i.length, this.useFrames = !1, this.timeScale = 1, this.loop = 0, this.loopDelay = 0, this.loopCounter = 0, this.completeDelay = 0, this.countdown = 0, this.offset = 0, this.calculatedOffset = 0, this.state = o.PENDING_ADD, this._pausedState = o.PENDING_ADD, this.paused = !1, this.elapsed = 0, this.totalElapsed = 0, this.duration = 0, this.progress = 0, this.totalDuration = 0, this.totalProgress = 0, this.callbacks = {
        onComplete: null, onLoop: null, onRepeat: null, onStart: null, onUpdate: null, onYoyo: null,
      }, this.callbackScope;
    },
    getValue() { return this.data[0].current; },
    setTimeScale(t) { return this.timeScale = t, this; },
    getTimeScale() { return this.timeScale; },
    isPlaying() { return this.state === o.ACTIVE; },
    isPaused() { return this.state === o.PAUSED; },
    hasTarget(t) { return this.targets.indexOf(t) !== -1; },
    updateTo(t, e, i) { for (let n = 0; n < this.totalData; n++) { const s = this.data[n]; if (s.key === t) { s.end = e, i && (s.start = s.current); break; } } return this; },
    restart() { this.state === o.REMOVED ? (this.seek(0), this.parent.makeActive(this)) : (this.stop(), this.play()); },
    calcDuration() { for (var t = 0, e = this.data, i = 0; i < this.totalData; i++) { const n = e[i]; n.t1 = n.duration + n.hold, n.yoyo && (n.t1 += n.duration), n.t2 = n.t1 + n.repeatDelay, n.totalDuration = n.delay + n.t1, n.repeat === -1 ? n.totalDuration += 999999999999 * n.t2 : n.repeat > 0 && (n.totalDuration += n.t2 * n.repeat), n.totalDuration > t && (t = n.totalDuration); } this.duration = t, this.loopCounter = this.loop === -1 ? 999999999999 : this.loop, this.loopCounter > 0 ? this.totalDuration = this.duration + this.completeDelay + (this.duration + this.loopDelay) * this.loopCounter : this.totalDuration = this.duration + this.completeDelay; },
    init() { for (let t = this.data, e = this.totalTargets, i = 0; i < this.totalData; i++) { const n = t[i]; const s = n.target; const r = n.gen; n.delay = r.delay(i, e, s), n.duration = r.duration(i, e, s), n.hold = r.hold(i, e, s), n.repeat = r.repeat(i, e, s), n.repeatDelay = r.repeatDelay(i, e, s); } return this.calcDuration(), this.progress = 0, this.totalProgress = 0, this.elapsed = 0, this.totalElapsed = 0, this.paused && !this.parentIsTimeline ? (this.state = o.PENDING_ADD, this._pausedState = o.INIT, !1) : (this.state = o.INIT, !0); },
    nextState() { if (this.loopCounter > 0) { this.elapsed = 0, this.progress = 0, this.loopCounter--; const t = this.callbacks.onLoop; t && (t.params[1] = this.targets, t.func.apply(t.scope, t.params)), this.resetTweenData(!0), this.loopDelay > 0 ? (this.countdown = this.loopDelay, this.state = o.LOOP_DELAY) : this.state = o.ACTIVE; } else if (this.completeDelay > 0) this.countdown = this.completeDelay, this.state = o.COMPLETE_DELAY; else { const e = this.callbacks.onComplete; e && (e.params[1] = this.targets, e.func.apply(e.scope, e.params)), this.state = o.PENDING_REMOVE; } },
    pause() { if (this.state !== o.PAUSED) return this.paused = !0, this._pausedState = this.state, this.state = o.PAUSED, this; },
    play(t) { if (this.state !== o.ACTIVE) { this.state !== o.PENDING_REMOVE && this.state !== o.REMOVED || (this.init(), this.parent.makeActive(this), t = !0); const e = this.callbacks.onStart; this.parentIsTimeline ? (this.resetTweenData(t), this.calculatedOffset === 0 ? (e && (e.params[1] = this.targets, e.func.apply(e.scope, e.params)), this.state = o.ACTIVE) : (this.countdown = this.calculatedOffset, this.state = o.OFFSET_DELAY)) : this.paused ? (this.paused = !1, this.parent.makeActive(this)) : (this.resetTweenData(t), this.state = o.ACTIVE, e && (e.params[1] = this.targets, e.func.apply(e.scope, e.params))); } },
    resetTweenData(t) { for (let e = this.data, i = 0; i < this.totalData; i++) { const n = e[i]; n.progress = 0, n.elapsed = 0, n.repeatCounter = n.repeat === -1 ? 999999999999 : n.repeat, t ? (n.start = n.getStartValue(n.target, n.key, n.start), n.end = n.getEndValue(n.target, n.key, n.end), n.current = n.start, n.state = o.PLAYING_FORWARD) : n.delay > 0 ? (n.elapsed = n.delay, n.state = o.DELAY) : n.state = o.PENDING_RENDER; } },
    resume() { return this.state === o.PAUSED ? (this.paused = !1, this.state = this._pausedState) : this.play(), this; },
    seek(t) { for (let e = this.data, i = 0; i < this.totalData; i++) { let n = this.totalDuration * t; const s = e[i]; let r = 0; let o = 0; n <= s.delay ? (r = 0, o = 0) : n >= s.totalDuration ? (r = 1, o = s.duration) : n > s.delay && n <= s.t1 ? (r = (n = Math.max(0, n - s.delay)) / s.t1, o = s.duration * r) : n > s.t1 && n < s.totalDuration && (n -= s.delay, (n = (n -= s.t1) / s.t2 % 1 * s.t2) > s.repeatDelay && (r = n / s.t1, o = s.duration * r)), s.progress = r, s.elapsed = o; const a = s.ease(s.progress); s.current = s.start + (s.end - s.start) * a, s.target[s.key] = s.current; } },
    setCallback(t, e, i, n) { return this.callbacks[t] = { func: e, scope: n, params: i }, this; },
    complete(t) { if (void 0 === t && (t = 0), t) this.countdown = t, this.state = o.COMPLETE_DELAY; else { const e = this.callbacks.onComplete; e && (e.params[1] = this.targets, e.func.apply(e.scope, e.params)), this.state = o.PENDING_REMOVE; } },
    stop(t) { this.state === o.ACTIVE && void 0 !== t && this.seek(t), this.state !== o.REMOVED && (this.state = o.PENDING_REMOVE); },
    update(t, e) { if (this.state === o.PAUSED) return !1; switch (this.useFrames && (e = 1 * this.parent.timeScale), e *= this.timeScale, this.elapsed += e, this.progress = Math.min(this.elapsed / this.duration, 1), this.totalElapsed += e, this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1), this.state) { case o.ACTIVE: for (var i = !1, n = 0; n < this.totalData; n++) this.updateTweenData(this, this.data[n], e) && (i = !0); i || this.nextState(); break; case o.LOOP_DELAY: this.countdown -= e, this.countdown <= 0 && (this.state = o.ACTIVE); break; case o.OFFSET_DELAY: if (this.countdown -= e, this.countdown <= 0) { const s = this.callbacks.onStart; s && (s.params[1] = this.targets, s.func.apply(s.scope, s.params)), this.state = o.ACTIVE; } break; case o.COMPLETE_DELAY: if (this.countdown -= e, this.countdown <= 0) { const r = this.callbacks.onComplete; r && r.func.apply(r.scope, r.params), this.state = o.PENDING_REMOVE; } } return this.state === o.PENDING_REMOVE; },
    setStateFromEnd(t, e, i) { if (e.yoyo) { e.elapsed = i, e.progress = i / e.duration, e.flipX && e.target.toggleFlipX(), e.flipY && e.target.toggleFlipY(); const n = t.callbacks.onYoyo; return n && (n.params[1] = e.target, n.func.apply(n.scope, n.params)), e.start = e.getStartValue(e.target, e.key, e.start), o.PLAYING_BACKWARD; } if (e.repeatCounter > 0) { e.repeatCounter--, e.elapsed = i, e.progress = i / e.duration, e.flipX && e.target.toggleFlipX(), e.flipY && e.target.toggleFlipY(); const s = t.callbacks.onRepeat; return s && (s.params[1] = e.target, s.func.apply(s.scope, s.params)), e.start = e.getStartValue(e.target, e.key, e.start), e.end = e.getEndValue(e.target, e.key, e.start), e.repeatDelay > 0 ? (e.elapsed = e.repeatDelay - i, e.current = e.start, e.target[e.key] = e.current, o.REPEAT_DELAY) : o.PLAYING_FORWARD; } return o.COMPLETE; },
    setStateFromStart(t, e, i) { if (e.repeatCounter > 0) { e.repeatCounter--, e.elapsed = i, e.progress = i / e.duration, e.flipX && e.target.toggleFlipX(), e.flipY && e.target.toggleFlipY(); const n = t.callbacks.onRepeat; return n && (n.params[1] = e.target, n.func.apply(n.scope, n.params)), e.end = e.getEndValue(e.target, e.key, e.start), e.repeatDelay > 0 ? (e.elapsed = e.repeatDelay - i, e.current = e.start, e.target[e.key] = e.current, o.REPEAT_DELAY) : o.PLAYING_FORWARD; } return o.COMPLETE; },
    updateTweenData(t, e, i) { switch (e.state) { case o.PLAYING_FORWARD: case o.PLAYING_BACKWARD: if (!e.target) { e.state = o.COMPLETE; break; } var n = e.elapsed; var s = e.duration; var r = 0; (n += i) > s && (r = n - s, n = s); var a; var h = e.state === o.PLAYING_FORWARD; var l = n / s; a = h ? e.ease(l) : e.ease(1 - l), e.current = e.start + (e.end - e.start) * a, e.target[e.key] = e.current, e.elapsed = n, e.progress = l; var u = t.callbacks.onUpdate; u && (u.params[1] = e.target, u.func.apply(u.scope, u.params)), l === 1 && (h ? e.hold > 0 ? (e.elapsed = e.hold - r, e.state = o.HOLD_DELAY) : e.state = this.setStateFromEnd(t, e, r) : e.state = this.setStateFromStart(t, e, r)); break; case o.DELAY: e.elapsed -= i, e.elapsed <= 0 && (e.elapsed = Math.abs(e.elapsed), e.state = o.PENDING_RENDER); break; case o.REPEAT_DELAY: e.elapsed -= i, e.elapsed <= 0 && (e.elapsed = Math.abs(e.elapsed), e.state = o.PLAYING_FORWARD); break; case o.HOLD_DELAY: e.elapsed -= i, e.elapsed <= 0 && (e.state = this.setStateFromEnd(t, e, Math.abs(e.elapsed))); break; case o.PENDING_RENDER: e.target ? (e.start = e.getStartValue(e.target, e.key, e.target[e.key]), e.end = e.getEndValue(e.target, e.key, e.start), e.current = e.start, e.target[e.key] = e.start, e.state = o.PLAYING_FORWARD) : e.state = o.COMPLETE; } return e.state !== o.COMPLETE; },
  }); a.TYPES = ['onComplete', 'onLoop', 'onRepeat', 'onStart', 'onUpdate', 'onYoyo'], r.register('tween', function (t) { return this.scene.sys.tweens.add(t); }), s.register('tween', function (t) { return this.scene.sys.tweens.create(t); }), t.exports = a;
}, function (t, e) {
  t.exports = {
    targets: null, delay: 0, duration: 1e3, ease: 'Power0', easeParams: null, hold: 0, repeat: 0, repeatDelay: 0, yoyo: !1, flipX: !1, flipY: !1,
  };
}, function (t, e) { function i(t) { return !!t.getStart && typeof t.getStart === 'function'; } function n(t) { return !!t.getEnd && typeof t.getEnd === 'function'; } var s = function (t, e) { let r; let o; let a = function (t, e, i) { return i; }; let h = function (t, e, i) { return i; }; const l = typeof e; if (l === 'number')a = function () { return e; }; else if (l === 'string') { const u = e[0]; const c = parseFloat(e.substr(2)); switch (u) { case '+': a = function (t, e, i) { return i + c; }; break; case '-': a = function (t, e, i) { return i - c; }; break; case '*': a = function (t, e, i) { return i * c; }; break; case '/': a = function (t, e, i) { return i / c; }; break; default: a = function () { return parseFloat(e); }; } } else l === 'function' ? a = e : l === 'object' && (i(o = e) || n(o)) ? (n(e) && (a = e.getEnd), i(e) && (h = e.getStart)) : e.hasOwnProperty('value') && (r = s(t, e.value)); return r || (r = { getEnd: a, getStart: h }), r; }; t.exports = s; }, function (t, e, i) { const n = i(4); t.exports = function (t) { let e = n(t, 'targets', null); return e === null ? e : (typeof e === 'function' && (e = e.call()), Array.isArray(e) || (e = [e]), e); }; }, function (t, e, i) { const n = i(0); const s = i(1); const r = new n({ initialize(t) { void 0 === t && (t = {}), this.name = s(t, 'name', 'map'), this.width = s(t, 'width', 0), this.height = s(t, 'height', 0), this.tileWidth = s(t, 'tileWidth', 0), this.tileHeight = s(t, 'tileHeight', 0), this.widthInPixels = s(t, 'widthInPixels', this.width * this.tileWidth), this.heightInPixels = s(t, 'heightInPixels', this.height * this.tileHeight), this.format = s(t, 'format', null), this.orientation = s(t, 'orientation', 'orthogonal'), this.version = s(t, 'version', '1'), this.properties = s(t, 'properties', {}), this.layers = s(t, 'layers', []), this.images = s(t, 'images', []), this.objects = s(t, 'objects', {}), this.collision = s(t, 'collision', {}), this.tilesets = s(t, 'tilesets', []), this.imageCollections = s(t, 'imageCollections', []), this.tiles = s(t, 'tiles', []); } }); t.exports = r; }, function (t, e, i) { const n = i(0); const s = i(1); const r = new n({ initialize(t) { void 0 === t && (t = {}), this.name = s(t, 'name', 'layer'), this.x = s(t, 'x', 0), this.y = s(t, 'y', 0), this.width = s(t, 'width', 0), this.height = s(t, 'height', 0), this.tileWidth = s(t, 'tileWidth', 0), this.tileHeight = s(t, 'tileHeight', 0), this.baseTileWidth = s(t, 'baseTileWidth', this.tileWidth), this.baseTileHeight = s(t, 'baseTileHeight', this.tileHeight), this.widthInPixels = s(t, 'widthInPixels', this.width * this.baseTileWidth), this.heightInPixels = s(t, 'heightInPixels', this.height * this.baseTileHeight), this.alpha = s(t, 'alpha', 1), this.visible = s(t, 'visible', !0), this.properties = s(t, 'properties', {}), this.indexes = s(t, 'indexes', []), this.collideIndexes = s(t, 'collideIndexes', []), this.callbacks = s(t, 'callbacks', []), this.bodies = s(t, 'bodies', []), this.data = s(t, 'data', []), this.tilemapLayer = s(t, 'tilemapLayer', null); } }); t.exports = r; }, function (t, e) { t.exports = function (t, e, i) { return t >= 0 && t < i.width && e >= 0 && e < i.height; }; }, function (t, e, i) { const n = i(18); const s = i(74); t.exports = function (t, e) { const i = void 0 === t ? s() : n({}, t); if (e) for (const r in e) void 0 !== e[r] && (i[r] = e[r]); return i; }; }, function (t, e) { t.exports = function (t, e) { return !!t.url && (t.url.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ? t.url : e + t.url); }; }, function (t, e, i) {
  const n = i(127); const s = i(22); const r = i(0); const o = i(15); const a = i(20); const h = i(2); const l = i(404); const u = i(4); const c = i(268); const d = i(403); const f = i(400); const p = new r({
    Extends: h,
    Mixins: [o.Alpha, o.BlendMode, o.ComputedSize, o.Depth, o.Flip, o.GetBounds, o.Mask, o.Origin, o.Pipeline, o.ScaleMode, o.ScrollFactor, o.Tint, o.Transform, o.Visible, d],
    initialize(t, e, i, n, r) {
      void 0 === e && (e = 0), void 0 === i && (i = 0), h.call(this, t, 'Text'), this.setPosition(e, i), this.setOrigin(0, 0), this.initPipeline('TextureTintPipeline'), this.canvas = s.create(this), this.context = this.canvas.getContext('2d'), this.style = new f(this, r), this.autoRound = !0, this.splitRegExp = /(?:\r\n|\r|\n)/, this.text = '', this.resolution = 1, this.padding = {
        left: 0, right: 0, top: 0, bottom: 0,
      }, this.width = 1, this.height = 1, this.canvasTexture = null, this.dirty = !1, this.initRTL(), r && r.padding && this.setPadding(r.padding), r && r.lineSpacing && (this._lineSpacing = r.lineSpacing), this.setText(n), t.sys.game.config.renderType === a.WEBGL && t.sys.game.renderer.onContextRestored(function () { this.canvasTexture = null, this.dirty = !0; }, this);
    },
    initRTL() { this.style.rtl && (this.canvas.dir = 'rtl', this.context.direction = 'rtl', this.canvas.style.display = 'none', n(this.canvas, this.scene.sys.canvas), this.originX = 1); },
    runWordWrap(t) { const e = this.style; if (e.wordWrapCallback) { let i = e.wordWrapCallback.call(e.wordWrapCallbackScope, t, this); return Array.isArray(i) && (i = i.join('\n')), i; } return e.wordWrapWidth ? e.wordWrapUseAdvanced ? this.advancedWordWrap(t, this.context, this.style.wordWrapWidth) : this.basicWordWrap(t, this.context, this.style.wordWrapWidth) : t; },
    advancedWordWrap(t, e, i) { for (var n = '', s = t.replace(/ +/gi, ' ').split(this.splitRegExp), r = s.length, o = 0; o < r; o++) { let a = s[o]; let h = ''; if (a = a.replace(/^ *|\s*$/gi, ''), e.measureText(a).width < i)n += `${a}\n`; else { for (let l = i, u = a.split(' '), c = 0; c < u.length; c++) { const d = u[c]; const f = `${d} `; let p = e.measureText(f).width; if (p > l) { if (c === 0) { for (var g = f; g.length && (g = g.slice(0, -1), !((p = e.measureText(g).width) <= l)););if (!g.length) throw new Error("This text's wordWrapWidth setting is less than a single character!"); const v = d.substr(g.length); u[c] = v, h += g; } const y = u[c].length ? c : c + 1; const m = u.slice(y).join(' ').replace(/[ \n]*$/gi, ''); s[o + 1] = `${m} ${s[o + 1] || ''}`, r = s.length; break; }h += f, l -= p; }n += `${h.replace(/[ \n]*$/gi, '')}\n`; } } return n = n.replace(/[\s|\n]*$/gi, ''); },
    basicWordWrap(t, e, i) { for (var n = '', s = t.split(this.splitRegExp), r = 0; r < s.length; r++) { for (let o = i, a = s[r].split(' '), h = 0; h < a.length; h++) { const l = e.measureText(a[h]).width; const u = l + e.measureText(' ').width; u > o ? (h > 0 && (n += '\n'), n += `${a[h]} `, o = i - l) : (o -= u, n += a[h], h < a.length - 1 && (n += ' ')); }r < s.length - 1 && (n += '\n'); } return n; },
    getWrappedText(t) { return void 0 === t && (t = this.text), this.style.syncFont(this.canvas, this.context), this.runWordWrap(t).split(this.splitRegExp); },
    setText(t) { return t || t === 0 || (t = ''), Array.isArray(t) && (t = t.join('\n')), t !== this.text && (this.text = t.toString(), this.updateText()), this; },
    setStyle(t) { return this.style.setStyle(t); },
    setFont(t) { return this.style.setFont(t); },
    setFontFamily(t) { return this.style.setFontFamily(t); },
    setFontSize(t) { return this.style.setFontSize(t); },
    setFontStyle(t) { return this.style.setFontStyle(t); },
    setFixedSize(t, e) { return this.style.setFixedSize(t, e); },
    setBackgroundColor(t) { return this.style.setBackgroundColor(t); },
    setFill(t) { return this.style.setFill(t); },
    setColor(t) { return this.style.setColor(t); },
    setStroke(t, e) { return this.style.setStroke(t, e); },
    setShadow(t, e, i, n, s, r) { return this.style.setShadow(t, e, i, n, s, r); },
    setShadowOffset(t, e) { return this.style.setShadowOffset(t, e); },
    setShadowColor(t) { return this.style.setShadowColor(t); },
    setShadowBlur(t) { return this.style.setShadowBlur(t); },
    setShadowStroke(t) { return this.style.setShadowStroke(t); },
    setShadowFill(t) { return this.style.setShadowFill(t); },
    setWordWrapWidth(t, e) { return this.style.setWordWrapWidth(t, e); },
    setWordWrapCallback(t, e) { return this.style.setWordWrapCallback(t, e); },
    setAlign(t) { return this.style.setAlign(t); },
    setPadding(t, e, i, n) { if (typeof t === 'object') { const s = t; const r = u(s, 'x', null); r !== null ? (t = r, i = r) : (t = u(s, 'left', 0), i = u(s, 'right', t)); const o = u(s, 'y', null); o !== null ? (e = o, n = o) : (e = u(s, 'top', 0), n = u(s, 'bottom', e)); } else void 0 === t && (t = 0), void 0 === e && (e = t), void 0 === i && (i = t), void 0 === n && (n = e); return this.padding.left = t, this.padding.top = e, this.padding.right = i, this.padding.bottom = n, this.updateText(); },
    setMaxLines(t) { return this.style.setMaxLines(t); },
    updateText() { const t = this.canvas; const e = this.context; const i = this.style; const n = this.resolution; const s = i.metrics; i.syncFont(t, e); let r = this.text; (i.wordWrapWidth || i.wordWrapCallback) && (r = this.runWordWrap(this.text)); let o; let a; const h = r.split(this.splitRegExp); const u = l(this, s, h); const c = this.padding; let d = u.width + c.left + c.right; let f = u.height + c.top + c.bottom; i.fixedWidth === 0 && (this.width = d), i.fixedHeight === 0 && (this.height = f), this.updateDisplayOrigin(), d *= n, f *= n, d = Math.max(d, 1), f = Math.max(f, 1), t.width !== d || t.height !== f ? (t.width = d, t.height = f, i.syncFont(t, e)) : e.clearRect(0, 0, d, f), e.save(), i.backgroundColor && (e.fillStyle = i.backgroundColor, e.fillRect(0, 0, d, f)), i.syncStyle(t, e), e.textBaseline = 'alphabetic', e.translate(c.left, c.top); for (let p = 0; p < u.lines; p++)o = i.strokeThickness / 2, a = i.strokeThickness / 2 + p * u.lineHeight + s.ascent, p > 0 && (a += u.lineSpacing * p), i.rtl ? o = d - o : i.align === 'right' ? o += u.width - u.lineWidths[p] : i.align === 'center' && (o += (u.width - u.lineWidths[p]) / 2), this.autoRound && (o = Math.round(o), a = Math.round(a)), i.strokeThickness && (this.style.syncShadow(e, i.shadowStroke), e.strokeText(h[p], o, a)), i.color && (this.style.syncShadow(e, i.shadowFill), e.fillText(h[p], o, a)); return e.restore(), this.dirty = !0, this; },
    getTextMetrics() { return this.style.getTextMetrics(); },
    toJSON() {
      const t = o.ToJSON(this); const e = {
        autoRound: this.autoRound,
        text: this.text,
        style: this.style.toJSON(),
        resolution: this.resolution,
        padding: {
          left: this.padding.left, right: this.padding.right, top: this.padding.top, bottom: this.padding.bottom,
        },
      }; return t.data = e, t;
    },
    preDestroy() { this.style.rtl && c(this.canvas), s.remove(this.canvas); },
  }); t.exports = p;
}, function (t, e) { t.exports = function (t, e) { return t.hasOwnProperty(e); }; }, function (t, e, i) {
  const n = i(594); const s = i(0); const r = i(1); const o = i(4); const a = i(253); const h = i(70); const l = i(34); const u = new s({
    initialize(t, e, i) { void 0 !== i || Array.isArray(e) || typeof e !== 'object' || (i = e, e = null), this.scene = t, this.children = new h(e), this.isParent = !0, this.classType = r(i, 'classType', l), this.active = r(i, 'active', !0), this.maxSize = r(i, 'maxSize', -1), this.defaultKey = r(i, 'defaultKey', null), this.defaultFrame = r(i, 'defaultFrame', null), this.runChildUpdate = r(i, 'runChildUpdate', !1), this.createCallback = r(i, 'createCallback', null), this.removeCallback = r(i, 'removeCallback', null), this.createMultipleCallback = r(i, 'createMultipleCallback', null), i && this.createMultiple(i); },
    create(t, e, i, n, s, r) { if (void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.defaultKey), void 0 === n && (n = this.defaultFrame), void 0 === s && (s = !0), void 0 === r && (r = !0), this.isFull()) return null; const o = new this.classType(this.scene, t, e, i, n); return this.scene.sys.displayList.add(o), o.preUpdate && this.scene.sys.updateList.add(o), o.visible = s, o.setActive(r), this.add(o), o; },
    createMultiple(t) { if (this.isFull()) return []; if (Array.isArray(t) || (t = [t]), void 0 === t[0].key) return []; for (var e = [], i = 0; i < t.length; i++) { const n = this.createFromConfig(t[i]); e = e.concat(n); } return e; },
    createFromConfig(t) {
      if (this.isFull()) return []; this.classType = r(t, 'classType', this.classType); let e = r(t, 'key', void 0); let i = r(t, 'frame', null); const s = r(t, 'visible', !0); const h = r(t, 'active', !0); const l = []; if (void 0 === e) return l; Array.isArray(e) || (e = [e]), Array.isArray(i) || (i = [i]); for (let u = r(t, 'repeat', 0), c = r(t, 'randomKey', !1), d = r(t, 'randomFrame', !1), f = r(t, 'yoyo', !1), p = r(t, 'frameQuantity', 1), g = r(t, 'max', 0), v = a(e, i, {
          max: g, qty: p, random: c, randomB: d, repeat: u, yoyo: f,
        }), y = 0; y < v.length; y++) { const m = this.create(0, 0, v[y].a, v[y].b, s, h); if (!m) break; l.push(m); } const x = o(t, 'setXY.x', 0); const w = o(t, 'setXY.y', 0); const b = o(t, 'setXY.stepX', 0); const T = o(t, 'setXY.stepY', 0); n.SetXY(l, x, w, b, T); const S = o(t, 'setRotation.value', 0); const A = o(t, 'setRotation.step', 0); n.SetRotation(l, S, A); const C = o(t, 'setScale.x', 1); const M = o(t, 'setScale.y', C); const _ = o(t, 'setScale.stepX', 0); const E = o(t, 'setScale.stepY', 0); n.SetScale(l, C, M, _, E); const P = o(t, 'setAlpha.value', 1); const L = o(t, 'setAlpha.step', 0); n.SetAlpha(l, P, L); const F = r(t, 'hitArea', null); const k = r(t, 'hitAreaCallback', null); F && n.SetHitArea(l, F, k); const R = r(t, 'gridAlign', !1); return R && n.GridAlign(l, R), this.createMultipleCallback && this.createMultipleCallback.call(this, l), l;
    },
    preUpdate(t, e) { if (this.runChildUpdate && this.children.size !== 0) for (let i = this.children.entries.slice(), n = 0; n < i.length; n++) { const s = i[n]; s.active && s.update(t, e); } },
    add(t, e) { return void 0 === e && (e = !1), this.isFull() ? this : (this.children.set(t), this.createCallback && this.createCallback.call(this, t), e && (this.scene.sys.displayList.add(t), t.preUpdate && this.scene.sys.updateList.add(t)), t.on('destroy', this.remove, this), this); },
    addMultiple(t, e) { if (void 0 === e && (e = !1), Array.isArray(t)) for (let i = 0; i < t.length; i++) this.add(t[i], e); return this; },
    remove(t, e, i) { return void 0 === e && (e = !1), void 0 === i && (i = !1), this.children.contains(t) ? (this.children.delete(t), this.removeCallback && this.removeCallback.call(this, t), t.off('destroy', this.remove, this), i ? t.destroy() : e && (t.scene.sys.displayList.remove(t), t.preUpdate && t.scene.sys.updateList.remove(t)), this) : this; },
    clear(t, e) { void 0 === t && (t = !1), void 0 === e && (e = !1); for (let i = this.children, n = 0; n < i.size; n++) { const s = i.entries[n]; s.off('destroy', this.remove, this), e ? s.destroy() : t && (s.scene.sys.displayList.remove(s), s.preUpdate && s.scene.sys.updateList.remove(s)); } return this.children.clear(), this; },
    contains(t) { return this.children.contains(t); },
    getChildren() { return this.children.entries; },
    getLength() { return this.children.size; },
    getFirst(t, e, i, n, s, r, o) { return this.getHandler(!0, 1, t, e, i, n, s, r, o); },
    getFirstNth(t, e, i, n, s, r, o, a) { return this.getHandler(!0, t, e, i, n, s, r, o, a); },
    getLast(t, e, i, n, s, r, o) { return this.getHandler(!1, 1, t, e, i, n, s, r, o); },
    getLastNth(t, e, i, n, s, r, o, a) { return this.getHandler(!1, t, e, i, n, s, r, o, a); },
    getHandler(t, e, i, n, s, r, o, a, h) { let l; let u; void 0 === i && (i = !1), void 0 === n && (n = !1); let c = 0; const d = this.children.entries; if (t) for (u = 0; u < d.length; u++) if ((l = d[u]).active === i) { if (++c === e) break; } else l = null; else for (u = d.length - 1; u >= 0; u--) if ((l = d[u]).active === i) { if (++c === e) break; } else l = null; return l ? (typeof s === 'number' && (l.x = s), typeof r === 'number' && (l.y = r), l) : n ? this.create(s, r, o, a, h) : null; },
    get(t, e, i, n, s) { return this.getFirst(!1, !0, t, e, i, n, s); },
    getFirstAlive(t, e, i, n, s, r) { return this.getFirst(!0, t, e, i, n, s, r); },
    getFirstDead(t, e, i, n, s, r) { return this.getFirst(!1, t, e, i, n, s, r); },
    playAnimation(t, e) { return n.PlayAnimation(this.children.entries, t, e), this; },
    isFull() { return this.maxSize !== -1 && this.children.size >= this.maxSize; },
    countActive(t) { void 0 === t && (t = !0); for (var e = 0, i = 0; i < this.children.size; i++) this.children.entries[i].active === t && e++; return e; },
    getTotalUsed() { return this.countActive(); },
    getTotalFree() { const t = this.getTotalUsed(); return (this.maxSize === -1 ? 999999999999 : this.maxSize) - t; },
    setDepth(t, e) { return n.SetDepth(this.children.entries, t, e), this; },
    kill(t) { this.children.contains(t) && t.setActive(!1); },
    killAndHide(t) { this.children.contains(t) && (t.setActive(!1), t.setVisible(!1)); },
    toggleVisible() { return n.ToggleVisible(this.children.entries), this; },
    destroy(t) { if (void 0 === t && (t = !1), this.scene && !this.ignoreDestroy) { if (t) for (let e = this.children, i = 0; i < e.size; i++) { const n = e.entries[i]; n.off('destroy', this.remove, this), n.destroy(); } this.children.clear(), this.scene = void 0, this.children = void 0; } },
  }); t.exports = u;
}, function (t, e, i) { const n = i(5); t.exports = function (t, e, i) { void 0 === i && (i = new n()); const s = t.width / 2; const r = t.height / 2; return i.x = t.x + s * Math.cos(e), i.y = t.y + r * Math.sin(e), i; }; }, function (t, e, i) {
  const n = i(0); const s = i(53); const r = i(171); const o = i(170); const a = i(131); const h = new n({
    initialize(t, e, i, n) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this.x = t, this.y = e, this.width = i, this.height = n; }, contains(t, e) { return s(this, t, e); }, getPoint(t, e) { return r(this, t, e); }, getPoints(t, e, i) { return o(this, t, e, i); }, getRandomPoint(t) { return a(this, t); }, setTo(t, e, i, n) { return this.x = t, this.y = e, this.width = i, this.height = n, this; }, setEmpty() { return this.width = 0, this.height = 0, this; }, setPosition(t, e) { return void 0 === e && (e = t), this.x = t, this.y = e, this; }, setSize(t, e) { return void 0 === e && (e = t), this.width = t, this.height = e, this; }, isEmpty() { return this.width <= 0 || this.height <= 0; }, getMinorRadius() { return Math.min(this.width, this.height) / 2; }, getMajorRadius() { return Math.max(this.width, this.height) / 2; }, left: { get() { return this.x - this.width / 2; }, set(t) { this.x = t + this.width / 2; } }, right: { get() { return this.x + this.width / 2; }, set(t) { this.x = t - this.width / 2; } }, top: { get() { return this.y - this.height / 2; }, set(t) { this.y = t + this.height / 2; } }, bottom: { get() { return this.y + this.height / 2; }, set(t) { this.y = t - this.height / 2; } },
  }); t.exports = h;
}, function (t, e, i) {
  const n = i(121); const s = i(0); const r = i(117); const o = i(15); const a = i(248); const h = i(2); const l = i(4); const u = i(16); const c = i(450); var d = new s({
    Extends: h, Mixins: [o.Alpha, o.BlendMode, o.Depth, o.Mask, o.Pipeline, o.Transform, o.Visible, o.ScrollFactor, c], initialize(t, e) { const i = l(e, 'x', 0); const n = l(e, 'y', 0); h.call(this, t, 'Graphics'), this.setPosition(i, n), this.initPipeline('FlatTintPipeline'), this.displayOriginX = 0, this.displayOriginY = 0, this.commandBuffer = [], this.defaultFillColor = -1, this.defaultFillAlpha = 1, this.defaultStrokeWidth = 1, this.defaultStrokeColor = -1, this.defaultStrokeAlpha = 1, this._lineWidth = 1, this.setDefaultStyles(e); }, setDefaultStyles(t) { return l(t, 'lineStyle', null) && (this.defaultStrokeWidth = l(t, 'lineStyle.width', 1), this.defaultStrokeColor = l(t, 'lineStyle.color', 16777215), this.defaultStrokeAlpha = l(t, 'lineStyle.alpha', 1), this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha)), l(t, 'fillStyle', null) && (this.defaultFillColor = l(t, 'fillStyle.color', 16777215), this.defaultFillAlpha = l(t, 'fillStyle.alpha', 1), this.fillStyle(this.defaultFillColor, this.defaultFillAlpha)), this; }, lineStyle(t, e, i) { return void 0 === i && (i = 1), this.commandBuffer.push(r.LINE_STYLE, t, e, i), this._lineWidth = t, this; }, fillStyle(t, e) { return void 0 === e && (e = 1), this.commandBuffer.push(r.FILL_STYLE, t, e), this; }, beginPath() { return this.commandBuffer.push(r.BEGIN_PATH), this; }, closePath() { return this.commandBuffer.push(r.CLOSE_PATH), this; }, fillPath() { return this.commandBuffer.push(r.FILL_PATH), this; }, strokePath() { return this.commandBuffer.push(r.STROKE_PATH), this; }, fillCircleShape(t) { return this.fillCircle(t.x, t.y, t.radius); }, strokeCircleShape(t) { return this.strokeCircle(t.x, t.y, t.radius); }, fillCircle(t, e, i) { return this.beginPath(), this.arc(t, e, i, 0, u.PI2), this.fillPath(), this; }, strokeCircle(t, e, i) { return this.beginPath(), this.arc(t, e, i, 0, u.PI2), this.strokePath(), this; }, fillRectShape(t) { return this.fillRect(t.x, t.y, t.width, t.height); }, strokeRectShape(t) { return this.strokeRect(t.x, t.y, t.width, t.height); }, fillRect(t, e, i, n) { return this.commandBuffer.push(r.FILL_RECT, t, e, i, n), this; }, strokeRect(t, e, i, n) { const s = this._lineWidth / 2; const r = t - s; const o = t + s; return this.beginPath(), this.moveTo(t, e), this.lineTo(t, e + n), this.strokePath(), this.beginPath(), this.moveTo(t + i, e), this.lineTo(t + i, e + n), this.strokePath(), this.beginPath(), this.moveTo(r, e), this.lineTo(o + i, e), this.strokePath(), this.beginPath(), this.moveTo(r, e + n), this.lineTo(o + i, e + n), this.strokePath(), this; }, fillPointShape(t, e) { return this.fillPoint(t.x, t.y, e); }, fillPoint(t, e, i) { return !i || i < 1 ? i = 1 : (t -= i / 2, e -= i / 2), this.commandBuffer.push(r.FILL_RECT, t, e, i, i), this; }, fillTriangleShape(t) { return this.fillTriangle(t.x1, t.y1, t.x2, t.y2, t.x3, t.y3); }, strokeTriangleShape(t) { return this.strokeTriangle(t.x1, t.y1, t.x2, t.y2, t.x3, t.y3); }, fillTriangle(t, e, i, n, s, o) { return this.commandBuffer.push(r.FILL_TRIANGLE, t, e, i, n, s, o), this; }, strokeTriangle(t, e, i, n, s, o) { return this.commandBuffer.push(r.STROKE_TRIANGLE, t, e, i, n, s, o), this; }, strokeLineShape(t) { return this.lineBetween(t.x1, t.y1, t.x2, t.y2); }, lineBetween(t, e, i, n) { return this.beginPath(), this.moveTo(t, e), this.lineTo(i, n), this.strokePath(), this; }, lineTo(t, e) { return this.commandBuffer.push(r.LINE_TO, t, e), this; }, moveTo(t, e) { return this.commandBuffer.push(r.MOVE_TO, t, e), this; }, lineFxTo(t, e, i, n) { return this.commandBuffer.push(r.LINE_FX_TO, t, e, i, n, 1), this; }, moveFxTo(t, e, i, n) { return this.commandBuffer.push(r.MOVE_FX_TO, t, e, i, n, 1), this; }, strokePoints(t, e, i) { void 0 === e && (e = !1), void 0 === i && (i = t.length), this.beginPath(), this.moveTo(t[0].x, t[0].y); for (let n = 1; n < i; n++) this.lineTo(t[n].x, t[n].y); return e && this.lineTo(t[0].x, t[0].y), this.strokePath(), this; }, fillPoints(t, e, i) { void 0 === e && (e = !1), void 0 === i && (i = t.length), this.beginPath(), this.moveTo(t[0].x, t[0].y); for (let n = 1; n < i; n++) this.lineTo(t[n].x, t[n].y); return e && this.lineTo(t[0].x, t[0].y), this.fillPath(), this; }, strokeEllipseShape(t, e) { void 0 === e && (e = 32); const i = t.getPoints(e); return this.strokePoints(i, !0); }, strokeEllipse(t, e, i, n, s) { void 0 === s && (s = 32); const r = new a(t, e, i, n).getPoints(s); return this.strokePoints(r, !0); }, fillEllipseShape(t, e) { void 0 === e && (e = 32); const i = t.getPoints(e); return this.fillPoints(i, !0); }, fillEllipse(t, e, i, n, s) { void 0 === s && (s = 32); const r = new a(t, e, i, n).getPoints(s); return this.fillPoints(r, !0); }, arc(t, e, i, n, s, o) { return this.commandBuffer.push(r.ARC, t, e, i, n, s, o), this; }, slice(t, e, i, n, s, o) { return void 0 === o && (o = !1), this.commandBuffer.push(r.BEGIN_PATH), this.commandBuffer.push(r.MOVE_TO, t, e), this.commandBuffer.push(r.ARC, t, e, i, n, s, o), this.commandBuffer.push(r.CLOSE_PATH), this; }, save() { return this.commandBuffer.push(r.SAVE), this; }, restore() { return this.commandBuffer.push(r.RESTORE), this; }, translate(t, e) { return this.commandBuffer.push(r.TRANSLATE, t, e), this; }, scale(t, e) { return this.commandBuffer.push(r.SCALE, t, e), this; }, rotate(t) { return this.commandBuffer.push(r.ROTATE, t), this; }, clear() { return this.commandBuffer.length = 0, this.defaultFillColor > -1 && this.fillStyle(this.defaultFillColor, this.defaultFillAlpha), this.defaultStrokeColor > -1 && this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha), this; }, generateTexture(t, e, i) { let n; let s; const r = this.scene.sys; if (void 0 === e && (e = r.game.config.width), void 0 === i && (i = r.game.config.height), d.TargetCamera.setViewport(0, 0, e, i), d.TargetCamera.scrollX = this.x, d.TargetCamera.scrollY = this.y, typeof t === 'string') if (r.textures.exists(t)) { const o = (n = r.textures.get(t)).getSourceImage(); o instanceof HTMLCanvasElement && (s = o.getContext('2d')); } else s = (n = r.textures.createCanvas(t, e, i)).getSourceImage().getContext('2d'); else t instanceof HTMLCanvasElement && (s = t.getContext('2d')); return s && (this.renderCanvas(r.game.renderer, this, 0, d.TargetCamera, null, s), r.game.renderer.gl && n && (n.source[0].glTexture = r.game.renderer.canvasToTexture(s.canvas, n.source[0].glTexture))), this; }, preDestroy() { this.commandBuffer = []; },
  }); d.TargetCamera = new n(0, 0, 0, 0), t.exports = d;
}, function (t, e) { t.exports = function (t) { if (!Array.isArray(t) || t.length < 2 || !Array.isArray(t[0])) return !1; for (let e = t[0].length, i = 1; i < t.length; i++) if (t[i].length !== e) return !1; return !0; }; }, function (t, e, i) {
  const n = i(0); const s = i(125); const r = i(175); const o = new n({
    initialize(t, e, i, n, s) { Array.isArray(i) || (i = [i]), this.manager = t, this.key = e, this.source = [], this.dataSource = [], this.frames = {}, this.customData = {}, this.firstFrame = '__BASE', this.frameTotal = 0; for (let o = 0; o < i.length; o++) this.source.push(new r(this, i[o], n, s)); }, add(t, e, i, n, r, o) { const a = new s(this, t, e, i, n, r, o); return this.frames[t] = a, this.frameTotal === 1 && (this.firstFrame = t), this.frameTotal++, a; }, has(t) { return this.frames[t]; }, get(t) { t || (t = this.firstFrame); let e = this.frames[t]; return e || (console.warn(`No Texture.frame found with name ${t}`), e = this.frames[this.firstFrame]), e; }, getTextureSourceIndex(t) { for (let e = 0; e < this.source.length; e++) if (this.source[e] === t) return e; return -1; }, getFramesFromTextureSource(t) { const e = []; for (const i in this.frames) if (i !== '__BASE') { const n = this.frames[i]; n.sourceIndex === t && e.push(n.name); } return e; }, getFrameNames(t) { void 0 === t && (t = !1); const e = Object.keys(this.frames); if (!t) { const i = e.indexOf('__BASE'); i !== -1 && e.splice(i, 1); } return e; }, getSourceImage(t) { void 0 !== t && t !== null && this.frameTotal !== 1 || (t = '__BASE'); const e = this.frames[t]; return e ? e.source.image : (console.warn(`No Texture.frame found with name ${t}`), this.frames.__BASE.source.image); }, getDataSourceImage(t) { void 0 !== t && t !== null && this.frameTotal !== 1 || (t = '__BASE'); let e; const i = this.frames[t]; return i ? e = i.sourceIndex : (console.warn(`No Texture.frame found with name ${t}`), e = this.frames.__BASE.sourceIndex), this.dataSource[e].image; }, setDataSource(t) { Array.isArray(t) || (t = [t]); for (let e = 0; e < t.length; e++) { const i = this.source[e]; this.dataSource.push(new r(this, t[e], i.width, i.height)); } }, setFilter(t) { let e; for (e = 0; e < this.source.length; e++) this.source[e].setFilter(t); for (e = 0; e < this.dataSource.length; e++) this.dataSource[e].setFilter(t); }, destroy() { let t; for (t = 0; t < this.source.length; t++) this.source[t].destroy(); for (t = 0; t < this.dataSource.length; t++) this.dataSource[t].destroy(); for (const e in this.frames) { this.frames[e].destroy(); } this.source = [], this.dataSource = [], this.frames = {}, this.manager = null; },
  }); t.exports = o;
}, function (t, e, i) {
  const n = i(0); const s = i(54); const r = i(119); const o = i(505); const a = i(504); const h = i(184); const l = new n({
    initialize(t, e) { this.scene = t, this.game, this.config = e, this.settings = h.create(e), this.canvas, this.context, this.anims, this.cache, this.plugins, this.registry, this.sound, this.textures, this.add, this.cameras, this.displayList, this.events, this.make, this.scenePlugin, this.updateList; }, init(t) { this.settings.status = s.INIT, this.game = t, this.canvas = t.canvas, this.context = t.context; const e = t.plugins; this.plugins = e, e.addToScene(this, r.Global, [r.CoreScene, a(this), o(this)]), this.events.emit('boot', this), this.settings.isBooted = !0; }, install(t) { Array.isArray(t) || (t = [t]), this.plugins.installLocal(this, t); }, step(t, e) { this.events.emit('preupdate', t, e), this.events.emit('update', t, e), this.scene.update.call(this.scene, t, e), this.events.emit('postupdate', t, e); }, render(t) { const e = this.displayList; e.depthSort(), this.cameras.render(t, e), this.events.emit('render', t); }, queueDepthSort() { this.displayList.queueDepthSort(); }, depthSort() { this.displayList.depthSort(); }, pause() { return this.settings.active && (this.settings.status = s.PAUSED, this.settings.active = !1, this.events.emit('pause', this)), this; }, resume() { return this.settings.active || (this.settings.status = s.RUNNING, this.settings.active = !0, this.events.emit('resume', this)), this; }, sleep() { return this.settings.status = s.SLEEPING, this.settings.active = !1, this.settings.visible = !1, this.events.emit('sleep', this), this; }, wake() { const t = this.settings; return t.status = s.RUNNING, t.active = !0, t.visible = !0, this.events.emit('wake', this), t.isTransition && this.events.emit('transitionwake', t.transitionFrom, t.transitionDuration), this; }, isSleeping() { return this.settings.status === s.SLEEPING; }, isActive() { return this.settings.status === s.RUNNING; }, isTransitioning() { return this.settings.isTransition || this.scenePlugin._target !== null; }, isTransitionOut() { return this.scenePlugin._target !== null && this.scenePlugin._duration > 0; }, isTransitionIn() { return this.settings.isTransition; }, isVisible() { return this.settings.visible; }, setVisible(t) { return this.settings.visible = t, this; }, setActive(t) { return t ? this.resume() : this.pause(); }, start(t) { t && (this.settings.data = t), this.settings.status = s.START, this.settings.active = !0, this.settings.visible = !0, this.events.emit('start', this), this.events.emit('ready', this); }, resize(t, e) { this.events.emit('resize', t, e); }, shutdown() { this.events.off('transitioninit'), this.events.off('transitionstart'), this.events.off('transitioncomplete'), this.events.off('transitionout'), this.settings.status = s.SHUTDOWN, this.settings.active = !1, this.settings.visible = !1, this.events.emit('shutdown', this); }, destroy() { this.settings.status = s.DESTROYED, this.settings.active = !1, this.settings.visible = !1, this.events.emit('destroy', this), this.events.removeAllListeners(); for (let t = ['scene', 'game', 'anims', 'cache', 'plugins', 'registry', 'sound', 'textures', 'add', 'camera', 'displayList', 'events', 'make', 'scenePlugin', 'updateList'], e = 0; e < t.length; e++) this[t[e]] = null; },
  }); t.exports = l;
}, function (t, e) {
  t.exports = {
    BACKSPACE: 8, TAB: 9, ENTER: 13, SHIFT: 16, CTRL: 17, ALT: 18, PAUSE: 19, CAPS_LOCK: 20, ESC: 27, SPACE: 32, PAGE_UP: 33, PAGE_DOWN: 34, END: 35, HOME: 36, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, PRINT_SCREEN: 42, INSERT: 45, DELETE: 46, ZERO: 48, ONE: 49, TWO: 50, THREE: 51, FOUR: 52, FIVE: 53, SIX: 54, SEVEN: 55, EIGHT: 56, NINE: 57, NUMPAD_ZERO: 96, NUMPAD_ONE: 97, NUMPAD_TWO: 98, NUMPAD_THREE: 99, NUMPAD_FOUR: 100, NUMPAD_FIVE: 101, NUMPAD_SIX: 102, NUMPAD_SEVEN: 103, NUMPAD_EIGHT: 104, NUMPAD_NINE: 105, A: 65, B: 66, C: 67, D: 68, E: 69, F: 70, G: 71, H: 72, I: 73, J: 74, K: 75, L: 76, M: 77, N: 78, O: 79, P: 80, Q: 81, R: 82, S: 83, T: 84, U: 85, V: 86, W: 87, X: 88, Y: 89, Z: 90, F1: 112, F2: 113, F3: 114, F4: 115, F5: 116, F6: 117, F7: 118, F8: 119, F9: 120, F10: 121, F11: 122, F12: 123, SEMICOLON: 186, PLUS: 187, COMMA: 188, MINUS: 189, PERIOD: 190, FORWARD_SLASH: 191, BACK_SLASH: 220, QUOTES: 222, BACKTICK: 192, OPEN_BRACKET: 219, CLOSED_BRACKET: 221,
  };
}, function (t, e) {
  t.exports = {
    ARC: 0, BEGIN_PATH: 1, CLOSE_PATH: 2, FILL_RECT: 3, LINE_TO: 4, MOVE_TO: 5, LINE_STYLE: 6, FILL_STYLE: 7, FILL_PATH: 8, STROKE_PATH: 9, FILL_TRIANGLE: 10, STROKE_TRIANGLE: 11, LINE_FX_TO: 12, MOVE_FX_TO: 13, SAVE: 14, RESTORE: 15, TRANSLATE: 16, SCALE: 17, ROTATE: 18,
  };
}, function (t, e, i) {
  const n = i(56); const s = i(78); const r = i(22); const o = {
    canvas: !1, canvasBitBltShift: null, file: !1, fileSystem: !1, getUserMedia: !0, littleEndian: !1, localStorage: !1, pointerLock: !1, support32bit: !1, vibration: !1, webGL: !1, worker: !1,
  }; t.exports = (function () { o.canvas = !!window.CanvasRenderingContext2D || n.cocoonJS; try { o.localStorage = !!localStorage.getItem; } catch (t) { o.localStorage = !1; }o.file = !!(window.File && window.FileReader && window.FileList && window.Blob), o.fileSystem = !!window.requestFileSystem; let t; let e; let i; let a = !1; return o.webGL = (function () { if (window.WebGLRenderingContext) try { const t = r.createWebGL(this); n.cocoonJS && (t.screencanvas = !1); const e = t.getContext('webgl') || t.getContext('experimental-webgl'); const i = r.create2D(this); const s = i.getContext('2d').createImageData(1, 1); return a = s.data instanceof Uint8ClampedArray, r.remove(t), r.remove(i), !!e; } catch (t) { return !1; } return !1; }()), o.worker = !!window.Worker, o.pointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document, navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia, window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL, o.getUserMedia = o.getUserMedia && !!navigator.getUserMedia && !!window.URL, s.firefox && s.firefoxVersion < 21 && (o.getUserMedia = !1), !n.iOS && (s.ie || s.firefox || s.chrome) && (o.canvasBitBltShift = !0), (s.safari || s.mobileSafari) && (o.canvasBitBltShift = !1), navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate, navigator.vibrate && (o.vibration = !0), typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined' && typeof Uint32Array !== 'undefined' && (o.littleEndian = (t = new ArrayBuffer(4), e = new Uint8Array(t), i = new Uint32Array(t), e[0] = 161, e[1] = 178, e[2] = 195, e[3] = 212, i[0] === 3569595041 || i[0] !== 2712847316 && null)), o.support32bit = typeof ArrayBuffer !== 'undefined' && typeof Uint8ClampedArray !== 'undefined' && typeof Int32Array !== 'undefined' && o.littleEndian !== null && a, o; }());
}, function (t, e) { t.exports = { Global: ['anims', 'cache', 'plugins', 'registry', 'sound', 'textures'], CoreScene: ['EventEmitter', 'CameraManager', 'GameObjectCreator', 'GameObjectFactory', 'ScenePlugin', 'DisplayList', 'UpdateList'], DefaultScene: ['CameraManager3D', 'Clock', 'DataManagerPlugin', 'InputPlugin', 'Loader', 'TweenManager', 'LightsPlugin'] }; }, function (t, e) { t.exports = function (t, e, i) { return (e - t) * i + t; }; }, function (t, e, i) {
  const n = i(23); const s = i(0); const r = i(38); const o = i(202); const a = i(9); const h = i(120); const l = i(14); const u = i(63); const c = i(129); const d = i(7); const f = new s({
    Extends: a,
    initialize(t, e, i, n) { a.call(this), this.scene, this.name = '', this.x = t, this.y = e, this.width = i, this.height = n, this.roundPixels = !1, this.useBounds = !1, this._bounds = new l(), this.inputEnabled = !0, this.scrollX = 0, this.scrollY = 0, this.zoom = 1, this.rotation = 0, this.matrix = new u(1, 0, 0, 1, 0, 0), this.transparent = !0, this.backgroundColor = c('rgba(0,0,0,0)'), this.fadeEffect = new o.Fade(this), this.flashEffect = new o.Flash(this), this.shakeEffect = new o.Shake(this), this.disableCull = !1, this.culledObjects = [], this.lerp = new d(1, 1), this.followOffset = new d(), this._follow = null, this._id = 0; },
    centerToBounds() { return this.useBounds && (this.scrollX = 0.5 * this._bounds.width - 0.5 * this.width, this.scrollY = 0.5 * this._bounds.height - 0.5 * this.height), this; },
    centerToSize() { return this.scrollX = 0.5 * this.width, this.scrollY = 0.5 * this.height, this; },
    cull(t) { if (this.disableCull) return t; const e = this.matrix.matrix; const i = e[0]; const n = e[1]; const s = e[2]; const r = e[3]; let o = i * r - n * s; if (!o) return t; const a = e[4]; const h = e[5]; const l = this.scrollX; const u = this.scrollY; const c = this.width; const d = this.height; const f = this.culledObjects; const p = t.length; o = 1 / o, f.length = 0; for (let g = 0; g < p; ++g) { const v = t[g]; if (v.hasOwnProperty('width') && !v.parentContainer) { const y = v.width; const m = v.height; const x = v.x - l * v.scrollFactorX - y * v.originX; const w = v.y - u * v.scrollFactorY - m * v.originY; const b = x * i + w * s + a; const T = x * n + w * r + h; const S = (x + y) * i + (w + m) * s + a; const A = (x + y) * n + (w + m) * r + h; const C = c + y; const M = d + m; b > -y && T > -m && b < C && T < M && S > -y && A > -m && S < C && A < M && f.push(v); } else f.push(v); } return f; },
    fadeIn(t, e, i, n, s, r) { return this.fadeEffect.start(!1, t, e, i, n, !0, s, r); },
    fadeOut(t, e, i, n, s, r) { return this.fadeEffect.start(!0, t, e, i, n, !0, s, r); },
    fadeFrom(t, e, i, n, s, r, o) { return this.fadeEffect.start(!1, t, e, i, n, s, r, o); },
    fade(t, e, i, n, s, r, o) { return this.fadeEffect.start(!0, t, e, i, n, s, r, o); },
    flash(t, e, i, n, s, r, o) { return this.flashEffect.start(t, e, i, n, s, r, o); },
    shake(t, e, i, n, s) { return this.shakeEffect.start(t, e, i, n, s); },
    getWorldPoint(t, e, i) { void 0 === i && (i = new d()); const n = this.matrix.matrix; const s = n[0]; const r = n[1]; const o = n[2]; const a = n[3]; const h = n[4]; const l = n[5]; let u = s * a - r * o; if (!u) return i.x = t, i.y = e, i; const c = a * (u = 1 / u); const f = -r * u; const p = -o * u; const g = s * u; const v = (o * l - a * h) * u; const y = (r * h - s * l) * u; const m = Math.cos(this.rotation); const x = Math.sin(this.rotation); const w = this.zoom; const b = this.scrollX; const T = this.scrollY; const S = t + (b * m - T * x) * w; const A = e + (b * x + T * m) * w; return i.x = S * c + A * p + v, i.y = S * f + A * g + y, i; },
    ignore(t) { const e = this._id; if (Array.isArray(t)) for (let i = 0; i < t.length; i++)t[i].cameraFilter |= e; else t.cameraFilter |= e; return this; },
    preRender(t, e) { const i = this.width; const n = this.height; const s = this.zoom * t; const r = this.matrix; const o = i / 2; const a = n / 2; const l = this._follow; if (l && (this.scrollX = h(this.scrollX, l.x - this.followOffset.x - o, this.lerp.x) / s, this.scrollY = h(this.scrollY, l.y - this.followOffset.y - a, this.lerp.y) / s), this.useBounds) { const u = this._bounds; const c = Math.max(0, u.right - i); const d = Math.max(0, u.bottom - n); this.scrollX < u.x ? this.scrollX = u.x : this.scrollX > c && (this.scrollX = c), this.scrollY < u.y ? this.scrollY = u.y : this.scrollY > d && (this.scrollY = d); } this.roundPixels && (this.scrollX = Math.round(this.scrollX), this.scrollY = Math.round(this.scrollY)), r.loadIdentity(), r.scale(e, e), r.translate(this.x + o, this.y + a), r.rotate(this.rotation), r.scale(s, s), r.translate(-o, -a), this.shakeEffect.preRender(); },
    removeBounds() { return this.useBounds = !1, this._bounds.setEmpty(), this; },
    setAngle(t) { return void 0 === t && (t = 0), this.rotation = r(t), this; },
    setLerp(t, e) { return void 0 === t && (t = 1), void 0 === e && (e = t), this.lerp.set(t, e), this; },
    setFollowOffset(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = 0), this.followOffset.set(t, e), this; },
    setBackgroundColor(t) { return void 0 === t && (t = 'rgba(0,0,0,0)'), this.backgroundColor = c(t), this.transparent = this.backgroundColor.alpha === 0, this; },
    setBounds(t, e, i, n) { return this._bounds.setTo(t, e, i, n), this.useBounds = !0, this; },
    setName(t) { return void 0 === t && (t = ''), this.name = t, this; },
    setPosition(t, e) { return void 0 === e && (e = t), this.x = t, this.y = e, this; },
    setRotation(t) { return void 0 === t && (t = 0), this.rotation = t, this; },
    setRoundPixels(t) { return this.roundPixels = t, this; },
    setScene(t) { return this.scene = t, this; },
    setScroll(t, e) { return void 0 === e && (e = t), this.scrollX = t, this.scrollY = e, this; },
    setSize(t, e) { return void 0 === e && (e = t), this.width = t, this.height = e, this; },
    setViewport(t, e, i, n) { return this.x = t, this.y = e, this.width = i, this.height = n, this; },
    setZoom(t) { return void 0 === t && (t = 1), this.zoom = t, this; },
    startFollow(t, e, i, s, r, o) { void 0 === e && (e = !1), void 0 === i && (i = 1), void 0 === s && (s = i), void 0 === r && (r = 0), void 0 === o && (o = r), this._follow = t, this.roundPixels = e, i = n(i, 0, 1), s = n(s, 0, 1), this.lerp.set(i, s), this.followOffset.set(r, o); const a = this.zoom; const h = this.width / 2; const l = this.height / 2; return this.scrollX = (t.x - r - h) / a, this.scrollY = (t.y - o - l) / a, this; },
    stopFollow() { return this._follow = null, this; },
    toJSON() {
      const t = {
        name: this.name, x: this.x, y: this.y, width: this.width, height: this.height, zoom: this.zoom, rotation: this.rotation, roundPixels: this.roundPixels, scrollX: this.scrollX, scrollY: this.scrollY, backgroundColor: this.backgroundColor.rgba,
      }; return this.useBounds && (t.bounds = {
        x: this._bounds.x, y: this._bounds.y, width: this._bounds.width, height: this._bounds.height,
      }), t;
    },
    resetFX() { return this.shakeEffect.reset(), this.flashEffect.reset(), this.fadeEffect.reset(), this; },
    update(t, e) { this.shakeEffect.update(t, e), this.flashEffect.update(t, e), this.fadeEffect.update(t, e); },
    destroy() { this.emit('cameradestroy', this), this.removeAllListeners(), this.resetFX(), this.matrix.destroy(), this.culledObjects = [], this._follow = null, this._bounds = null, this.scene = null; },
  }); t.exports = f;
}, function (t, e, i) {
  const n = new (i(0))({
    initialize(t) { if (this.entries = {}, this.size = 0, Array.isArray(t)) for (let e = 0; e < t.length; e++) this.set(t[e][0], t[e][1]); }, set(t, e) { return this.has(t) || (this.entries[t] = e, this.size++), this; }, get(t) { if (this.has(t)) return this.entries[t]; }, getArray() { const t = []; const e = this.entries; for (const i in e)t.push(e[i]); return t; }, has(t) { return this.entries.hasOwnProperty(t); }, delete(t) { return this.has(t) && (delete this.entries[t], this.size--), this; }, clear() { return Object.keys(this.entries).forEach(function (t) { delete this.entries[t]; }, this), this.size = 0, this; }, keys() { return Object.keys(this.entries); }, values() { const t = []; const e = this.entries; for (const i in e)t.push(e[i]); return t; }, dump() { const t = this.entries; for (const e in console.group('Map'), t)console.log(e, t[e]); console.groupEnd(); }, each(t) { const e = this.entries; for (const i in e) if (!1 === t(i, e[i])) break; return this; }, contains(t) { const e = this.entries; for (const i in e) if (e[i] === t) return !0; return !1; }, merge(t, e) { void 0 === e && (e = !1); const i = this.entries; const n = t.entries; for (const s in n)i.hasOwnProperty(s) && e ? i[s] = n[s] : this.set(s, n[s]); return this; },
  }); t.exports = n;
}, function (t, e) { const i = {}; t.exports = i, i.create = function (t, e) { return { x: t || 0, y: e || 0 }; }, i.clone = function (t) { return { x: t.x, y: t.y }; }, i.magnitude = function (t) { return Math.sqrt(t.x * t.x + t.y * t.y); }, i.magnitudeSquared = function (t) { return t.x * t.x + t.y * t.y; }, i.rotate = function (t, e, i) { const n = Math.cos(e); const s = Math.sin(e); i || (i = {}); const r = t.x * n - t.y * s; return i.y = t.x * s + t.y * n, i.x = r, i; }, i.rotateAbout = function (t, e, i, n) { const s = Math.cos(e); const r = Math.sin(e); n || (n = {}); const o = i.x + ((t.x - i.x) * s - (t.y - i.y) * r); return n.y = i.y + ((t.x - i.x) * r + (t.y - i.y) * s), n.x = o, n; }, i.normalise = function (t) { const e = i.magnitude(t); return e === 0 ? { x: 0, y: 0 } : { x: t.x / e, y: t.y / e }; }, i.dot = function (t, e) { return t.x * e.x + t.y * e.y; }, i.cross = function (t, e) { return t.x * e.y - t.y * e.x; }, i.cross3 = function (t, e, i) { return (e.x - t.x) * (i.y - t.y) - (e.y - t.y) * (i.x - t.x); }, i.add = function (t, e, i) { return i || (i = {}), i.x = t.x + e.x, i.y = t.y + e.y, i; }, i.sub = function (t, e, i) { return i || (i = {}), i.x = t.x - e.x, i.y = t.y - e.y, i; }, i.mult = function (t, e) { return { x: t.x * e, y: t.y * e }; }, i.div = function (t, e) { return { x: t.x / e, y: t.y / e }; }, i.perp = function (t, e) { return { x: (e = !0 === e ? -1 : 1) * -t.y, y: e * t.x }; }, i.neg = function (t) { return { x: -t.x, y: -t.y }; }, i.angle = function (t, e) { return Math.atan2(e.y - t.y, e.x - t.x); }, i._temp = [i.create(), i.create(), i.create(), i.create(), i.create(), i.create()]; }, function (t, e, i) { const n = i(10); t.exports = function (t, e) { const i = n(e, 'anims', null); if (i === null) return t; if (typeof i === 'string')t.anims.play(i); else if (typeof i === 'object') { const s = t.anims; const r = n(i, 'key', void 0); const o = n(i, 'startFrame', void 0); const a = n(i, 'delay', 0); const h = n(i, 'repeat', 0); const l = n(i, 'repeatDelay', 0); const u = n(i, 'yoyo', !1); const c = n(i, 'play', !1); const d = n(i, 'delayedPlay', 0); s.delay(a), s.repeat(h), s.repeatDelay(l), s.yoyo(u), c ? s.play(r, o) : d > 0 ? s.delayedPlay(d, r, o) : s.load(r); } return t; }; }, function (t, e, i) {
  const n = i(0); const s = i(18); var r = new n({
    initialize(t, e, i, n, s, r, o) {
      this.texture = t, this.name = e, this.source = t.source[i], this.sourceIndex = i, this.cutX, this.cutY, this.cutWidth, this.cutHeight, this.x = 0, this.y = 0, this.width, this.height, this.halfWidth, this.halfHeight, this.centerX, this.centerY, this.pivotX = 0, this.pivotY = 0, this.customPivot = !1, this.rotated = !1, this.autoRound = -1, this.customData = {}, this.data = {
        cut: {
          x: 0, y: 0, w: 0, h: 0, r: 0, b: 0,
        },
        trim: !1,
        sourceSize: { w: 0, h: 0 },
        spriteSourceSize: {
          x: 0, y: 0, w: 0, h: 0,
        },
        uvs: {
          x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0,
        },
        radius: 0,
        drawImage: {
          sx: 0, sy: 0, sWidth: 0, sHeight: 0, dWidth: 0, dHeight: 0,
        },
      }, this.setSize(r, o, n, s);
    },
    setSize(t, e, i, n) { void 0 === i && (i = 0), void 0 === n && (n = 0), this.cutX = i, this.cutY = n, this.cutWidth = t, this.cutHeight = e, this.width = t, this.height = e, this.halfWidth = Math.floor(0.5 * t), this.halfHeight = Math.floor(0.5 * e), this.centerX = Math.floor(t / 2), this.centerY = Math.floor(e / 2); const s = this.data; const r = s.cut; r.x = i, r.y = n, r.w = t, r.h = e, r.r = i + t, r.b = n + e, s.sourceSize.w = t, s.sourceSize.h = e, s.spriteSourceSize.w = t, s.spriteSourceSize.h = e, s.radius = 0.5 * Math.sqrt(t * t + e * e); const o = s.drawImage; return o.sx = i, o.sy = n, o.sWidth = t, o.sHeight = e, o.dWidth = t, o.dHeight = e, this.updateUVs(); },
    setTrim(t, e, i, n, s, r) { const o = this.data; const a = o.spriteSourceSize; return o.trim = !0, o.sourceSize.w = t, o.sourceSize.h = e, a.x = i, a.y = n, a.w = s, a.h = r, this.x = i, this.y = n, this.width = s, this.height = r, this.halfWidth = 0.5 * s, this.halfHeight = 0.5 * r, this.centerX = Math.floor(s / 2), this.centerY = Math.floor(r / 2), this.updateUVs(); },
    updateUVs() { const t = this.cutX; const e = this.cutY; const i = this.cutWidth; const n = this.cutHeight; const s = this.data.drawImage; s.sWidth = i, s.sHeight = n, s.dWidth = i, s.dHeight = n; const r = this.source.width; const o = this.source.height; const a = this.data.uvs; return a.x0 = t / r, a.y0 = e / o, a.x1 = t / r, a.y1 = (e + n) / o, a.x2 = (t + i) / r, a.y2 = (e + n) / o, a.x3 = (t + i) / r, a.y3 = e / o, this; },
    updateUVsInverted() { const t = this.source.width; const e = this.source.height; const i = this.data.uvs; return i.x3 = (this.cutX + this.cutHeight) / t, i.y3 = (this.cutY + this.cutWidth) / e, i.x2 = this.cutX / t, i.y2 = (this.cutY + this.cutWidth) / e, i.x1 = this.cutX / t, i.y1 = this.cutY / e, i.x0 = (this.cutX + this.cutHeight) / t, i.y0 = this.cutY / e, this; },
    clone() { const t = new r(this.texture, this.name, this.sourceIndex); return t.cutX = this.cutX, t.cutY = this.cutY, t.cutWidth = this.cutWidth, t.cutHeight = this.cutHeight, t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t.halfWidth = this.halfWidth, t.halfHeight = this.halfHeight, t.centerX = this.centerX, t.centerY = this.centerY, t.rotated = this.rotated, t.data = s(!0, t.data, this.data), t.updateUVs(), t; },
    destroy() { this.texture = null, this.source = null; },
    realWidth: { get() { return this.data.sourceSize.w; } },
    realHeight: { get() { return this.data.sourceSize.h; } },
    uvs: { get() { return this.data.uvs; } },
    radius: { get() { return this.data.radius; } },
    trimmed: { get() { return this.data.trim; } },
    canvasData: { get() { return this.data.drawImage; } },
  }); t.exports = r;
}, function (t, e, i) {
  const n = i(0); const s = i(200); const r = i(519); const o = i(518); const a = i(27); const h = i(83); const l = new n({
    Extends: h,
    Mixins: [s],
    initialize(t) {
      h.call(this, {
        game: t.game,
        renderer: t.renderer,
        gl: t.renderer.gl,
        topology: t.topology ? t.topology : t.renderer.gl.TRIANGLES,
        vertShader: t.vertShader ? t.vertShader : o,
        fragShader: t.fragShader ? t.fragShader : r,
        vertexCapacity: t.vertexCapacity ? t.vertexCapacity : 12e3,
        vertexSize: t.vertexSize ? t.vertexSize : 2 * Float32Array.BYTES_PER_ELEMENT + 2 * Float32Array.BYTES_PER_ELEMENT + 4 * Uint8Array.BYTES_PER_ELEMENT,
        attributes: [{
          name: 'inPosition', size: 2, type: t.renderer.gl.FLOAT, normalized: !1, offset: 0,
        }, {
          name: 'inTexCoord', size: 2, type: t.renderer.gl.FLOAT, normalized: !1, offset: 2 * Float32Array.BYTES_PER_ELEMENT,
        }, {
          name: 'inTint', size: 4, type: t.renderer.gl.UNSIGNED_BYTE, normalized: !0, offset: 4 * Float32Array.BYTES_PER_ELEMENT,
        }],
      }), this.vertexViewF32 = new Float32Array(this.vertexData), this.vertexViewU32 = new Uint32Array(this.vertexData), this.maxQuads = 2e3, this.batches = [], this.mvpInit();
    },
    setTexture2D(t, e) { if (!t) return this; const i = this.batches; i.length === 0 && this.pushBatch(); const n = i[i.length - 1]; return e > 0 ? (n.textures[e - 1] && n.textures[e - 1] !== t && this.pushBatch(), i[i.length - 1].textures[e - 1] = t) : (n.texture !== null && n.texture !== t && this.pushBatch(), i[i.length - 1].texture = t), this; },
    pushBatch() { const t = { first: this.vertexCount, texture: null, textures: [] }; this.batches.push(t); },
    flush() { if (this.flushLocked) return this; this.flushLocked = !0; let t; let e; let i; const n = this.gl; const s = this.renderer; const r = this.vertexCount; const o = this.topology; const a = this.vertexSize; const h = this.batches; let l = 0; let u = null; if (h.length === 0 || r === 0) return this.flushLocked = !1, this; n.bufferSubData(n.ARRAY_BUFFER, 0, this.bytes.subarray(0, r * a)); for (let c = 0; c < h.length - 1; ++c) { if (u = h[c], t = h[c + 1], u.textures.length > 0) { for (e = 0; e < u.textures.length; ++e)(i = u.textures[e]) && s.setTexture2D(i, 1 + e); n.activeTexture(n.TEXTURE0); }l = t.first - u.first, u.texture === null || l <= 0 || (s.setTexture2D(u.texture, 0), n.drawArrays(o, u.first, l)); } if ((u = h[h.length - 1]).textures.length > 0) { for (e = 0; e < u.textures.length; ++e)(i = u.textures[e]) && s.setTexture2D(i, 1 + e); n.activeTexture(n.TEXTURE0); } return l = r - u.first, u.texture && l > 0 && (s.setTexture2D(u.texture, 0), n.drawArrays(o, u.first, l)), this.vertexCount = 0, h.length = 0, this.pushBatch(), this.flushLocked = !1, this; },
    onBind() { return h.prototype.onBind.call(this), this.mvpUpdate(), this.batches.length === 0 && this.pushBatch(), this; },
    resize(t, e, i) { return h.prototype.resize.call(this, t, e, i), this.projOrtho(0, this.width, this.height, 0, -1e3, 1e3), this; },
    drawStaticTilemapLayer(t) { if (t.vertexCount > 0) { const e = this.vertexBuffer; const i = this.gl; const n = this.renderer; const s = t.tileset.image.get(); n.currentPipeline && n.currentPipeline.vertexCount > 0 && n.flush(), this.vertexBuffer = t.vertexBuffer, n.setPipeline(this), n.setTexture2D(s.source.glTexture, 0), i.drawArrays(this.topology, 0, t.vertexCount), this.vertexBuffer = e; } this.viewIdentity(), this.modelIdentity(); },
    drawEmitterManager(t, e, i) { let n = null; i && (n = i.matrix), this.renderer.setPipeline(this); let s; let r; let o; let a; let h; let l; let u; let c; let d; let f; const p = this.renderer.config.roundPixels; const g = t.emitters.list; const v = g.length; const y = this.vertexViewF32; const m = this.vertexViewU32; const x = this.renderer; const w = this.maxQuads; const b = e.scrollX; const T = e.scrollY; const S = e.matrix.matrix; let A = S[0]; let C = S[1]; let M = S[2]; let _ = S[3]; let E = S[4]; let P = S[5]; const L = Math.sin; const F = Math.cos; const k = this.vertexComponentCount; const R = this.vertexCapacity; const O = t.defaultFrame.source.glTexture; n && (h = n[0], l = n[1], u = n[2], c = n[3], d = n[4], f = n[5]), this.setTexture2D(O, 0); for (let B = 0; B < v; ++B) { const D = g[B]; const I = D.alive; let z = I.length; const Y = Math.ceil(z / w); let X = 0; let N = b * D.scrollFactorX; let V = T * D.scrollFactorY; if (n) { const W = -N; const G = -V; s = u * A + c * M, r = u * C + c * _, o = d * A + f * M + (W * A + G * M + E), a = d * C + f * _ + (W * C + G * _ + P), A = h * A + l * M, C = h * C + l * _, M = s, _ = r, E = o, P = a, N = 0, V = 0; } if (D.visible && z !== 0) { x.setBlendMode(D.blendMode), this.vertexCount >= R && (this.flush(), this.setTexture2D(O, 0)); for (let U = 0; U < Y; ++U) { for (var H = Math.min(z, w), j = 0; j < H; ++j) { const q = I[X + j]; if (!(q.alpha <= 0)) { const K = q.frame; const J = K.uvs; const Z = -K.halfWidth; const Q = -K.halfHeight; const $ = q.color; const tt = Z + K.width; const et = Q + K.height; const it = L(q.rotation); const nt = F(q.rotation); const st = nt * q.scaleX; const rt = it * q.scaleX; const ot = -it * q.scaleY; const at = nt * q.scaleY; const ht = q.x - N; const lt = q.y - V; const ut = st * A + rt * M; const ct = st * C + rt * _; const dt = ot * A + at * M; const ft = ot * C + at * _; const pt = ht * A + lt * M + E; const gt = ht * C + lt * _ + P; let vt = Z * ut + Q * dt + pt; let yt = Z * ct + Q * ft + gt; let mt = Z * ut + et * dt + pt; let xt = Z * ct + et * ft + gt; let wt = tt * ut + et * dt + pt; let bt = tt * ct + et * ft + gt; let Tt = tt * ut + Q * dt + pt; let St = tt * ct + Q * ft + gt; const At = this.vertexCount * k; p && (vt |= 0, yt |= 0, mt |= 0, xt |= 0, wt |= 0, bt |= 0, Tt |= 0, St |= 0), y[At + 0] = vt, y[At + 1] = yt, y[At + 2] = J.x0, y[At + 3] = J.y0, m[At + 4] = $, y[At + 5] = mt, y[At + 6] = xt, y[At + 7] = J.x1, y[At + 8] = J.y1, m[At + 9] = $, y[At + 10] = wt, y[At + 11] = bt, y[At + 12] = J.x2, y[At + 13] = J.y2, m[At + 14] = $, y[At + 15] = vt, y[At + 16] = yt, y[At + 17] = J.x0, y[At + 18] = J.y0, m[At + 19] = $, y[At + 20] = wt, y[At + 21] = bt, y[At + 22] = J.x2, y[At + 23] = J.y2, m[At + 24] = $, y[At + 25] = Tt, y[At + 26] = St, y[At + 27] = J.x3, y[At + 28] = J.y3, m[At + 29] = $, this.vertexCount += 6, this.vertexCount >= R && (this.flush(), this.setTexture2D(O, 0)); } }X += H, z -= H, this.vertexCount >= R && (this.flush(), this.setTexture2D(O, 0)); } } } this.setTexture2D(O, 0); },
    drawBlitter(t, e, i) { let n = null; i && (n = i.matrix), this.renderer.setPipeline(this); const s = this.renderer.config.roundPixels; const r = a.getTintAppendFloatAlpha; const o = this.vertexViewF32; const h = this.vertexViewU32; const l = t.getRenderList(); let u = l.length; const c = e.matrix.matrix; let d = c[0]; let f = c[1]; let p = c[2]; let g = c[3]; let v = c[4]; let y = c[5]; let m = e.scrollX * t.scrollFactorX; let x = e.scrollY * t.scrollFactorY; const w = Math.ceil(u / this.maxQuads); let b = 0; if (n) { const T = n[0]; const S = n[1]; const A = n[2]; const C = n[3]; const M = n[4]; const _ = n[5]; const E = -m; const P = -x; const L = A * d + C * p; const F = A * f + C * g; const k = M * d + _ * p + (E * d + P * p + v); const R = M * f + _ * g + (E * f + P * g + y); d = T * d + S * p, f = T * f + S * g, p = L, g = F, v = k, y = R, m = 0, x = 0; } for (var O, B = t.x - m, D = t.y - x, I = 0; I < w; ++I) { for (var z = Math.min(u, this.maxQuads), Y = 0; Y < z; ++Y) { const X = l[b + Y]; const N = X.frame; const V = X.alpha; if (V !== 0) { const W = r(16777215, V); const G = N.uvs; const U = X.flipX; const H = X.flipY; const j = N.width * (U ? -1 : 1); const q = N.height * (H ? -1 : 1); const K = B + X.x + N.x + N.width * (U ? 1 : 0); const J = D + X.y + N.y + N.height * (H ? 1 : 0); const Z = K + j; const Q = J + q; let $ = K * d + J * p + v; let tt = K * f + J * g + y; let et = Z * d + Q * p + v; let it = Z * f + Q * g + y; N.sourceIndex !== O && (this.setTexture2D(N.texture.source[N.sourceIndex].glTexture, 0), O = N.sourceIndex); const nt = this.vertexCount * this.vertexComponentCount; s && ($ |= 0, tt |= 0, et |= 0, it |= 0), o[nt + 0] = $, o[nt + 1] = tt, o[nt + 2] = G.x0, o[nt + 3] = G.y0, h[nt + 4] = W, o[nt + 5] = $, o[nt + 6] = it, o[nt + 7] = G.x1, o[nt + 8] = G.y1, h[nt + 9] = W, o[nt + 10] = et, o[nt + 11] = it, o[nt + 12] = G.x2, o[nt + 13] = G.y2, h[nt + 14] = W, o[nt + 15] = $, o[nt + 16] = tt, o[nt + 17] = G.x0, o[nt + 18] = G.y0, h[nt + 19] = W, o[nt + 20] = et, o[nt + 21] = it, o[nt + 22] = G.x2, o[nt + 23] = G.y2, h[nt + 24] = W, o[nt + 25] = et, o[nt + 26] = tt, o[nt + 27] = G.x3, o[nt + 28] = G.y3, h[nt + 29] = W, this.vertexCount += 6, this.vertexCount >= this.vertexCapacity && (this.flush(), O = -1); } }b += z, u -= z, this.vertexCount >= this.vertexCapacity && this.flush(); } },
    batchSprite(t, e, i) { let n = null; i && (n = i.matrix), this.renderer.setPipeline(this), this.vertexCount + 6 > this.vertexCapacity && this.flush(); let s; let r; let o; let h; let l; let u; const c = this.renderer.config.roundPixels; const d = a.getTintAppendFloatAlpha; const f = this.vertexViewF32; const p = this.vertexViewU32; const g = e.matrix.matrix; const v = t.frame; const y = v.texture.source[v.sourceIndex].glTexture; const m = !!y.isRenderTexture; const x = t.flipX; const w = t.flipY ^ m; const b = v.uvs; const T = v.width * (x ? -1 : 1); const S = v.height * (w ? -1 : 1); const A = -t.displayOriginX + v.x + v.width * (x ? 1 : 0); const C = -t.displayOriginY + v.y + v.height * (w ? 1 : 0); const M = (c ? 0 | A : A) + T; const _ = (c ? 0 | C : C) + S; const E = t.scaleX; const P = t.scaleY; const L = t.rotation; const F = t._alphaTL; const k = t._alphaTR; const R = t._alphaBL; const O = t._alphaBR; const B = t._tintTL; const D = t._tintTR; const I = t._tintBL; const z = t._tintBR; const Y = Math.sin(L); const X = Math.cos(L); const N = X * E; const V = Y * E; const W = -Y * P; const G = X * P; let U = t.x; let H = t.y; const j = g[0]; const q = g[1]; const K = g[2]; const J = g[3]; const Z = g[4]; const Q = g[5]; if (n) { const $ = n[0]; const tt = n[1]; const et = n[2]; const it = n[3]; const nt = n[4]; const st = n[5]; const rt = -e.scrollX * t.scrollFactorX; const ot = -e.scrollY * t.scrollFactorY; const at = $ * j + tt * K; const ht = $ * q + tt * J; const lt = et * j + it * K; const ut = et * q + it * J; s = N * at + V * lt, r = N * ht + V * ut, o = W * at + G * lt, h = W * ht + G * ut, l = U * at + H * lt + (nt * j + st * K + (rt * j + ot * K + Z)), u = U * ht + H * ut + (nt * q + st * J + (rt * q + ot * J + Q)); } else s = N * j + V * K, r = N * q + V * J, o = W * j + G * K, h = W * q + G * J, l = (U -= e.scrollX * t.scrollFactorX) * j + (H -= e.scrollY * t.scrollFactorY) * K + Z, u = U * q + H * J + Q; let ct; let dt = A * s + C * o + l; let ft = A * r + C * h + u; let pt = A * s + _ * o + l; let gt = A * r + _ * h + u; let vt = M * s + _ * o + l; let yt = M * r + _ * h + u; let mt = M * s + C * o + l; let xt = M * r + C * h + u; const wt = d(B, F); const bt = d(D, k); const Tt = d(I, R); const St = d(z, O); c && (dt |= 0, ft |= 0, pt |= 0, gt |= 0, vt |= 0, yt |= 0, mt |= 0, xt |= 0), this.setTexture2D(y, 0), f[(ct = this.vertexCount * this.vertexComponentCount) + 0] = dt, f[ct + 1] = ft, f[ct + 2] = b.x0, f[ct + 3] = b.y0, p[ct + 4] = wt, f[ct + 5] = pt, f[ct + 6] = gt, f[ct + 7] = b.x1, f[ct + 8] = b.y1, p[ct + 9] = Tt, f[ct + 10] = vt, f[ct + 11] = yt, f[ct + 12] = b.x2, f[ct + 13] = b.y2, p[ct + 14] = St, f[ct + 15] = dt, f[ct + 16] = ft, f[ct + 17] = b.x0, f[ct + 18] = b.y0, p[ct + 19] = wt, f[ct + 20] = vt, f[ct + 21] = yt, f[ct + 22] = b.x2, f[ct + 23] = b.y2, p[ct + 24] = St, f[ct + 25] = mt, f[ct + 26] = xt, f[ct + 27] = b.x3, f[ct + 28] = b.y3, p[ct + 29] = bt, this.vertexCount += 6; },
    batchMesh(t, e, i) { let n = null; i && (n = i.matrix); const s = t.vertices; const r = s.length; const o = r / 2 | 0; this.renderer.setPipeline(this), this.vertexCount + o > this.vertexCapacity && this.flush(); let h; let l; let u; let c; let d; let f; const p = this.renderer.config.roundPixels; const g = a.getTintAppendFloatAlpha; const v = t.uv; const y = t.colors; const m = t.alphas; const x = this.vertexViewF32; const w = this.vertexViewU32; const b = e.matrix.matrix; const T = t.frame; const S = t.texture.source[T.sourceIndex].glTexture; const A = t.x; const C = t.y; const M = t.scaleX; const _ = t.scaleY; const E = t.rotation; const P = Math.sin(E); const L = Math.cos(E); const F = L * M; const k = P * M; const R = -P * _; const O = L * _; let B = A; let D = C; const I = b[0]; const z = b[1]; const Y = b[2]; const X = b[3]; const N = b[4]; const V = b[5]; let W = 0; if (n) { const G = n[0]; const U = n[1]; const H = n[2]; const j = n[3]; const q = n[4]; const K = n[5]; const J = -e.scrollX * t.scrollFactorX; const Z = -e.scrollY * t.scrollFactorY; const Q = G * I + U * Y; const $ = G * z + U * X; const tt = H * I + j * Y; const et = H * z + j * X; h = F * Q + k * tt, l = F * $ + k * et, u = R * Q + O * tt, c = R * $ + O * et, d = B * Q + D * tt + (q * I + K * Y + (J * I + Z * Y + N)), f = B * $ + D * et + (q * z + K * X + (J * z + Z * X + V)); } else h = F * I + k * Y, l = F * z + k * X, u = R * I + O * Y, c = R * z + O * X, d = (B -= e.scrollX * t.scrollFactorX) * I + (D -= e.scrollY * t.scrollFactorY) * Y + N, f = B * z + D * X + V; this.setTexture2D(S, 0), W = this.vertexCount * this.vertexComponentCount; for (let it = 0, nt = 0; it < r; it += 2) { const st = s[it + 0]; const rt = s[it + 1]; let ot = st * h + rt * u + d; let at = st * l + rt * c + f; p && (ot |= 0, at |= 0), x[W + 0] = ot, x[W + 1] = at, x[W + 2] = v[it + 0], x[W + 3] = v[it + 1], w[W + 4] = g(y[nt], m[nt]), W += 5, nt += 1; } this.vertexCount += o; },
    batchBitmapText(t, e, i) { let n = null; i && (n = i.matrix), this.renderer.setPipeline(this), this.vertexCount + 6 > this.vertexCapacity && this.flush(); let s; let r; let o; let h; let l; let u; let c; let d; let f; let p; let g; let v; let y; let m; const x = this.renderer.config.roundPixels; const w = t.text; const b = w.length; const T = a.getTintAppendFloatAlpha; const S = this.vertexViewF32; const A = this.vertexViewU32; const C = e.matrix.matrix; const M = e.width + 50; const _ = e.height + 50; const E = t.frame; const P = t.texture.source[E.sourceIndex]; const L = e.scrollX * t.scrollFactorX; const F = e.scrollY * t.scrollFactorY; const k = t.fontData; const R = k.lineHeight; const O = t.fontSize / k.size; const B = k.chars; const D = t.alpha; const I = T(t._tintTL, D); const z = T(t._tintTR, D); const Y = T(t._tintBL, D); const X = T(t._tintBR, D); const N = t.x; const V = t.y; const W = E.cutX; const G = E.cutY; const U = P.width; const H = P.height; const j = P.glTexture; let q = 0; let K = 0; let J = 0; let Z = 0; let Q = null; let $ = 0; let tt = 0; let et = 0; let it = 0; let nt = 0; let st = 0; let rt = 0; let ot = 0; let at = 0; let ht = 0; let lt = 0; let ut = 0; let ct = null; let dt = 0; const ft = N + E.x; const pt = V + E.y; const gt = t.rotation; const vt = t.scaleX; const yt = t.scaleY; const mt = t.letterSpacing; const xt = Math.sin(gt); const wt = Math.cos(gt); const bt = wt * vt; const Tt = xt * vt; const St = -xt * yt; const At = wt * yt; let Ct = ft; let Mt = pt; const _t = C[0]; const Et = C[1]; const Pt = C[2]; const Lt = C[3]; const Ft = C[4]; const kt = C[5]; let Rt = 0; if (n) { const Ot = n[0]; const Bt = n[1]; const Dt = n[2]; const It = n[3]; const zt = n[4]; const Yt = n[5]; const Xt = -L; const Nt = -F; const Vt = Ot * _t + Bt * Pt; const Wt = Ot * Et + Bt * Lt; const Gt = Dt * _t + It * Pt; const Ut = Dt * Et + It * Lt; f = bt * Vt + Tt * Gt, p = bt * Wt + Tt * Ut, g = St * Vt + At * Gt, v = St * Wt + At * Ut, y = Ct * Vt + Mt * Gt + (zt * _t + Yt * Pt + (Xt * _t + Nt * Pt + Ft)), m = Ct * Wt + Mt * Ut + (zt * Et + Yt * Lt + (Xt * Et + Nt * Lt + kt)); } else f = bt * _t + Tt * Pt, p = bt * Et + Tt * Lt, g = St * _t + At * Pt, v = St * Et + At * Lt, y = (Ct -= L) * _t + (Mt -= F) * Pt + Ft, m = Ct * Et + Mt * Lt + kt; this.setTexture2D(j, 0); for (let Ht = 0; Ht < b; ++Ht) if ((Z = w.charCodeAt(Ht)) !== 10) { if (Q = B[Z]) { if ($ = W + Q.x, tt = G + Q.y, et = Q.width, it = Q.height, nt = (J + Q.xOffset + q) * O, st = (Q.yOffset + K) * O, ct !== null) { const jt = Q.kerning[dt]; nt += void 0 !== jt ? jt : 0; }q += Q.xAdvance + mt, J += 1, ct = Q, dt = Z, et !== 0 && it !== 0 && Z !== 32 && (r = (nt -= t.displayOriginX) * p + (st -= t.displayOriginY) * v + m, o = nt * f + (ot = st + it * O) * g + y, h = nt * p + ot * v + m, l = (rt = nt + et * O) * f + ot * g + y, u = rt * p + ot * v + m, c = rt * f + st * g + y, d = rt * p + st * v + m, at = $ / U, ht = ($ + et) / U, lt = tt / H, ut = (tt + it) / H, ((s = nt * f + st * g + y) < -50 || s > M || r < -50 || r > _) && (o < -50 || o > M || h < -50 || h > _) && (l < -50 || l > M || u < -50 || u > _) && (c < -50 || c > M || d < -50 || d > _) || (this.vertexCount + 6 > this.vertexCapacity && this.flush(), Rt = this.vertexCount * this.vertexComponentCount, x && (s |= 0, r |= 0, o |= 0, h |= 0, l |= 0, u |= 0, c |= 0, d |= 0), S[Rt + 0] = s, S[Rt + 1] = r, S[Rt + 2] = at, S[Rt + 3] = lt, A[Rt + 4] = I, S[Rt + 5] = o, S[Rt + 6] = h, S[Rt + 7] = at, S[Rt + 8] = ut, A[Rt + 9] = Y, S[Rt + 10] = l, S[Rt + 11] = u, S[Rt + 12] = ht, S[Rt + 13] = ut, A[Rt + 14] = X, S[Rt + 15] = s, S[Rt + 16] = r, S[Rt + 17] = at, S[Rt + 18] = lt, A[Rt + 19] = I, S[Rt + 20] = l, S[Rt + 21] = u, S[Rt + 22] = ht, S[Rt + 23] = ut, A[Rt + 24] = X, S[Rt + 25] = c, S[Rt + 26] = d, S[Rt + 27] = ht, S[Rt + 28] = lt, A[Rt + 29] = z, this.vertexCount += 6)); } } else q = 0, J = 0, K += R, ct = null; },
    batchDynamicBitmapText(t, e, i) {
      let n = null; i && (n = i.matrix), this.renderer.setPipeline(this), this.vertexCount + 6 > this.vertexCapacity && this.flush(); let s; let r; let o; let h; let l; let u; let c; let d; let f; let p; let g; let v; let y; let m; let x; let w; let b; let T; let S; let A; const C = this.renderer.config.roundPixels; const M = t.displayCallback; const _ = t.text; const E = _.length; const P = a.getTintAppendFloatAlpha; const L = this.vertexViewF32; const F = this.vertexViewU32; const k = this.renderer; const R = e.matrix.matrix; const O = t.frame; const B = t.texture.source[O.sourceIndex]; const D = e.scrollX * t.scrollFactorX; const I = e.scrollY * t.scrollFactorY; const z = t.scrollX; const Y = t.scrollY; const X = t.fontData; const N = X.lineHeight; let V = t.fontSize / X.size; const W = X.chars; const G = t.alpha; let U = P(t._tintTL, G); let H = P(t._tintTR, G); let j = P(t._tintBL, G); let q = P(t._tintBR, G); const K = t.x; const J = t.y; const Z = O.cutX; const Q = O.cutY; const $ = B.width; const tt = B.height; const et = B.glTexture; let it = 0; let nt = 0; let st = 0; let rt = 0; let ot = null; let at = 0; let ht = 0; let lt = 0; let ut = 0; let ct = 0; let dt = 0; let ft = 0; let pt = 0; let gt = 0; let vt = 0; let yt = 0; let mt = 0; let xt = null; let wt = 0; const bt = K + O.x; const Tt = J + O.y; let St = t.rotation; const At = t.scaleX; const Ct = t.scaleY; const Mt = t.letterSpacing; let _t = Math.sin(St); let Et = Math.cos(St); let Pt = Et * At; let Lt = _t * At; let Ft = -_t * Ct; let kt = Et * Ct; let Rt = bt; let Ot = Tt; const Bt = R[0]; const Dt = R[1]; const It = R[2]; const zt = R[3]; const Yt = R[4]; const Xt = R[5]; const Nt = t.cropWidth > 0 || t.cropHeight > 0; let Vt = 0; if (n) { const Wt = n[0]; const Gt = n[1]; const Ut = n[2]; const Ht = n[3]; const jt = n[4]; const qt = n[5]; const Kt = -D; const Jt = -I; const Zt = Wt * Bt + Gt * It; const Qt = Wt * Dt + Gt * zt; const $t = Ut * Bt + Ht * It; const te = Ut * Dt + Ht * zt; x = Pt * Zt + Lt * $t, w = Pt * Qt + Lt * te, b = Ft * Zt + kt * $t, T = Ft * Qt + kt * te, S = Rt * Zt + Ot * $t + (jt * Bt + qt * It + (Kt * Bt + Jt * It + Yt)), A = Rt * Qt + Ot * te + (jt * Dt + qt * zt + (Kt * Dt + Jt * zt + Xt)); } else x = Pt * Bt + Lt * It, w = Pt * Dt + Lt * zt, b = Ft * Bt + kt * It, T = Ft * Dt + kt * zt, S = (Rt -= D) * Bt + (Ot -= I) * It + Yt, A = Rt * Dt + Ot * zt + Xt; this.setTexture2D(et, 0), Nt && k.pushScissor(t.x, t.y, t.cropWidth * t.scaleX, t.cropHeight * t.scaleY); for (let ee = 0; ee < E; ++ee) {
        if (V = t.fontSize / t.fontData.size, St = 0, (rt = _.charCodeAt(ee)) !== 10) {
          if (ot = W[rt]) {
            if (at = Z + ot.x, ht = Q + ot.y, lt = ot.width, ut = ot.height, ct = st + ot.xOffset + it - z, dt = ot.yOffset + nt - Y, xt !== null) { const ie = ot.kerning[wt]; ct += void 0 !== ie ? ie : 0; } if (it += ot.xAdvance + Mt, st += 1, xt = ot, wt = rt, lt !== 0 && ut !== 0 && rt !== 32) {
              if (M) {
                const ne = M({
                  color: 0,
                  tint: {
                    topLeft: U, topRight: H, bottomLeft: j, bottomRight: q,
                  },
                  index: ee,
                  charCode: rt,
                  x: ct,
                  y: dt,
                  scale: V,
                  rotation: 0,
                  data: ot.data,
                }); ct = ne.x, dt = ne.y, V = ne.scale, St = ne.rotation, ne.color ? (U = ne.color, H = ne.color, j = ne.color, q = ne.color) : (U = ne.tint.topLeft, H = ne.tint.topRight, j = ne.tint.bottomLeft, q = ne.tint.bottomRight), U = P(U, G), H = P(H, G), j = P(j, G), q = P(q, G);
              }ct -= t.displayOriginX, dt -= t.displayOriginY, ct *= V, dt *= V, _t = Math.sin(St), Et = Math.cos(St), s = Rt = (y = ct) * x + (m = dt) * b + S, r = Ot = y * w + m * T + A, o = (pt = ut) * (Ft = (g = -_t * V) * x + (v = Et * V) * b) + Rt, h = pt * (kt = g * w + v * T) + Ot, l = (ft = lt) * (Pt = (f = Et * V) * x + (p = _t * V) * b) + pt * Ft + Rt, u = ft * (Lt = f * w + p * T) + pt * kt + Ot, c = ft * Pt + Rt, d = ft * Lt + Ot, gt = at / $, vt = (at + lt) / $, yt = ht / tt, mt = (ht + ut) / tt, this.vertexCount + 6 > this.vertexCapacity && this.flush(), Vt = this.vertexCount * this.vertexComponentCount, C && (s |= 0, r |= 0, o |= 0, h |= 0, l |= 0, u |= 0, c |= 0, d |= 0), L[Vt + 0] = s, L[Vt + 1] = r, L[Vt + 2] = gt, L[Vt + 3] = yt, F[Vt + 4] = U, L[Vt + 5] = o, L[Vt + 6] = h, L[Vt + 7] = gt, L[Vt + 8] = mt, F[Vt + 9] = j, L[Vt + 10] = l, L[Vt + 11] = u, L[Vt + 12] = vt, L[Vt + 13] = mt, F[Vt + 14] = q, L[Vt + 15] = s, L[Vt + 16] = r, L[Vt + 17] = gt, L[Vt + 18] = yt, F[Vt + 19] = U, L[Vt + 20] = l, L[Vt + 21] = u, L[Vt + 22] = vt, L[Vt + 23] = mt, F[Vt + 24] = q, L[Vt + 25] = c, L[Vt + 26] = d, L[Vt + 27] = vt, L[Vt + 28] = yt, F[Vt + 29] = H, this.vertexCount += 6;
            }
          }
        } else it = 0, st = 0, nt += N, xt = null;
      } Nt && k.popScissor();
    },
    batchText(t, e, i) { const n = a.getTintAppendFloatAlpha; this.batchTexture(t, t.canvasTexture, t.canvasTexture.width, t.canvasTexture.height, t.x, t.y, t.canvasTexture.width, t.canvasTexture.height, t.scaleX, t.scaleY, t.rotation, t.flipX, t.flipY, t.scrollFactorX, t.scrollFactorY, t.displayOriginX, t.displayOriginY, 0, 0, t.canvasTexture.width, t.canvasTexture.height, n(t._tintTL, t._alphaTL), n(t._tintTR, t._alphaTR), n(t._tintBL, t._alphaBL), n(t._tintBR, t._alphaBR), 0, 0, e, i); },
    batchDynamicTilemapLayer(t, e, i) { for (let n = t.culledTiles, s = n.length, r = t.tileset.image.get().source.glTexture, o = t.tileset, h = t.scrollFactorX, l = t.scrollFactorY, u = t.alpha, c = t.x, d = t.y, f = t.scaleX, p = t.scaleY, g = a.getTintAppendFloatAlpha, v = 0; v < s; ++v) { const y = n[v]; const m = o.getTileTextureCoordinates(y.index); if (m !== null) { const x = y.width; const w = y.height; const b = m.x; const T = m.y; const S = g(y.tint, u * y.alpha); this.batchTexture(t, r, r.width, r.height, y.width / 2 + c + y.pixelX * f, y.height / 2 + d + y.pixelY * p, y.width * f, y.height * p, 1, 1, y.rotation, y.flipX, y.flipY, h, l, y.width / 2, y.height / 2, b, T, x, w, S, S, S, S, 0, 0, e, i); } } },
    batchTileSprite(t, e, i) { const n = a.getTintAppendFloatAlpha; this.batchTexture(t, t.tileTexture, t.frame.width, t.frame.height, t.x, t.y, t.width, t.height, t.scaleX, t.scaleY, t.rotation, t.flipX, t.flipY, t.scrollFactorX, t.scrollFactorY, t.originX * t.width, t.originY * t.height, 0, 0, t.width, t.height, n(t._tintTL, t._alphaTL), n(t._tintTR, t._alphaTR), n(t._tintBL, t._alphaBL), n(t._tintBR, t._alphaBR), t.tilePositionX % t.frame.width / t.frame.width, t.tilePositionY % t.frame.height / t.frame.height, e, i); },
    batchTexture(t, e, i, n, s, r, o, a, h, l, u, c, d, f, p, g, v, y, m, x, w, b, T, S, A, C, M, _, E) { let P = null; E && (P = E.matrix), this.renderer.setPipeline(this), this.vertexCount + 6 > this.vertexCapacity && this.flush(), d ^= e.isRenderTexture ? 1 : 0; let L; let F; let k; let R; let O; let B; const D = this.renderer.config.roundPixels; const I = this.vertexViewF32; const z = this.vertexViewU32; const Y = _.matrix.matrix; const X = o * (c ? 1 : 0) - g; const N = a * (d ? 1 : 0) - v; const V = X + o * (c ? -1 : 1); const W = N + a * (d ? -1 : 1); const G = s; const U = r; const H = Math.sin(u); const j = Math.cos(u); const q = j * h; const K = H * h; const J = -H * l; const Z = j * l; let Q = G; let $ = U; const tt = Y[0]; const et = Y[1]; const it = Y[2]; const nt = Y[3]; const st = Y[4]; const rt = Y[5]; if (P) { const ot = P[0]; const at = P[1]; const ht = P[2]; const lt = P[3]; const ut = P[4]; const ct = P[5]; const dt = -_.scrollX * f; const ft = -_.scrollY * p; const pt = ot * tt + at * it; const gt = ot * et + at * nt; const vt = ht * tt + lt * it; const yt = ht * et + lt * nt; L = q * pt + K * vt, F = q * gt + K * yt, k = J * pt + Z * vt, R = J * gt + Z * yt, O = Q * pt + $ * vt + (ut * tt + ct * it + (dt * tt + ft * it + st)), B = Q * gt + $ * yt + (ut * et + ct * nt + (dt * et + ft * nt + rt)); } else L = q * tt + K * it, F = q * et + K * nt, k = J * tt + Z * it, R = J * et + Z * nt, O = (Q -= _.scrollX * f) * tt + ($ -= _.scrollY * p) * it + st, B = Q * et + $ * nt + rt; let mt; let xt = X * L + N * k + O; let wt = X * F + N * R + B; let bt = X * L + W * k + O; let Tt = X * F + W * R + B; let St = V * L + W * k + O; let At = V * F + W * R + B; let Ct = V * L + N * k + O; let Mt = V * F + N * R + B; const _t = y / i + C; const Et = m / n + M; const Pt = (y + x) / i + C; const Lt = (m + w) / n + M; this.setTexture2D(e, 0), mt = this.vertexCount * this.vertexComponentCount, D && (xt |= 0, wt |= 0, bt |= 0, Tt |= 0, St |= 0, At |= 0, Ct |= 0, Mt |= 0), I[mt + 0] = xt, I[mt + 1] = wt, I[mt + 2] = _t, I[mt + 3] = Et, z[mt + 4] = b, I[mt + 5] = bt, I[mt + 6] = Tt, I[mt + 7] = _t, I[mt + 8] = Lt, z[mt + 9] = T, I[mt + 10] = St, I[mt + 11] = At, I[mt + 12] = Pt, I[mt + 13] = Lt, z[mt + 14] = S, I[mt + 15] = xt, I[mt + 16] = wt, I[mt + 17] = _t, I[mt + 18] = Et, z[mt + 19] = b, I[mt + 20] = St, I[mt + 21] = At, I[mt + 22] = Pt, I[mt + 23] = Lt, z[mt + 24] = S, I[mt + 25] = Ct, I[mt + 26] = Mt, I[mt + 27] = Pt, I[mt + 28] = Et, z[mt + 29] = A, this.vertexCount += 6; },
    drawTexture(t, e, i, n, s, r, o, h, l, u, c) { let d = null; c && (d = c.matrix), this.renderer.setPipeline(this), this.vertexCount + 6 > this.vertexCapacity && this.flush(); const f = this.renderer.config.roundPixels; const p = this.vertexViewF32; const g = this.vertexViewU32; const v = e; const y = i; const m = v + h; const x = y + l; let w = u[0]; let b = u[1]; let T = u[2]; let S = u[3]; let A = u[4]; let C = u[5]; if (d) { const M = d[0]; const _ = d[1]; const E = d[2]; const P = d[3]; const L = d[4]; const F = w * _ + b * P; const k = T * _ + S * P; const R = A * _ + C * P + d[5]; w = w * M + b * E, b = F, T = T * M + S * E, S = k, A = A * M + C * E + L, C = R; } let O; let B = v * w + y * T + A; let D = v * b + y * S + C; let I = v * w + x * T + A; let z = v * b + x * S + C; let Y = m * w + x * T + A; let X = m * b + x * S + C; let N = m * w + y * T + A; let V = m * b + y * S + C; const W = t.width; const G = t.height; const U = r / W; const H = o / G; const j = (r + h) / W; const q = (o + l) / G; n = a.getTintAppendFloatAlpha(n, s), this.setTexture2D(t, 0), O = this.vertexCount * this.vertexComponentCount, f && (B |= 0, D |= 0, I |= 0, z |= 0, Y |= 0, X |= 0, N |= 0, V |= 0), p[O + 0] = B, p[O + 1] = D, p[O + 2] = U, p[O + 3] = H, g[O + 4] = n, p[O + 5] = I, p[O + 6] = z, p[O + 7] = U, p[O + 8] = q, g[O + 9] = n, p[O + 10] = Y, p[O + 11] = X, p[O + 12] = j, p[O + 13] = q, g[O + 14] = n, p[O + 15] = B, p[O + 16] = D, p[O + 17] = U, p[O + 18] = H, g[O + 19] = n, p[O + 20] = Y, p[O + 21] = X, p[O + 22] = j, p[O + 23] = q, g[O + 24] = n, p[O + 25] = N, p[O + 26] = V, p[O + 27] = j, p[O + 28] = H, g[O + 29] = n, this.vertexCount += 6, this.flush(); },
    batchGraphics() {},
  }); t.exports = l;
}, function (t, e) { t.exports = function (t, e, i) { let n; return void 0 === i && (i = !0), e && (typeof e === 'string' ? n = document.getElementById(e) : typeof e === 'object' && e.nodeType === 1 && (n = e)), n || (n = document.body), i && n.style && (n.style.overflow = 'hidden'), n.appendChild(t), t; }; }, function (t, e) {
  let i; let n = ''; t.exports = {
    disable(t) { return n === '' && (n = i(t)), n && (t[n] = !1), t; }, enable(t) { return n === '' && (n = i(t)), n && (t[n] = !0), t; }, getPrefix: i = function (t) { for (let e = ['i', 'webkitI', 'msI', 'mozI', 'oI'], i = 0; i < e.length; i++) { const n = `${e[i]}mageSmoothingEnabled`; if (n in t) return n; } return null; }, isEnabled(t) { return n !== null ? t[n] : null; },
  };
}, function (t, e, i) { const n = i(285); const s = i(283); const r = i(281); const o = i(280); t.exports = function (t) { switch (typeof t) { case 'string': return t.substr(0, 3).toLowerCase() === 'rgb' ? o(t) : n(t); case 'number': return s(t); case 'object': return r(t); } }; }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === e && (e = 0), void 0 === i && (i = ' '), void 0 === n && (n = 3); let s = 0; if (e + 1 >= (t = t.toString()).length) switch (n) { case 1: t = new Array(e + 1 - t.length).join(i) + t; break; case 3: var r = Math.ceil((s = e - t.length) / 2); t = new Array(s - r + 1).join(i) + t + new Array(r + 1).join(i); break; default: t += new Array(e + 1 - t.length).join(i); } return t; }; }, function (t, e, i) { const n = i(5); t.exports = function (t, e) { void 0 === e && (e = new n()); const i = Math.random() * Math.PI * 2; const s = Math.sqrt(Math.random()); return e.x = t.x + s * Math.cos(i) * t.width / 2, e.y = t.y + s * Math.sin(i) * t.height / 2, e; }; }, function (t, e, i) { const n = i(96); const s = i(5); t.exports = function (t, e, i) { if (void 0 === i && (i = new s()), e <= 0 || e >= 1) return i.x = t.x, i.y = t.y, i; let r = n(t) * e; return e > 0.5 ? (r -= t.width + t.height) <= t.width ? (i.x = t.right - r, i.y = t.bottom) : (i.x = t.x, i.y = t.bottom - (r - t.width)) : r <= t.width ? (i.x = t.x + r, i.y = t.y) : (i.x = t.right, i.y = t.y + (r - t.width)), i; }; }, function (t, e, i) { const n = i(5); t.exports = function (t, e, i) { return void 0 === i && (i = new n()), i.x = t.x + t.radius * Math.cos(e), i.y = t.y + t.radius * Math.sin(e), i; }; }, function (t, e, i) {
  const n = new (i(0))({
    initialize(t, e, i, n, s, r, o, a) { (void 0 === i || i <= 0) && (i = 32), (void 0 === n || n <= 0) && (n = 32), void 0 === s && (s = 0), void 0 === r && (r = 0), void 0 === o && (o = {}), void 0 === a && (a = {}), this.name = t, this.firstgid = e, this.tileWidth = i, this.tileHeight = n, this.tileMargin = s, this.tileSpacing = r, this.tileProperties = o, this.tileData = a, this.image = null, this.rows = 0, this.columns = 0, this.total = 0, this.texCoordinates = []; }, getTileProperties(t) { return this.containsTileIndex(t) ? this.tileProperties[t - this.firstgid] : null; }, getTileData(t) { return this.containsTileIndex(t) ? this.tileData[t - this.firstgid] : null; }, getTileCollisionGroup(t) { const e = this.getTileData(t); return e && e.objectgroup ? e.objectgroup : null; }, containsTileIndex(t) { return t >= this.firstgid && t < this.firstgid + this.total; }, getTileTextureCoordinates(t) { return this.containsTileIndex(t) ? this.texCoordinates[t - this.firstgid] : null; }, setImage(t) { return this.image = t, this.updateTileData(this.image.source[0].width, this.image.source[0].height), this; }, setTileSize(t, e) { return void 0 !== t && (this.tileWidth = t), void 0 !== e && (this.tileHeight = e), this.image && this.updateTileData(this.image.source[0].width, this.image.source[0].height), this; }, setSpacing(t, e) { return void 0 !== t && (this.tileMargin = t), void 0 !== e && (this.tileSpacing = e), this.image && this.updateTileData(this.image.source[0].width, this.image.source[0].height), this; }, updateTileData(t, e) { let i = (e - 2 * this.tileMargin + this.tileSpacing) / (this.tileHeight + this.tileSpacing); let n = (t - 2 * this.tileMargin + this.tileSpacing) / (this.tileWidth + this.tileSpacing); i % 1 == 0 && n % 1 == 0 || console.warn(`Tileset ${this.name} image tile area is not an even multiple of tile size`), i = Math.floor(i), n = Math.floor(n), this.rows = i, this.columns = n, this.total = i * n, this.texCoordinates.length = 0; for (let s = this.tileMargin, r = this.tileMargin, o = 0; o < this.rows; o++) { for (let a = 0; a < this.columns; a++) this.texCoordinates.push({ x: s, y: r }), s += this.tileWidth + this.tileSpacing; s = this.tileMargin, r += this.tileHeight + this.tileSpacing; } return this; },
  }); t.exports = n;
}, function (t, e) { t.exports = function (t, e, i) { let n = i.baseTileHeight; const s = i.tilemapLayer; let r = 0; return s && (void 0 === e && (e = s.scene.cameras.main), r = s.y + e.scrollY * (1 - s.scrollFactorY), n *= s.scaleY), r + t * n; }; }, function (t, e) { t.exports = function (t, e, i) { let n = i.baseTileWidth; const s = i.tilemapLayer; let r = 0; return s && (void 0 === e && (e = s.scene.cameras.main), r = s.x + e.scrollX * (1 - s.scrollFactorX), n *= s.scaleX), r + t * n; }; }, function (t, e, i) { const n = i(104); t.exports = function (t, e, i, s) { if (void 0 === i && (i = !1), n(t, e, s)) { const r = s.data[e][t]; return r === null ? null : r.index === -1 ? i ? r : null : r; } return null; }; }, function (t, e, i) {
  t.exports = {
    CalculateFacesAt: i(218), CalculateFacesWithin: i(40), Copy: i(662), CreateFromTiles: i(661), CullTiles: i(660), Fill: i(659), FilterTiles: i(658), FindByIndex: i(657), FindTile: i(656), ForEachTile: i(655), GetTileAt: i(137), GetTileAtWorldXY: i(654), GetTilesWithin: i(21), GetTilesWithinShape: i(653), GetTilesWithinWorldXY: i(652), HasTileAt: i(321), HasTileAtWorldXY: i(651), IsInLayerBounds: i(104), PutTileAt: i(217), PutTileAtWorldXY: i(650), PutTilesAt: i(649), Randomize: i(648), RemoveTileAt: i(320), RemoveTileAtWorldXY: i(647), RenderDebug: i(646), ReplaceByIndex: i(322), SetCollision: i(645), SetCollisionBetween: i(644), SetCollisionByExclusion: i(643), SetCollisionByProperty: i(642), SetCollisionFromCollisionGroup: i(641), SetTileIndexCallback: i(640), SetTileLocationCallback: i(639), Shuffle: i(638), SwapByIndex: i(637), TileToWorldX: i(136), TileToWorldXY: i(636), TileToWorldY: i(135), WeightedRandomize: i(635), WorldToTileX: i(52), WorldToTileXY: i(634), WorldToTileY: i(51),
  };
}, function (t, e) { const i = {}; t.exports = i, i.create = function (t) { const e = { min: { x: 0, y: 0 }, max: { x: 0, y: 0 } }; return t && i.update(e, t), e; }, i.update = function (t, e, i) { t.min.x = 1 / 0, t.max.x = -1 / 0, t.min.y = 1 / 0, t.max.y = -1 / 0; for (let n = 0; n < e.length; n++) { const s = e[n]; s.x > t.max.x && (t.max.x = s.x), s.x < t.min.x && (t.min.x = s.x), s.y > t.max.y && (t.max.y = s.y), s.y < t.min.y && (t.min.y = s.y); }i && (i.x > 0 ? t.max.x += i.x : t.min.x += i.x, i.y > 0 ? t.max.y += i.y : t.min.y += i.y); }, i.contains = function (t, e) { return e.x >= t.min.x && e.x <= t.max.x && e.y >= t.min.y && e.y <= t.max.y; }, i.overlaps = function (t, e) { return t.min.x <= e.max.x && t.max.x >= e.min.x && t.max.y >= e.min.y && t.min.y <= e.max.y; }, i.translate = function (t, e) { t.min.x += e.x, t.max.x += e.x, t.min.y += e.y, t.max.y += e.y; }, i.shift = function (t, e) { const i = t.max.x - t.min.x; const n = t.max.y - t.min.y; t.min.x = e.x, t.max.x = e.x + i, t.min.y = e.y, t.max.y = e.y + n; }; }, function (t, e, i) {
  const n = {}; t.exports = n; const s = i(123); const r = i(49); n.create = function (t, e) {
    for (var i = [], n = 0; n < t.length; n++) {
      const s = t[n]; const r = {
        x: s.x, y: s.y, index: n, body: e, isInternal: !1, contact: null,
      }; r.contact = { vertex: r, normalImpulse: 0, tangentImpulse: 0 }, i.push(r);
    } return i;
  }, n.fromPath = function (t, e) { const i = []; return t.replace(/L?\s*([\-\d\.e]+)[\s,]*([\-\d\.e]+)*/gi, (t, e, n) => { i.push({ x: parseFloat(e), y: parseFloat(n) }); }), n.create(i, e); }, n.centre = function (t) { for (var e, i, r, o = n.area(t, !0), a = { x: 0, y: 0 }, h = 0; h < t.length; h++)r = (h + 1) % t.length, e = s.cross(t[h], t[r]), i = s.mult(s.add(t[h], t[r]), e), a = s.add(a, i); return s.div(a, 6 * o); }, n.mean = function (t) { for (var e = { x: 0, y: 0 }, i = 0; i < t.length; i++)e.x += t[i].x, e.y += t[i].y; return s.div(e, t.length); }, n.area = function (t, e) { for (var i = 0, n = t.length - 1, s = 0; s < t.length; s++)i += (t[n].x - t[s].x) * (t[n].y + t[s].y), n = s; return e ? i / 2 : Math.abs(i) / 2; }, n.inertia = function (t, e) { for (var i, n, r = 0, o = 0, a = t, h = 0; h < a.length; h++)n = (h + 1) % a.length, r += (i = Math.abs(s.cross(a[n], a[h]))) * (s.dot(a[n], a[n]) + s.dot(a[n], a[h]) + s.dot(a[h], a[h])), o += i; return e / 6 * (r / o); }, n.translate = function (t, e, i) { let n; if (i) for (n = 0; n < t.length; n++)t[n].x += e.x * i, t[n].y += e.y * i; else for (n = 0; n < t.length; n++)t[n].x += e.x, t[n].y += e.y; return t; }, n.rotate = function (t, e, i) { if (e !== 0) { for (let n = Math.cos(e), s = Math.sin(e), r = 0; r < t.length; r++) { const o = t[r]; const a = o.x - i.x; const h = o.y - i.y; o.x = i.x + (a * n - h * s), o.y = i.y + (a * s + h * n); } return t; } }, n.contains = function (t, e) { for (let i = 0; i < t.length; i++) { const n = t[i]; const s = t[(i + 1) % t.length]; if ((e.x - n.x) * (s.y - n.y) + (e.y - n.y) * (n.x - s.x) > 0) return !1; } return !0; }, n.scale = function (t, e, i, r) { if (e === 1 && i === 1) return t; let o; let a; r = r || n.centre(t); for (let h = 0; h < t.length; h++)o = t[h], a = s.sub(o, r), t[h].x = r.x + a.x * e, t[h].y = r.y + a.y * i; return t; }, n.chamfer = function (t, e, i, n, o) { (e = typeof e === 'number' ? [e] : e || [8]).length || (e = [e]), i = void 0 !== i ? i : -1, n = n || 2, o = o || 14; for (var a = [], h = 0; h < t.length; h++) { const l = t[h - 1 >= 0 ? h - 1 : t.length - 1]; const u = t[h]; const c = t[(h + 1) % t.length]; const d = e[h < e.length ? h : e.length - 1]; if (d !== 0) { const f = s.normalise({ x: u.y - l.y, y: l.x - u.x }); const p = s.normalise({ x: c.y - u.y, y: u.x - c.x }); const g = Math.sqrt(2 * Math.pow(d, 2)); const v = s.mult(r.clone(f), d); const y = s.normalise(s.mult(s.add(f, p), 0.5)); const m = s.sub(u, s.mult(y, g)); let x = i; i === -1 && (x = 1.75 * Math.pow(d, 0.32)), (x = r.clamp(x, n, o)) % 2 == 1 && (x += 1); for (let w = Math.acos(s.dot(f, p)) / x, b = 0; b < x; b++)a.push(s.add(s.rotate(v, w * b), m)); } else a.push(u); } return a; }, n.clockwiseSort = function (t) { const e = n.mean(t); return t.sort((t, i) => s.angle(e, t) - s.angle(e, i)), t; }, n.isConvex = function (t) { let e; let i; let n; let s; let r = 0; const o = t.length; if (o < 3) return null; for (e = 0; e < o; e++) if (n = (e + 2) % o, s = (t[i = (e + 1) % o].x - t[e].x) * (t[n].y - t[i].y), (s -= (t[i].y - t[e].y) * (t[n].x - t[i].x)) < 0 ? r |= 1 : s > 0 && (r |= 2), r === 3) return !1; return r !== 0 || null; }, n.hull = function (t) { let e; let i; const n = []; const r = []; for ((t = t.slice(0)).sort((t, e) => { const i = t.x - e.x; return i !== 0 ? i : t.y - e.y; }), i = 0; i < t.length; i += 1) { for (e = t[i]; r.length >= 2 && s.cross3(r[r.length - 2], r[r.length - 1], e) <= 0;)r.pop(); r.push(e); } for (i = t.length - 1; i >= 0; i -= 1) { for (e = t[i]; n.length >= 2 && s.cross3(n[n.length - 2], n[n.length - 1], e) <= 0;)n.pop(); n.push(e); } return n.pop(), r.pop(), n.concat(r); };
}, function (t, e, i) { const n = i(0); const s = i(343); const r = i(34); const o = new n({ Extends: r, Mixins: [s.Acceleration, s.Angular, s.Bounce, s.Debug, s.Drag, s.Enable, s.Friction, s.Gravity, s.Immovable, s.Mass, s.Size, s.Velocity], initialize(t, e, i, n, s) { r.call(this, t, e, i, n, s), this.body = null; } }); t.exports = o; }, function (t, e, i) {
  const n = i(0); const s = i(17); const r = i(19); const o = i(6); const a = i(1); const h = i(8); const l = i(269); const u = new n({
    Extends: r,
    initialize(t, e, i, n) {
      let s = 'xml'; if (h(e)) { const o = e; e = a(o, 'key'), i = a(o, 'url'), n = a(o, 'xhrSettings'), s = a(o, 'extension', s); } const l = {
        type: 'xml', cache: t.cacheManager.xml, extension: s, responseType: 'text', key: e, url: i, xhrSettings: n,
      }; r.call(this, t, l);
    },
    onProcess() { this.state = s.FILE_PROCESSING, this.data = l(this.xhrLoader.responseText), this.data ? this.onProcessComplete() : (console.warn(`Invalid XMLFile: ${this.key}`), this.onProcessError()); },
  }); o.register('xml', function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new u(this, t[n])); else this.addFile(new u(this, t, e, i)); return this; }), t.exports = u;
}, function (t, e, i) { const n = i(5); t.exports = function (t, e, i) { void 0 === i && (i = new n()); const s = t.x1; const r = t.y1; const o = t.x2; const a = t.y2; const h = e.x1; const l = e.y1; const u = e.x2; const c = e.y2; const d = (u - h) * (r - l) - (c - l) * (s - h); const f = (o - s) * (r - l) - (a - r) * (s - h); const p = (c - l) * (o - s) - (u - h) * (a - r); if (p === 0) return !1; const g = d / p; const v = f / p; return g >= 0 && g <= 1 && v >= 0 && v <= 1 && (i.x = s + g * (o - s), i.y = r + g * (a - r), !0); }; }, function (t, e, i) { const n = i(0); const s = i(15); const r = i(2); const o = i(860); const a = new n({ Extends: r, Mixins: [s.Alpha, s.BlendMode, s.Depth, s.Flip, s.GetBounds, s.Mask, s.Origin, s.Pipeline, s.ScaleMode, s.Size, s.Texture, s.Transform, s.Visible, s.ScrollFactor, o], initialize(t, e, i, n, s, o, a, h, l) { if (r.call(this, t, 'Mesh'), this.setTexture(h, l), this.setPosition(e, i), this.setSizeToFrame(), this.setOrigin(), this.initPipeline('TextureTintPipeline'), n.length !== s.length) throw new Error('Mesh Vertex count must match UV count'); let u; const c = n.length / 2 | 0; if (o.length > 0 && o.length < c) throw new Error('Mesh Color count must match Vertex count'); if (a.length > 0 && a.length < c) throw new Error('Mesh Alpha count must match Vertex count'); if (o.length === 0) for (u = 0; u < c; ++u)o[u] = 16777215; if (a.length === 0) for (u = 0; u < c; ++u)a[u] = 1; this.vertices = new Float32Array(n), this.uv = new Float32Array(s), this.colors = new Uint32Array(o), this.alphas = new Float32Array(a); } }); t.exports = a; }, function (t, e) { t.exports = function (t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = t.length); const n = e + Math.floor(Math.random() * i); return void 0 === t[n] ? null : t[n]; }; }, function (t, e, i) {
  t.exports = {
    Matrix: i(490), Add: i(483), AddAt: i(482), BringToTop: i(481), CountAllMatching: i(480), Each: i(479), EachInRange: i(478), FindClosestInSorted: i(207), GetAll: i(477), GetFirst: i(476), GetRandom: i(145), MoveDown: i(475), MoveTo: i(474), MoveUp: i(473), NumberArray: i(472), NumberArrayStep: i(471), QuickSelect: i(172), Range: i(253), Remove: i(187), RemoveAt: i(470), RemoveBetween: i(469), RemoveRandomElement: i(468), Replace: i(467), RotateLeft: i(290), RotateRight: i(289), SafeRange: i(29), SendToBack: i(466), SetAll: i(465), Shuffle: i(94), SpliceOne: i(55), StableSort: i(82), Swap: i(464),
  };
}, function (t, e, i) {
  const n = i(0); const s = i(520); const r = i(126); const o = new n({
    Extends: r, initialize(t) { t.fragShader = s.replace('%LIGHT_COUNT%', 10.0.toString()), r.call(this, t); }, onBind() { r.prototype.onBind.call(this); const t = this.renderer; const e = this.program; return this.mvpUpdate(), t.setInt1(e, 'uNormSampler', 1), t.setFloat2(e, 'uResolution', this.width, this.height), this; }, onRender(t, e) { const i = t.sys.lights; if (!i) return this; if (i.culledLights.length = 0, i.lights.length <= 0 || !i.active) return this; let n; const s = this.renderer; const r = this.program; const o = i.cull(e); const a = Math.min(o.length, 10); const h = e.matrix; const l = { x: 0, y: 0 }; const u = s.height; for (n = 0; n < 10; ++n)s.setFloat1(r, `uLights[${n}].radius`, 0); if (a <= 0) return this; for (s.setFloat4(r, 'uCamera', e.x, e.y, e.rotation, e.zoom), s.setFloat3(r, 'uAmbientLightColor', i.ambientColor.r, i.ambientColor.g, i.ambientColor.b), n = 0; n < a; ++n) { const c = o[n]; const d = `uLights[${n}].`; h.transformPoint(c.x, c.y, l), s.setFloat2(r, `${d}position`, l.x - e.scrollX * c.scrollFactorX * e.zoom, u - (l.y - e.scrollY * c.scrollFactorY * e.zoom)), s.setFloat3(r, `${d}color`, c.r, c.g, c.b), s.setFloat1(r, `${d}intensity`, c.intensity), s.setFloat1(r, `${d}radius`, c.radius); } return this; }, drawStaticTilemapLayer(t, e, i) { const n = t.tileset.image.dataSource[0]; n ? (this.renderer.setPipeline(this), this.setTexture2D(n.glTexture, 1), r.prototype.drawStaticTilemapLayer.call(this, t, e, i)) : (console.warn('Normal map texture missing for using Light2D pipeline. StaticTilemapLayer rendered with default pipeline.'), this.renderer.pipelines.TextureTintPipeline.drawStaticTilemapLayer(t, e, i)); }, drawEmitterManager(t, e, i) { const n = t.texture.dataSource[t.frame.sourceIndex]; n ? (this.renderer.setPipeline(this), this.setTexture2D(n.glTexture, 1), r.prototype.drawEmitterManager.call(this, t, e, i)) : (console.warn('Normal map texture missing for using Light2D pipeline. EmitterManager rendered with default pipeline.'), this.renderer.pipelines.TextureTintPipeline.drawEmitterManager(t, e, i)); }, drawBlitter(t, e, i) { const n = t.texture.dataSource[t.frame.sourceIndex]; n ? (this.renderer.setPipeline(this), this.setTexture2D(n.glTexture, 1), r.prototype.drawBlitter.call(this, t, e, i)) : (console.warn('Normal map texture missing for using Light2D pipeline. Blitter rendered with default pipeline.'), this.renderer.pipelines.TextureTintPipeline.drawBlitter(t, e, i)); }, batchSprite(t, e, i) { const n = t.texture.dataSource[t.frame.sourceIndex]; n ? (this.renderer.setPipeline(this), this.setTexture2D(n.glTexture, 1), r.prototype.batchSprite.call(this, t, e, i)) : (console.warn('Normal map texture missing for using Light2D pipeline. Sprite rendered with default pipeline.'), this.renderer.pipelines.TextureTintPipeline.batchSprite(t, e, i)); }, batchMesh(t, e, i) { const n = t.texture.dataSource[t.frame.sourceIndex]; n ? (this.renderer.setPipeline(this), this.setTexture2D(n.glTexture, 1), r.prototype.batchMesh.call(this, t, e, i)) : (console.warn('Normal map texture missing for using Light2D pipeline. Mesh rendered with default pipeline.'), this.renderer.pipelines.TextureTintPipeline.batchMesh(t, e, i)); }, batchBitmapText(t, e, i) { const n = t.texture.dataSource[t.frame.sourceIndex]; n ? (this.renderer.setPipeline(this), this.setTexture2D(n.glTexture, 1), r.prototype.batchBitmapText.call(this, t, e, i)) : (console.warn('Normal map texture missing for using Light2D pipeline. BitmapText rendered with default pipeline.'), this.renderer.pipelines.TextureTintPipeline.batchBitmapText(t, e, i)); }, batchDynamicBitmapText(t, e, i) { const n = t.texture.dataSource[t.frame.sourceIndex]; n ? (this.renderer.setPipeline(this), this.setTexture2D(n.glTexture, 1), r.prototype.batchDynamicBitmapText.call(this, t, e, i)) : (console.warn('Normal map texture missing for using Light2D pipeline. DynamicBitmapText rendered with default pipeline.'), this.renderer.pipelines.TextureTintPipeline.batchDynamicBitmapText(t, e, i)); }, batchText(t, e, i) { const n = t.texture.dataSource[t.frame.sourceIndex]; n ? (this.renderer.setPipeline(this), this.setTexture2D(n.glTexture, 1), r.prototype.batchText.call(this, t, e, i)) : (console.warn('Normal map texture missing for using Light2D pipeline. Text rendered with default pipeline.'), this.renderer.pipelines.TextureTintPipeline.batchText(t, e, i)); }, batchDynamicTilemapLayer(t, e, i) { const n = t.tileset.image.dataSource[0]; n ? (this.renderer.setPipeline(this), this.setTexture2D(n.glTexture, 1), r.prototype.batchDynamicTilemapLayer.call(this, t, e, i)) : (console.warn('Normal map texture missing for using Light2D pipeline. DynamicTilemapLayer rendered with default pipeline.'), this.renderer.pipelines.TextureTintPipeline.batchDynamicTilemapLayer(t, e, i)); }, batchTileSprite(t, e, i) { const n = t.texture.dataSource[t.frame.sourceIndex]; n ? (this.renderer.setPipeline(this), this.setTexture2D(n.glTexture, 1), r.prototype.batchTileSprite.call(this, t, e, i)) : (console.warn('Normal map texture missing for using Light2D pipeline. TileSprite rendered with default pipeline.'), this.renderer.pipelines.TextureTintPipeline.batchTileSprite(t, e, i)); },
  }); o.LIGHT_COUNT = 10, t.exports = o;
}, function (t, e, i) { const n = i(16); t.exports = function (t) { return t * n.RAD_TO_DEG; }; }, function (t, e, i) {
  const n = i(0); const s = i(2); const r = i(34); const o = i(7); const a = i(277); const h = new n({
    Extends: s, initialize(t, e, i, n, h, l) { s.call(this, t, 'Sprite3D'), this.gameObject = new r(t, 0, 0, h, l), this.position = new a(e, i, n), this.size = new o(this.gameObject.width, this.gameObject.height), this.scale = new o(1, 1), this.adjustScaleX = !0, this.adjustScaleY = !0, this._visible = !0; }, project(t) { const e = this.position; const i = this.gameObject; t.project(e, i), t.getPointSize(e, this.size, this.scale), this.scale.x <= 0 || this.scale.y <= 0 ? i.setVisible(!1) : (i.visible || i.setVisible(!0), this.adjustScaleX && (i.scaleX = this.scale.x), this.adjustScaleY && (i.scaleY = this.scale.y), i.setDepth(-1 * i.z)); }, setVisible(t) { return this.visible = t, this; }, visible: { get() { return this._visible; }, set(t) { this._visible = t, this.gameObject.visible = t; } }, x: { get() { return this.position.x; }, set(t) { this.position.x = t; } }, y: { get() { return this.position.y; }, set(t) { this.position.y = t; } }, z: { get() { return this.position.z; }, set(t) { this.position.z = t; } },
  }); t.exports = h;
}, function (t, e) { t.exports = function (t, e, i) { return t << 16 | e << 8 | i; }; }, function (t, e, i) { const n = i(5); t.exports = function (t, e) { void 0 === e && (e = new n()); const i = t.x2 - t.x1; const s = t.y2 - t.y1; const r = t.x3 - t.x1; const o = t.y3 - t.y1; let a = Math.random(); let h = Math.random(); return a + h >= 1 && (a = 1 - a, h = 1 - h), e.x = t.x1 + (i * a + r * h), e.y = t.y1 + (s * a + o * h), e; }; }, function (t, e, i) { const n = i(5); t.exports = function (t, e) { return void 0 === e && (e = new n()), e.x = t.x + Math.random() * t.width, e.y = t.y + Math.random() * t.height, e; }; }, function (t, e, i) { const n = i(5); t.exports = function (t, e) { void 0 === e && (e = new n()); const i = Math.random(); return e.x = t.x1 + i * (t.x2 - t.x1), e.y = t.y1 + i * (t.y2 - t.y1), e; }; }, function (t, e, i) { const n = i(71); const s = i(5); t.exports = function (t, e, i, r) { void 0 === r && (r = []), e || (e = n(t) / i); for (let o = t.x1, a = t.y1, h = t.x2, l = t.y2, u = 0; u < e; u++) { const c = u / e; const d = o + (h - o) * c; const f = a + (l - a) * c; r.push(new s(d, f)); } return r; }; }, function (t, e, i) { const n = i(5); t.exports = function (t, e) { void 0 === e && (e = new n()); const i = 2 * Math.PI * Math.random(); const s = Math.random() + Math.random(); const r = s > 1 ? 2 - s : s; const o = r * Math.cos(i); const a = r * Math.sin(i); return e.x = t.x + o * t.radius, e.y = t.y + a * t.radius, e; }; }, function (t, e, i) {
  const n = i(50); const s = i(87); const r = i(32); const o = i(0); const a = i(15); const h = i(2); const l = i(14); const u = i(31); const c = new o({
    Extends: h, Mixins: [a.Depth, a.GetBounds, a.Origin, a.ScaleMode, a.Transform, a.ScrollFactor, a.Visible], initialize(t, e, i, s, r) { void 0 === s && (s = 1), void 0 === r && (r = s), h.call(this, t, 'Zone'), this.setPosition(e, i), this.width = s, this.height = r, this.blendMode = n.NORMAL; }, displayWidth: { get() { return this.scaleX * this.width; }, set(t) { this.scaleX = t / this.width; } }, displayHeight: { get() { return this.scaleY * this.height; }, set(t) { this.scaleY = t / this.height; } }, setSize(t, e, i) { return void 0 === i && (i = !0), this.width = t, this.height = e, i && this.input && this.input.hitArea instanceof l && (this.input.hitArea.width = t, this.input.hitArea.height = e), this; }, setDisplaySize(t, e) { return this.displayWidth = t, this.displayHeight = e, this; }, setCircleDropZone(t) { return this.setDropZone(new s(0, 0, t), r); }, setRectangleDropZone(t, e) { const i = -t / 2; const n = -e / 2; return this.setDropZone(new l(i, n, t, e), u); }, setDropZone(t, e) { return void 0 === t ? this.setRectangleDropZone(this.width, this.height) : this.input || this.setInteractive(t, e, !0), this; }, renderCanvas() {}, renderWebGL() {},
  }); t.exports = c;
}, function (t, e, i) {
  const n = i(0); const s = i(9); const r = i(72); const o = i(60); var a = new n({
    Extends: s,
    initialize(t) {
      s.call(this), this.manager = t, this.isTimeline = !0, this.data = [], this.totalData = 0, this.useFrames = !1, this.timeScale = 1, this.loop = 0, this.loopDelay = 0, this.loopCounter = 0, this.completeDelay = 0, this.countdown = 0, this.state = o.PENDING_ADD, this._pausedState = o.PENDING_ADD, this.paused = !1, this.elapsed = 0, this.totalElapsed = 0, this.duration = 0, this.progress = 0, this.totalDuration = 0, this.totalProgress = 0, this.callbacks = {
        onComplete: null, onLoop: null, onStart: null, onUpdate: null, onYoyo: null,
      }, this.callbackScope;
    },
    setTimeScale(t) { return this.timeScale = t, this; },
    getTimeScale() { return this.timeScale; },
    isPlaying() { return this.state === o.ACTIVE; },
    add(t) { return this.queue(r(this, t)); },
    queue(t) { return this.isPlaying() || (t.parent = this, t.parentIsTimeline = !0, this.data.push(t), this.totalData = this.data.length), this; },
    hasOffset(t) { return t.offset !== null; },
    isOffsetAbsolute(t) { return typeof t === 'number'; },
    isOffsetRelative(t) { if (typeof t === 'string') { const e = t[0]; if (e === '-' || e === '+') return !0; } return !1; },
    getRelativeOffset(t, e) { const i = t[0]; const n = parseFloat(t.substr(2)); let s = e; switch (i) { case '+': s += n; break; case '-': s -= n; } return Math.max(0, s); },
    calcDuration() { for (var t = 0, e = 0, i = 0, n = 0; n < this.totalData; n++) { const s = this.data[n]; s.init(), this.hasOffset(s) ? this.isOffsetAbsolute(s.offset) ? (s.calculatedOffset = s.offset, s.offset === 0 && (i = 0)) : this.isOffsetRelative(s.offset) && (s.calculatedOffset = this.getRelativeOffset(s.offset, t)) : s.calculatedOffset = i, t = s.totalDuration + s.calculatedOffset, e += s.totalDuration, i += s.totalDuration; } this.duration = e, this.loopCounter = this.loop === -1 ? 999999999999 : this.loop, this.loopCounter > 0 ? this.totalDuration = this.duration + this.completeDelay + (this.duration + this.loopDelay) * this.loopCounter : this.totalDuration = this.duration + this.completeDelay; },
    init() { return this.calcDuration(), this.progress = 0, this.totalProgress = 0, !this.paused || (this.state = o.PAUSED, !1); },
    resetTweens(t) { for (let e = 0; e < this.totalData; e++) { this.data[e].play(t); } },
    setCallback(t, e, i, n) { return a.TYPES.indexOf(t) !== -1 && (this.callbacks[t] = { func: e, scope: n, params: i }), this; },
    makeActive(t) { return this.manager.makeActive(t); },
    play() { if (this.state !== o.ACTIVE) { if (this.paused) return this.paused = !1, void this.manager.makeActive(this); this.resetTweens(!1), this.state = o.ACTIVE; const t = this.callbacks.onStart; t && t.func.apply(t.scope, t.params), this.emit('start', this); } },
    nextState() { if (this.loopCounter > 0) { this.elapsed = 0, this.progress = 0, this.loopCounter--; const t = this.callbacks.onLoop; t && t.func.apply(t.scope, t.params), this.emit('loop', this, this.loopCounter), this.resetTweens(!0), this.loopDelay > 0 ? (this.countdown = this.loopDelay, this.state = o.LOOP_DELAY) : this.state = o.ACTIVE; } else if (this.completeDelay > 0) this.countdown = this.completeDelay, this.state = o.COMPLETE_DELAY; else { const e = this.callbacks.onComplete; e && e.func.apply(e.scope, e.params), this.emit('complete', this), this.state = o.PENDING_REMOVE; } },
    update(t, e) { if (this.state !== o.PAUSED) { const i = e; switch (this.useFrames && (e = 1 * this.manager.timeScale), e *= this.timeScale, this.elapsed += e, this.progress = Math.min(this.elapsed / this.duration, 1), this.totalElapsed += e, this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1), this.state) { case o.ACTIVE: for (var n = this.totalData, s = 0; s < this.totalData; s++) { this.data[s].update(t, i) && n--; } var r = this.callbacks.onUpdate; r && r.func.apply(r.scope, r.params), this.emit('update', this), n === 0 && this.nextState(); break; case o.LOOP_DELAY: this.countdown -= e, this.countdown <= 0 && (this.state = o.ACTIVE); break; case o.COMPLETE_DELAY: if (this.countdown -= e, this.countdown <= 0) { const a = this.callbacks.onComplete; a && a.func.apply(a.scope, a.params), this.emit('complete', this), this.state = o.PENDING_REMOVE; } } return this.state === o.PENDING_REMOVE; } },
    stop() { this.state = o.PENDING_REMOVE; },
    pause() { if (this.state !== o.PAUSED) return this.paused = !0, this._pausedState = this.state, this.state = o.PAUSED, this.emit('pause', this), this; },
    resume() { return this.state === o.PAUSED && (this.paused = !1, this.state = this._pausedState), this.emit('resume', this), this; },
    hasTarget(t) { for (let e = 0; e < this.data.length; e++) if (this.data[e].hasTarget(t)) return !0; return !1; },
    destroy() { for (let t = 0; t < this.data.length; t++) this.data[t].stop(); },
  }); a.TYPES = ['onStart', 'onUpdate', 'onLoop', 'onComplete', 'onYoyo'], t.exports = a;
}, function (t, e, i) { const n = i(33); const s = i(99); const r = i(10); const o = i(61); const a = i(62); const h = i(73); const l = i(101); const u = i(160); const c = i(4); const d = i(157); const f = i(72); t.exports = function (t, e) { const i = new d(t); const p = u(e); if (p.length === 0) return i.paused = !0, i; const g = n(s); g.targets = l(e); const v = r(e, 'totalDuration', 0); g.duration = v > 0 ? Math.floor(v / p.length) : h(e, 'duration', g.duration), g.delay = h(e, 'delay', g.delay), g.easeParams = c(e, 'easeParams', g.easeParams), g.ease = a(c(e, 'ease', g.ease), g.easeParams), g.hold = h(e, 'hold', g.hold), g.repeat = h(e, 'repeat', g.repeat), g.repeatDelay = h(e, 'repeatDelay', g.repeatDelay), g.yoyo = o(e, 'yoyo', g.yoyo), g.flipX = o(e, 'flipX', g.flipX), g.flipY = o(e, 'flipY', g.flipY); for (let y = 0; y < p.length; y++)i.queue(f(i, p[y], g)); i.completeDelay = r(e, 'completeDelay', 0), i.loop = Math.round(r(e, 'loop', 0)), i.loopDelay = Math.round(r(e, 'loopDelay', 0)), i.paused = o(e, 'paused', !1), i.useFrames = o(e, 'useFrames', !1); const m = c(e, 'callbackScope', i); const x = [i]; const w = c(e, 'onStart', !1); if (w) { const b = c(e, 'onStartScope', m); const T = c(e, 'onStartParams', []); i.setCallback('onStart', w, x.concat(T), b); } const S = c(e, 'onUpdate', !1); if (S) { const A = c(e, 'onUpdateScope', m); const C = c(e, 'onUpdateParams', []); i.setCallback('onUpdate', S, x.concat(C), A); } const M = c(e, 'onLoop', !1); if (M) { const _ = c(e, 'onLoopScope', m); const E = c(e, 'onLoopParams', []); i.setCallback('onLoop', M, x.concat(E), _); } const P = c(e, 'onYoyo', !1); if (P) { const L = c(e, 'onYoyoScope', m); const F = c(e, 'onYoyoParams', []); i.setCallback('onYoyo', P, x.concat(null, F), L); } const k = c(e, 'onComplete', !1); if (k) { const R = c(e, 'onCompleteScope', m); const O = c(e, 'onCompleteParams', []); i.setCallback('onComplete', k, x.concat(O), R); } return i; }; }, function (t, e, i) { const n = i(99); const s = i(10); const r = i(61); const o = i(62); const a = i(73); const h = i(4); const l = i(100); const u = i(98); const c = i(97); t.exports = function (t, e, i) { void 0 === i && (i = n); const d = h(e, 'from', 0); const f = h(e, 'to', 1); const p = [{ value: d }]; const g = a(e, 'delay', i.delay); const v = a(e, 'duration', i.duration); const y = h(e, 'easeParams', i.easeParams); const m = o(h(e, 'ease', i.ease), y); const x = a(e, 'hold', i.hold); const w = a(e, 'repeat', i.repeat); const b = a(e, 'repeatDelay', i.repeatDelay); const T = r(e, 'yoyo', i.yoyo); const S = []; const A = l('value', f); const C = c(p[0], 'value', A.getEnd, A.getStart, m, g, v, T, x, w, b, !1, !1); C.start = d, C.current = d, C.to = f, S.push(C); const M = new u(t, S, p); M.offset = s(e, 'offset', null), M.completeDelay = s(e, 'completeDelay', 0), M.loop = Math.round(s(e, 'loop', 0)), M.loopDelay = Math.round(s(e, 'loopDelay', 0)), M.paused = r(e, 'paused', !1), M.useFrames = r(e, 'useFrames', !1); for (let _ = h(e, 'callbackScope', M), E = [M, null], P = u.TYPES, L = 0; L < P.length; L++) { const F = P[L]; const k = h(e, F, !1); if (k) { const R = h(e, `${F}Scope`, _); const O = h(e, `${F}Params`, []); M.setCallback(F, k, E.concat(O), R); } } return M; }; }, function (t, e, i) { const n = i(4); t.exports = function (t) { let e = n(t, 'tweens', null); return e === null ? [] : (typeof e === 'function' && (e = e.call()), Array.isArray(e) || (e = [e]), e); }; }, function (t, e, i) { const n = i(304); t.exports = function (t) { let e; const i = []; if (t.hasOwnProperty('props')) for (e in t.props)e.substr(0, 1) !== '_' && i.push({ key: e, value: t.props[e] }); else for (e in t)n.indexOf(e) === -1 && e.substr(0, 1) !== '_' && i.push({ key: e, value: t[e] }); return i; }; }, function (t, e, i) {
  const n = i(0); const s = i(1); const r = new n({
    initialize(t) { this.delay = 0, this.repeat = 0, this.repeatCount = 0, this.loop = !1, this.callback, this.callbackScope, this.args, this.timeScale = 1, this.startAt = 0, this.elapsed = 0, this.paused = !1, this.hasDispatched = !1, this.reset(t); }, reset(t) { return this.delay = s(t, 'delay', 0), this.repeat = s(t, 'repeat', 0), this.loop = s(t, 'loop', !1), this.callback = s(t, 'callback', void 0), this.callbackScope = s(t, 'callbackScope', this.callback), this.args = s(t, 'args', []), this.timeScale = s(t, 'timeScale', 1), this.startAt = s(t, 'startAt', 0), this.paused = s(t, 'paused', !1), this.elapsed = this.startAt, this.hasDispatched = !1, this.repeatCount = this.repeat === -1 || this.loop ? 999999999999 : this.repeat, this; }, getProgress() { return this.elapsed / this.delay; }, getOverallProgress() { if (this.repeat > 0) { const t = this.delay + this.delay * this.repeat; return (this.elapsed + this.delay * (this.repeat - this.repeatCount)) / t; } return this.getProgress(); }, getRepeatCount() { return this.repeatCount; }, getElapsed() { return this.elapsed; }, getElapsedSeconds() { return 0.001 * this.elapsed; }, remove(t) { void 0 === t && (t = !1), this.elapsed = this.delay, this.hasDispatched = !t, this.repeatCount = 0; }, destroy() { this.callback = void 0, this.callbackScope = void 0, this.args = []; },
  }); t.exports = r;
}, function (t, e, i) {
  const n = new (i(0))({
    initialize(t) { this.pluginManager = t, this.game = t.game, this.scene, this.systems; }, init() {}, start() {}, stop() {}, boot() {}, destroy() { this.pluginManager = null, this.game = null, this.scene = null, this.systems = null; },
  }); t.exports = n;
}, function (t, e, i) {
  const n = i(0); const s = i(19); const r = i(1); const o = i(106); const a = i(8); const h = new n({
    Extends: s,
    initialize(t, e, i, n) {
      if (a(e)) { const o = e; e = r(o, 'key'), n = r(o, 'config', n); } const h = {
        type: 'audio', cache: t.cacheManager.audio, extension: i.type, key: e, url: i.url, config: n,
      }; s.call(this, t, h), this.locked = 'ontouchstart' in window, this.loaded = !1, this.filesLoaded = 0, this.filesTotal = 0;
    },
    onLoad() { this.loaded || (this.loaded = !0, this.loader.nextFile(this, !0)); },
    onError() { for (let t = 0; t < this.data.length; t++) { const e = this.data[t]; e.oncanplaythrough = null, e.onerror = null; } this.loader.nextFile(this, !1); },
    onProgress(t) { const e = t.target; e.oncanplaythrough = null, e.onerror = null, this.filesLoaded++, this.percentComplete = Math.min(this.filesLoaded / this.filesTotal, 1), this.loader.emit('fileprogress', this, this.percentComplete), this.filesLoaded === this.filesTotal && this.onLoad(); },
    load() { this.data = []; const t = this.config && this.config.instances || 1; this.filesTotal = t, this.filesLoaded = 0, this.percentComplete = 0; for (var e = 0; e < t; e++) { var i = new Audio(); i.dataset.name = this.key + (`0${e}`).slice(-2), i.dataset.used = 'false', this.locked ? i.dataset.locked = 'true' : (i.dataset.locked = 'false', i.preload = 'auto', i.oncanplaythrough = this.onProgress.bind(this), i.onerror = this.onError.bind(this)), this.data.push(i); } for (e = 0; e < this.data.length; e++)(i = this.data[e]).src = o(this, this.loader.baseURL), this.locked || i.load(); this.locked && setTimeout(this.onLoad.bind(this)); },
  }); t.exports = h;
}, function (t, e, i) {
  const n = i(0); const s = i(20); const r = i(19); const o = i(6); const a = i(1); const h = i(164); const l = i(8); const u = new n({
    Extends: r,
    initialize(t, e, i, n, s) {
      if (l(e)) { const o = e; e = a(o, 'key'), n = a(o, 'xhrSettings'), s = a(o, 'context', s); } const h = {
        type: 'audio', cache: t.cacheManager.audio, extension: i.type, responseType: 'arraybuffer', key: e, url: i.url, xhrSettings: n, config: { context: s },
      }; r.call(this, t, h);
    },
    onProcess() { this.state = s.FILE_PROCESSING; const t = this; this.config.context.decodeAudioData(this.xhrLoader.response, (e) => { t.data = e, t.onProcessComplete(); }, function (e) { console.error(`Error decoding audio: ${this.key} - `, e.message), t.onProcessError(); }), this.config.context = null; },
  }); u.create = function (t, e, i, n, s) { const r = t.systems.game; const o = r.config.audio; const c = r.device.audio; l(e) && (i = a(e, 'url', []), n = a(e, 'config', {})); const d = u.getAudioURL(r, i); return d ? !c.webAudio || o && o.disableWebAudio ? new h(t, e, d, n) : new u(t, e, d, s, r.sound.context) : null; }, u.getAudioURL = function (t, e) { Array.isArray(e) || (e = [e]); for (let i = 0; i < e.length; i++) { const n = a(e[i], 'url', e[i]); if (n.indexOf('blob:') === 0 || n.indexOf('data:') === 0) return n; let s = n.match(/\.([a-zA-Z0-9]+)($|\?)/); if (s = a(e[i], 'type', s ? s[1] : '').toLowerCase(), t.device.audio[s]) return { url: n, type: s }; } return null; }, o.register('audio', function (t, e, i, n) { let s; const r = this.systems.game; const o = r.config.audio; const a = r.device.audio; if (o && o.noAudio || !a.webAudio && !a.audioData) return this; if (Array.isArray(t)) for (let h = 0; h < t.length; h++)(s = u.create(this, t[h])) && this.addFile(s); else (s = u.create(this, t, e, i, n)) && this.addFile(s); return this; }), t.exports = u;
}, function (t, e, i) { const n = i(105); t.exports = function (t, e) { const i = n(e, t.xhrSettings); const s = new XMLHttpRequest(); return s.open('GET', t.src, i.async, i.user, i.password), s.responseType = t.xhrSettings.responseType, s.timeout = i.timeout, i.header && i.headerValue && s.setRequestHeader(i.header, i.headerValue), i.requestedWith && s.setRequestHeader('X-Requested-With', i.requestedWith), i.overrideMimeType && s.overrideMimeType(i.overrideMimeType), s.onload = t.onLoad.bind(t, s), s.onerror = t.onError.bind(t), s.onprogress = t.onProgress.bind(t), s.send(), s; }; }, function (t, e) {
  t.exports = function (t, e, i) {
    return {
      gameObject: t, enabled: !0, draggable: !1, dropZone: !1, target: null, camera: null, hitArea: e, hitAreaCallback: i, localX: 0, localY: 0, dragState: 0, dragStartX: 0, dragStartY: 0, dragX: 0, dragY: 0,
    };
  };
}, function (t, e, i) { const n = i(117); const s = i(2); t.exports = function (t, e, i, r, o, a, h) { if (!(s.RENDER_MASK !== e.renderFlags || e.cameraFilter > 0 && e.cameraFilter & r._id)) { const l = r.scrollX * e.scrollFactorX; const u = r.scrollY * e.scrollFactorY; const c = e.x; const d = e.y; const f = e.scaleX; const p = e.scaleY; const g = e.rotation; const v = e.commandBuffer; const y = a || t.currentContext; let m = 1; let x = 1; let w = 0; let b = 0; let T = 1; let S = 0; let A = 0; let C = 0; if (t.currentBlendMode !== e.blendMode && (t.currentBlendMode = e.blendMode, y.globalCompositeOperation = t.blendModes[e.blendMode]), t.currentAlpha !== e.alpha && (t.currentAlpha = e.alpha, y.globalAlpha = e.alpha), t.currentScaleMode !== e.scaleMode && (t.currentScaleMode = e.scaleMode), y.save(), o) { const M = o.matrix; y.transform(M[0], M[1], M[2], M[3], M[4], M[5]); }y.translate(c - l, d - u), y.rotate(g), y.scale(f, p), y.fillStyle = '#fff', y.globalAlpha = e.alpha; for (let _ = 0, E = v.length; _ < E; ++_) switch (v[_]) { case n.ARC: y.arc(v[_ + 1], v[_ + 2], v[_ + 3], v[_ + 4], v[_ + 5], v[_ + 6]), _ += 6; break; case n.LINE_STYLE: T = v[_ + 1], w = v[_ + 2], m = v[_ + 3], S = (16711680 & w) >>> 16, A = (65280 & w) >>> 8, C = 255 & w, y.strokeStyle = `rgba(${S},${A},${C},${m})`, y.lineWidth = T, _ += 3; break; case n.FILL_STYLE: b = v[_ + 1], x = v[_ + 2], S = (16711680 & b) >>> 16, A = (65280 & b) >>> 8, C = 255 & b, y.fillStyle = `rgba(${S},${A},${C},${x})`, _ += 2; break; case n.BEGIN_PATH: y.beginPath(); break; case n.CLOSE_PATH: y.closePath(); break; case n.FILL_PATH: h || y.fill(); break; case n.STROKE_PATH: h || y.stroke(); break; case n.FILL_RECT: h ? y.rect(v[_ + 1], v[_ + 2], v[_ + 3], v[_ + 4]) : y.fillRect(v[_ + 1], v[_ + 2], v[_ + 3], v[_ + 4]), _ += 4; break; case n.FILL_TRIANGLE: y.beginPath(), y.moveTo(v[_ + 1], v[_ + 2]), y.lineTo(v[_ + 3], v[_ + 4]), y.lineTo(v[_ + 5], v[_ + 6]), y.closePath(), h || y.fill(), _ += 6; break; case n.STROKE_TRIANGLE: y.beginPath(), y.moveTo(v[_ + 1], v[_ + 2]), y.lineTo(v[_ + 3], v[_ + 4]), y.lineTo(v[_ + 5], v[_ + 6]), y.closePath(), h || y.stroke(), _ += 6; break; case n.LINE_TO: y.lineTo(v[_ + 1], v[_ + 2]), _ += 2; break; case n.MOVE_TO: y.moveTo(v[_ + 1], v[_ + 2]), _ += 2; break; case n.LINE_FX_TO: y.lineTo(v[_ + 1], v[_ + 2]), _ += 5; break; case n.MOVE_FX_TO: y.moveTo(v[_ + 1], v[_ + 2]), _ += 5; break; case n.SAVE: y.save(); break; case n.RESTORE: y.restore(); break; case n.TRANSLATE: y.translate(v[_ + 1], v[_ + 2]), _ += 2; break; case n.SCALE: y.scale(v[_ + 1], v[_ + 2]), _ += 2; break; case n.ROTATE: y.rotate(v[_ + 1]), _ += 1; }y.restore(); } }; }, function (t, e) { t.exports = function (t) { const e = t.width / 2; const i = t.height / 2; const n = Math.pow(e - i, 2) / Math.pow(e + i, 2); return Math.PI * (e + i) * (1 + 3 * n / (10 + Math.sqrt(4 - 3 * n))); }; }, function (t, e, i) { const n = i(169); const s = i(110); const r = i(64); const o = i(16); t.exports = function (t, e, i, a) { void 0 === a && (a = []), e || (e = n(t) / i); for (let h = 0; h < e; h++) { const l = r(h / e, 0, o.PI2); a.push(s(t, l)); } return a; }; }, function (t, e, i) { const n = i(110); const s = i(64); const r = i(16); const o = i(5); t.exports = function (t, e, i) { void 0 === i && (i = new o()); const a = s(e, 0, r.PI2); return n(t, a, i); }; }, function (t, e) { var i = function (t, e, r, o, a) { for (r = r || 0, o = o || t.length - 1, a = a || s; o > r;) { if (o - r > 600) { const h = o - r + 1; const l = e - r + 1; const u = Math.log(h); const c = 0.5 * Math.exp(2 * u / 3); const d = 0.5 * Math.sqrt(u * c * (h - c) / h) * (l - h / 2 < 0 ? -1 : 1); const f = Math.max(r, Math.floor(e - l * c / h + d)); const p = Math.min(o, Math.floor(e + (h - l) * c / h + d)); i(t, e, f, p, a); } const g = t[e]; let v = r; let y = o; for (n(t, r, e), a(t[o], g) > 0 && n(t, r, o); v < y;) { for (n(t, v, y), v++, y--; a(t[v], g) < 0;)v++; for (;a(t[y], g) > 0;)y--; }a(t[r], g) === 0 ? n(t, r, y) : n(t, ++y, o), y <= e && (r = y + 1), e <= y && (o = y - 1); } }; function n(t, e, i) { const n = t[e]; t[e] = t[i], t[i] = n; } function s(t, e) { return t < e ? -1 : t > e ? 1 : 0; }t.exports = i; }, function (t, e) { t.exports = function (t) { for (var e = t.length, i = t[0].length, n = new Array(i), s = 0; s < i; s++) { n[s] = new Array(e); for (let r = e - 1; r > -1; r--)n[s][r] = t[r][s]; } return n; }; }, function (t, e, i) {
  t.exports = {
    AtlasXML: i(501), Canvas: i(500), Image: i(499), JSONArray: i(498), JSONHash: i(497), SpriteSheet: i(496), SpriteSheetFromAtlas: i(495), UnityYAML: i(494),
  };
}, function (t, e, i) {
  const n = i(22); const s = i(0); const r = i(84); const o = i(58); const a = new s({
    initialize(t, e, i, n) { const s = t.manager.game; this.renderer = s.renderer, this.texture = t, this.image = e, this.compressionAlgorithm = null, this.resolution = 1, this.width = i || e.naturalWidth || e.width || 0, this.height = n || e.naturalHeight || e.height || 0, this.scaleMode = o.DEFAULT, this.isCanvas = e instanceof HTMLCanvasElement, this.isPowerOf2 = r(this.width, this.height), this.glTexture = null, this.init(s); }, init(t) { this.renderer && this.renderer.gl && (this.isCanvas ? this.glTexture = this.renderer.canvasToTexture(this.image) : this.glTexture = this.renderer.createTextureFromSource(this.image, this.width, this.height, this.scaleMode)), t.config.pixelArt && this.setFilter(1); }, setFilter(t) { this.renderer.gl && this.renderer.setTextureFilter(this.glTexture, t); }, update() { this.renderer.gl && this.isCanvas && this.renderer.canvasToTexture(this.image, this.glTexture); }, destroy() { this.glTexture && this.renderer.deleteTexture(this.glTexture), this.isCanvas && n.remove(this.image), this.renderer = null, this.texture = null, this.image = null; },
  }); t.exports = a;
}, function (t, e, i) {
  const n = i(22); const s = i(502); const r = i(0); const o = i(30); const a = i(20); const h = i(9); const l = i(276); const u = i(4); const c = i(174); const d = i(114); const f = new r({
    Extends: h, initialize(t) { h.call(this), this.game = t, this.name = 'TextureManager', this.list = {}, this._tempCanvas = n.create2D(this, 1, 1), this._tempContext = this._tempCanvas.getContext('2d'), this._pending = 0, t.events.once('boot', this.boot, this); }, boot() { this._pending = 2, this.on('onload', this.updatePending, this), this.on('onerror', this.updatePending, this), this.addBase64('__DEFAULT', this.game.config.defaultImage), this.addBase64('__MISSING', this.game.config.missingImage), this.game.events.once('destroy', this.destroy, this); }, updatePending() { this._pending--, this._pending === 0 && (this.off('onload'), this.off('onerror'), this.game.events.emit('ready')); }, checkKey(t) { return !this.exists(t) || (console.error(`Texture key already in use: ${t}`), !1); }, remove(t) { if (typeof t === 'string') { if (!this.exists(t)) return console.warn(`No texture found matching key: ${t}`), this; t = this.get(t); } return this.list.hasOwnProperty(t.key) && (delete this.list[t.key], t.destroy(), this.emit('removetexture', t.key)), this; }, addBase64(t, e) { if (this.checkKey(t)) { const i = this; const n = new Image(); n.onerror = function () { i.emit('onerror', t); }, n.onload = function () { const e = i.create(t, n); c.Image(e, 0), i.emit('addtexture', t, e), i.emit('onload', t, e); }, n.src = e; } }, addImage(t, e, i) { let n = null; return this.checkKey(t) && (n = this.create(t, e), c.Image(n, 0), i && n.setDataSource(i), this.emit('addtexture', t, n)), n; }, generate(t, e) { if (this.checkKey(t)) { const i = n.create(this, 1, 1); return e.canvas = i, l(e), this.addCanvas(t, i); } return null; }, createCanvas(t, e, i) { if (void 0 === e && (e = 256), void 0 === i && (i = 256), this.checkKey(t)) { const s = n.create(this, e, i, a.CANVAS, !0); return this.addCanvas(t, s); } return null; }, addCanvas(t, e) { let i = null; return this.checkKey(t) && (i = new s(this, t, e, e.width, e.height), this.list[t] = i, this.emit('addtexture', t, i)), i; }, addAtlas(t, e, i, n) { return Array.isArray(i.textures) || Array.isArray(i.frames) ? this.addAtlasJSONArray(t, e, i, n) : this.addAtlasJSONHash(t, e, i, n); }, addAtlasJSONArray(t, e, i, n) { let s = null; if (this.checkKey(t)) { if (s = this.create(t, e), Array.isArray(i)) for (let r = i.length === 1, o = 0; o < s.source.length; o++) { const a = r ? i[0] : i[o]; c.JSONArray(s, o, a); } else c.JSONArray(s, 0, i); n && s.setDataSource(n), this.emit('addtexture', t, s); } return s; }, addAtlasJSONHash(t, e, i, n) { let s = null; if (this.checkKey(t)) { if (s = this.create(t, e), Array.isArray(i)) for (let r = 0; r < i.length; r++)c.JSONHash(s, r, i[r]); else c.JSONHash(s, 0, i); n && s.setDataSource(n), this.emit('addtexture', t, s); } return s; }, addAtlasXML(t, e, i, n) { let s = null; return this.checkKey(t) && (s = this.create(t, e), c.AtlasXML(s, 0, i), n && s.setDataSource(n), this.emit('addtexture', t, s)), s; }, addUnityAtlas(t, e, i, n) { let s = null; return this.checkKey(t) && (s = this.create(t, e), c.UnityYAML(s, 0, i), n && s.setDataSource(n), this.emit('addtexture', t, s)), s; }, addSpriteSheet(t, e, i) { let n = null; if (this.checkKey(t)) { const s = (n = this.create(t, e)).source[0].width; const r = n.source[0].height; c.SpriteSheet(n, 0, 0, 0, s, r, i), this.emit('addtexture', t, n); } return n; }, addSpriteSheetFromAtlas(t, e) { if (!this.checkKey(t)) return null; const i = u(e, 'atlas', null); const n = u(e, 'frame', null); if (i && n) { const s = this.get(i).get(n); if (s) { const r = this.create(t, s.source.image); return s.trimmed ? c.SpriteSheetFromAtlas(r, s, e) : c.SpriteSheet(r, 0, s.cutX, s.cutY, s.cutWidth, s.cutHeight, e), this.emit('addtexture', t, r), r; } } }, create(t, e, i, n) { let s = null; return this.checkKey(t) && (s = new d(this, t, e, i, n), this.list[t] = s), s; }, exists(t) { return this.list.hasOwnProperty(t); }, get(t) { return void 0 === t && (t = '__DEFAULT'), this.list[t] ? this.list[t] : this.list.__MISSING; }, cloneFrame(t, e) { if (this.list[t]) return this.list[t].get(e).clone(); }, getFrame(t, e) { if (this.list[t]) return this.list[t].get(e); }, getTextureKeys() { const t = []; for (const e in this.list)e !== '__DEFAULT' && e !== '__MISSING' && t.push(e); return t; }, getPixel(t, e, i, n) { const s = this.getFrame(i, n); if (s) { const r = s.source.image; if (t >= 0 && t <= r.width && e >= 0 && e <= r.height) { t += s.cutX, e += s.cutY; const a = this._tempContext; a.clearRect(0, 0, 1, 1), a.drawImage(r, t, e, 1, 1, 0, 0, 1, 1); const h = a.getImageData(0, 0, 1, 1); return new o(h.data[0], h.data[1], h.data[2], h.data[3]); } } return null; }, setTexture(t, e, i) { return this.list[e] && (t.texture = this.list[e], t.frame = t.texture.get(i)), t; }, each(t, e) { for (var i = [null], n = 1; n < arguments.length; n++)i.push(arguments[n]); for (const s in this.list)i[0] = this.list[s], t.apply(e, i); }, destroy() { for (const t in this.list) this.list[t].destroy(); this.list = {}, this.game = null, n.remove(this._tempCanvas); },
  }); t.exports = f;
}, function (t, e, i) {
  const n = i(76); const s = new (i(0))({
    Extends: n, initialize(t, e, i) { void 0 === i && (i = {}), this.audioBuffer = t.game.cache.audio.get(e), this.audioBuffer ? (this.source = null, this.loopSource = null, this.muteNode = t.context.createGain(), this.volumeNode = t.context.createGain(), this.playTime = 0, this.startTime = 0, this.loopTime = 0, this.rateUpdates = [], this.hasEnded = !1, this.hasLooped = !1, this.muteNode.connect(this.volumeNode), this.volumeNode.connect(t.destination), this.duration = this.audioBuffer.duration, this.totalDuration = this.audioBuffer.duration, n.call(this, t, e, i)) : console.warn(`Audio cache entry missing: ${e}`); }, play(t, e) { return !!n.prototype.play.call(this, t, e) && (this.stopAndRemoveBufferSource(), this.createAndStartBufferSource(), this.emit('play', this), !0); }, pause() { return !(this.manager.context.currentTime < this.startTime) && (!!n.prototype.pause.call(this) && (this.currentConfig.seek = this.getCurrentTime(), this.stopAndRemoveBufferSource(), this.emit('pause', this), !0)); }, resume() { return !(this.manager.context.currentTime < this.startTime) && (!!n.prototype.resume.call(this) && (this.createAndStartBufferSource(), this.emit('resume', this), !0)); }, stop() { return !!n.prototype.stop.call(this) && (this.stopAndRemoveBufferSource(), this.emit('stop', this), !0); }, createAndStartBufferSource() { const t = this.currentConfig.seek; const e = this.currentConfig.delay; const i = this.manager.context.currentTime + e; const n = (this.currentMarker ? this.currentMarker.start : 0) + t; const s = this.duration - t; this.playTime = i - t, this.startTime = i, this.source = this.createBufferSource(), this.applyConfig(), this.source.start(Math.max(0, i), Math.max(0, n), Math.max(0, s)), this.resetConfig(); }, createAndStartLoopBufferSource() { const t = this.getLoopTime(); const e = this.currentMarker ? this.currentMarker.start : 0; const i = this.duration; this.loopTime = t, this.loopSource = this.createBufferSource(), this.loopSource.playbackRate.setValueAtTime(this.totalRate, 0), this.loopSource.start(Math.max(0, t), Math.max(0, e), Math.max(0, i)); }, createBufferSource() { const t = this; const e = this.manager.context.createBufferSource(); return e.buffer = this.audioBuffer, e.connect(this.muteNode), e.onended = function (e) { e.target === t.source && (t.currentConfig.loop ? t.hasLooped = !0 : t.hasEnded = !0); }, e; }, stopAndRemoveBufferSource() { this.source && (this.source.stop(), this.source.disconnect(), this.source = null), this.playTime = 0, this.startTime = 0, this.stopAndRemoveLoopBufferSource(); }, stopAndRemoveLoopBufferSource() { this.loopSource && (this.loopSource.stop(), this.loopSource.disconnect(), this.loopSource = null), this.loopTime = 0; }, applyConfig() { this.rateUpdates.length = 0, this.rateUpdates.push({ time: 0, rate: 1 }), n.prototype.applyConfig.call(this); }, update(t, e) { this.hasEnded ? (this.hasEnded = !1, n.prototype.stop.call(this), this.stopAndRemoveBufferSource(), this.emit('ended', this)) : this.hasLooped && (this.hasLooped = !1, this.source = this.loopSource, this.loopSource = null, this.playTime = this.startTime = this.loopTime, this.rateUpdates.length = 0, this.rateUpdates.push({ time: 0, rate: this.totalRate }), this.createAndStartLoopBufferSource(), this.emit('looped', this)); }, destroy() { n.prototype.destroy.call(this), this.audioBuffer = null, this.stopAndRemoveBufferSource(), this.muteNode.disconnect(), this.muteNode = null, this.volumeNode.disconnect(), this.volumeNode = null, this.rateUpdates.length = 0, this.rateUpdates = null; }, calculateRate() { n.prototype.calculateRate.call(this); const t = this.manager.context.currentTime; this.source && typeof this.totalRate === 'number' && this.source.playbackRate.setValueAtTime(this.totalRate, t), this.isPlaying && (this.rateUpdates.push({ time: Math.max(this.startTime, t) - this.playTime, rate: this.totalRate }), this.loopSource && (this.stopAndRemoveLoopBufferSource(), this.createAndStartLoopBufferSource())); }, getCurrentTime() { for (var t = 0, e = 0; e < this.rateUpdates.length; e++) { t += ((e < this.rateUpdates.length - 1 ? this.rateUpdates[e + 1].time : this.manager.context.currentTime - this.playTime) - this.rateUpdates[e].time) * this.rateUpdates[e].rate; } return t; }, getLoopTime() { for (var t = 0, e = 0; e < this.rateUpdates.length - 1; e++)t += (this.rateUpdates[e + 1].time - this.rateUpdates[e].time) * this.rateUpdates[e].rate; const i = this.rateUpdates[this.rateUpdates.length - 1]; return this.playTime + i.time + (this.duration - t) / i.rate; }, rate: { get() { return this.currentConfig.rate; }, set(t) { this.currentConfig.rate = t, this.calculateRate(), this.emit('rate', this, t); } }, setRate(t) { return this.rate = t, this; }, detune: { get() { return this.currentConfig.detune; }, set(t) { this.currentConfig.detune = t, this.calculateRate(), this.emit('detune', this, t); } }, setDetune(t) { return this.detune = t, this; }, mute: { get() { return this.muteNode.gain.value === 0; }, set(t) { this.currentConfig.mute = t, this.muteNode.gain.setValueAtTime(t ? 0 : 1, 0), this.emit('mute', this, t); } }, setMute(t) { return this.mute = t, this; }, volume: { get() { return this.volumeNode.gain.value; }, set(t) { this.currentConfig.volume = t, this.volumeNode.gain.setValueAtTime(t, 0), this.emit('volume', this, t); } }, setVolume(t) { return this.volume = t, this; }, seek: { get() { return this.isPlaying ? this.manager.context.currentTime < this.startTime ? this.startTime - this.playTime : this.getCurrentTime() : this.isPaused ? this.currentConfig.seek : 0; }, set(t) { this.manager.context.currentTime < this.startTime || (this.isPlaying || this.isPaused) && (t = Math.min(Math.max(0, t), this.duration), this.currentConfig.seek = t, this.isPlaying && (this.stopAndRemoveBufferSource(), this.createAndStartBufferSource()), this.emit('seek', this, t)); } }, setSeek(t) { return this.seek = t, this; }, loop: { get() { return this.currentConfig.loop; }, set(t) { this.currentConfig.loop = t, this.isPlaying && (this.stopAndRemoveLoopBufferSource(), t && this.createAndStartLoopBufferSource()), this.emit('loop', this, t); } }, setLoop(t) { return this.loop = t, this; },
  }); t.exports = s;
}, function (t, e, i) {
  const n = i(77); const s = i(0); const r = i(177); const o = new s({
    Extends: n, initialize(t) { this.context = this.createAudioContext(t), this.masterMuteNode = this.context.createGain(), this.masterVolumeNode = this.context.createGain(), this.masterMuteNode.connect(this.masterVolumeNode), this.masterVolumeNode.connect(this.context.destination), this.destination = this.masterMuteNode, this.locked = this.context.state === 'suspended' && ('ontouchstart' in window || 'onclick' in window), n.call(this, t), this.locked && this.unlock(); }, createAudioContext(t) { const e = t.config.audio; return e && e.context ? (e.context.resume(), e.context) : new AudioContext(); }, add(t, e) { const i = new r(this, t, e); return this.sounds.push(i), i; }, unlock() { const t = this; var e = function () { t.context.resume().then(() => { document.body.removeEventListener('touchstart', e), document.body.removeEventListener('touchend', e), document.body.removeEventListener('click', e), t.unlocked = !0; }); }; document.body && (document.body.addEventListener('touchstart', e, !1), document.body.addEventListener('touchend', e, !1), document.body.addEventListener('click', e, !1)); }, onBlur() { this.context.suspend(); }, onFocus() { this.context.resume(); }, destroy() { if (this.destination = null, this.masterVolumeNode.disconnect(), this.masterVolumeNode = null, this.masterMuteNode.disconnect(), this.masterMuteNode = null, this.game.config.audio && this.game.config.audio.context) this.context.suspend(); else { const t = this; this.context.close().then(() => { t.context = null; }); }n.prototype.destroy.call(this); }, setMute(t) { return this.mute = t, this; }, mute: { get() { return this.masterMuteNode.gain.value === 0; }, set(t) { this.masterMuteNode.gain.setValueAtTime(t ? 0 : 1, 0), this.emit('mute', this, t); } }, setVolume(t) { return this.volume = t, this; }, volume: { get() { return this.masterVolumeNode.gain.value; }, set(t) { this.masterVolumeNode.gain.setValueAtTime(t, 0), this.emit('volume', this, t); } },
  }); t.exports = o;
}, function (t, e, i) {
  const n = i(76); const s = i(0); const r = i(9); const o = i(18); const a = new s({
    Extends: r,
    initialize(t, e, i) {
      void 0 === i && (i = {}), r.call(this), this.manager = t, this.key = e, this.isPlaying = !1, this.isPaused = !1, this.totalRate = 1, this.duration = 0, this.totalDuration = 0, this.config = o({
        mute: !1, volume: 1, rate: 1, detune: 0, seek: 0, loop: !1, delay: 0,
      }, i), this.currentConfig = this.config, this.mute = !1, this.volume = 1, this.rate = 1, this.detune = 0, this.seek = 0, this.loop = !1, this.markers = {}, this.currentMarker = null, this.pendingRemove = !1;
    },
    addMarker(t) { return !1; },
    updateMarker(t) { return !1; },
    removeMarker(t) { return null; },
    play(t, e) { return !1; },
    pause() { return !1; },
    resume() { return !1; },
    stop() { return !1; },
    destroy() { this.manager.remove(this), n.prototype.destroy.call(this); },
  }); t.exports = a;
}, function (t, e, i) {
  const n = i(77); const s = i(0); const r = i(9); const o = i(179); const a = i(3); const h = new s({
    Extends: r, initialize(t) { r.call(this), this.game = t, this.sounds = [], this.mute = !1, this.volume = 1, this.rate = 1, this.detune = 0, this.pauseOnBlur = !0, this.locked = !1; }, add(t, e) { const i = new o(this, t, e); return this.sounds.push(i), i; }, addAudioSprite(t, e) { const i = this.add(t, e); return i.spritemap = {}, i; }, play(t, e) { return !1; }, playAudioSprite(t, e, i) { return !1; }, remove(t) { return n.prototype.remove.call(this, t); }, removeByKey(t) { return n.prototype.removeByKey.call(this, t); }, pauseAll: a, resumeAll: a, stopAll: a, update: a, setRate: a, setDetune: a, setMute: a, setVolume: a, forEachActiveSound(t, e) { n.prototype.forEachActiveSound.call(this, t, e); }, destroy() { n.prototype.destroy.call(this); },
  }); t.exports = h;
}, function (t, e, i) {
  const n = i(76); const s = new (i(0))({
    Extends: n, initialize(t, e, i) { void 0 === i && (i = {}), this.tags = t.game.cache.audio.get(e), this.tags ? (this.audio = null, this.startTime = 0, this.previousTime = 0, this.duration = this.tags[0].duration, this.totalDuration = this.tags[0].duration, n.call(this, t, e, i)) : console.warn(`Audio cache entry missing: ${e}`); }, play(t, e) { return !this.manager.isLocked(this, 'play', [t, e]) && (!!n.prototype.play.call(this, t, e) && (!!this.pickAndPlayAudioTag() && (this.emit('play', this), !0))); }, pause() { return !this.manager.isLocked(this, 'pause') && (!(this.startTime > 0) && (!!n.prototype.pause.call(this) && (this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0), this.stopAndReleaseAudioTag(), this.emit('pause', this), !0))); }, resume() { return !this.manager.isLocked(this, 'resume') && (!(this.startTime > 0) && (!!n.prototype.resume.call(this) && (!!this.pickAndPlayAudioTag() && (this.emit('resume', this), !0)))); }, stop() { return !this.manager.isLocked(this, 'stop') && (!!n.prototype.stop.call(this) && (this.stopAndReleaseAudioTag(), this.emit('stop', this), !0)); }, pickAndPlayAudioTag() { if (!this.pickAudioTag()) return this.reset(), !1; const t = this.currentConfig.seek; const e = this.currentConfig.delay; const i = (this.currentMarker ? this.currentMarker.start : 0) + t; return this.previousTime = i, this.audio.currentTime = i, this.applyConfig(), e === 0 ? (this.startTime = 0, this.audio.paused && this.playCatchPromise()) : (this.startTime = window.performance.now() + 1e3 * e, this.audio.paused || this.audio.pause()), this.resetConfig(), !0; }, pickAudioTag() { if (this.audio) return !0; for (let t = 0; t < this.tags.length; t++) { const e = this.tags[t]; if (e.dataset.used === 'false') return e.dataset.used = 'true', this.audio = e, !0; } if (!this.manager.override) return !1; const i = []; this.manager.forEachActiveSound(function (t) { t.key === this.key && t.audio && i.push(t); }, this), i.sort((t, e) => (t.loop === e.loop ? e.seek / e.duration - t.seek / t.duration : t.loop ? 1 : -1)); const n = i[0]; return this.audio = n.audio, n.reset(), n.audio = null, n.startTime = 0, n.previousTime = 0, !0; }, playCatchPromise() { const t = this.audio.play(); t && t.catch((t) => { console.warn(t); }); }, stopAndReleaseAudioTag() { this.audio.pause(), this.audio.dataset.used = 'false', this.audio = null, this.startTime = 0, this.previousTime = 0; }, reset() { n.prototype.stop.call(this); }, onBlur() { this.isPlaying = !1, this.isPaused = !0, this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0), this.currentConfig.delay = Math.max(0, (this.startTime - window.performance.now()) / 1e3), this.stopAndReleaseAudioTag(); }, onFocus() { this.isPlaying = !0, this.isPaused = !1, this.pickAndPlayAudioTag(); }, update(t, e) { if (this.isPlaying) if (this.startTime > 0) this.startTime < t - this.manager.audioPlayDelay && (this.audio.currentTime += Math.max(0, t - this.startTime) / 1e3, this.startTime = 0, this.previousTime = this.audio.currentTime, this.playCatchPromise()); else { const i = this.currentMarker ? this.currentMarker.start : 0; const n = i + this.duration; let s = this.audio.currentTime; if (this.currentConfig.loop)s >= n - this.manager.loopEndOffset ? (this.audio.currentTime = i + Math.max(0, s - n), s = this.audio.currentTime) : s < i && (this.audio.currentTime += i, s = this.audio.currentTime), s < this.previousTime && this.emit('looped', this); else if (s >= n) return this.reset(), this.stopAndReleaseAudioTag(), void this.emit('ended', this); this.previousTime = s; } }, destroy() { n.prototype.destroy.call(this), this.tags = null, this.audio && this.stopAndReleaseAudioTag(); }, updateMute() { this.audio && (this.audio.muted = this.currentConfig.mute || this.manager.mute); }, updateVolume() { this.audio && (this.audio.volume = this.currentConfig.volume * this.manager.volume); }, calculateRate() { n.prototype.calculateRate.call(this), this.audio && (this.audio.playbackRate = this.totalRate); }, mute: { get() { return this.currentConfig.mute; }, set(t) { this.currentConfig.mute = t, this.manager.isLocked(this, 'mute', t) || this.emit('mute', this, t); } }, setMute(t) { return this.mute = t, this; }, volume: { get() { return this.currentConfig.volume; }, set(t) { this.currentConfig.volume = t, this.manager.isLocked(this, 'volume', t) || this.emit('volume', this, t); } }, setVolume(t) { return this.volume = t, this; }, rate: { get() { return this.currentConfig.rate; }, set(t) { this.currentConfig.rate = t, this.manager.isLocked(this, 'rate', t) || (this.calculateRate(), this.emit('rate', this, t)); } }, setRate(t) { return this.rate = t, this; }, detune: { get() { return this.currentConfig.detune; }, set(t) { this.currentConfig.detune = t, this.manager.isLocked(this, 'detune', t) || (this.calculateRate(), this.emit('detune', this, t)); } }, setDetune(t) { return this.detune = t, this; }, seek: { get() { return this.isPlaying ? this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0) : this.isPaused ? this.currentConfig.seek : 0; }, set(t) { this.manager.isLocked(this, 'seek', t) || this.startTime > 0 || (this.isPlaying || this.isPaused) && (t = Math.min(Math.max(0, t), this.duration), this.isPlaying ? (this.previousTime = t, this.audio.currentTime = t) : this.isPaused && (this.currentConfig.seek = t), this.emit('seek', this, t)); } }, setSeek(t) { return this.seek = t, this; }, loop: { get() { return this.currentConfig.loop; }, set(t) { this.currentConfig.loop = t, this.manager.isLocked(this, 'loop', t) || (this.audio && (this.audio.loop = t), this.emit('loop', this, t)); } }, setLoop(t) { return this.loop = t, this; },
  }); t.exports = s;
}, function (t, e, i) {
  const n = i(77); const s = i(0); const r = i(181); const o = new s({
    Extends: n, initialize(t) { this.override = !0, this.audioPlayDelay = 0.1, this.loopEndOffset = 0.05, this.onBlurPausedSounds = [], this.locked = 'ontouchstart' in window, this.lockedActionsQueue = this.locked ? [] : null, this._mute = !1, this._volume = 1, n.call(this, t); }, add(t, e) { const i = new r(this, t, e); return this.sounds.push(i), i; }, unlock() { this.locked = !1; const t = this; if (this.game.cache.audio.entries.each((e, i) => { for (let n = 0; n < i.length; n++) if (i[n].dataset.locked === 'true') return t.locked = !0, !1; return !0; }), this.locked) { let e = !1; const i = function () { e = !0; }; var n = function () { if (e)e = !1; else { document.body.removeEventListener('touchmove', i), document.body.removeEventListener('touchend', n); const s = []; if (t.game.cache.audio.entries.each((t, e) => { for (let i = 0; i < e.length; i++) { const n = e[i]; n.dataset.locked === 'true' && s.push(n); } return !0; }), s.length !== 0) { const r = s[s.length - 1]; r.oncanplaythrough = function () { r.oncanplaythrough = null, s.forEach((t) => { t.dataset.locked = 'false'; }), t.unlocked = !0; }, s.forEach((t) => { t.load(); }); } } }; this.once('unlocked', function () { for (this.forEachActiveSound((t) => { t.currentMarker === null && t.duration === 0 && (t.duration = t.tags[0].duration), t.totalDuration = t.tags[0].duration; }); this.lockedActionsQueue.length;) { const t = this.lockedActionsQueue.shift(); t.sound[t.prop].apply ? t.sound[t.prop].apply(t.sound, t.value || []) : t.sound[t.prop] = t.value; } }, this), document.body.addEventListener('touchmove', i, !1), document.body.addEventListener('touchend', n, !1); } }, onBlur() { this.forEachActiveSound(function (t) { t.isPlaying && (this.onBlurPausedSounds.push(t), t.onBlur()); }); }, onFocus() { this.onBlurPausedSounds.forEach((t) => { t.onFocus(); }), this.onBlurPausedSounds.length = 0; }, destroy() { n.prototype.destroy.call(this), this.onBlurPausedSounds.length = 0, this.onBlurPausedSounds = null; }, isLocked(t, e, i) { return t.tags[0].dataset.locked === 'true' && (this.lockedActionsQueue.push({ sound: t, prop: e, value: i }), !0); }, setMute(t) { return this.mute = t, this; }, mute: { get() { return this._mute; }, set(t) { this._mute = t, this.forEachActiveSound((t) => { t.updateMute(); }), this.emit('mute', this, t); } }, setVolume(t) { return this.volume = t, this; }, volume: { get() { return this._volume; }, set(t) { this._volume = t, this.forEachActiveSound((t) => { t.updateVolume(); }), this.emit('volume', this, t); } },
  }); t.exports = o;
}, function (t, e, i) { const n = i(182); const s = i(180); const r = i(178); const o = { create(t) { const e = t.config.audio; const i = t.device.audio; return e && e.noAudio || !i.webAudio && !i.audioData ? new s(t) : !i.webAudio || e && e.disableWebAudio ? new n(t) : new r(t); } }; t.exports = o; }, function (t, e, i) {
  const n = i(54); const s = i(4); const r = i(93); const o = i(503); const a = {
    create(t) {
      return typeof t === 'string' ? t = { key: t } : void 0 === t && (t = {}), {
        status: n.PENDING, key: s(t, 'key', ''), active: s(t, 'active', !1), visible: s(t, 'visible', !0), isBooted: !1, isTransition: !1, transitionFrom: null, transitionDuration: 0, transitionAllowInput: !0, data: {}, pack: s(t, 'pack', !1), cameras: s(t, 'cameras', null), map: s(t, 'map', r(o, s(t, 'mapAdd', {}))), physics: s(t, 'physics', {}), loader: s(t, 'loader', {}), plugins: s(t, 'plugins', !1),
      };
    },
  }; t.exports = a;
}, function (t, e, i) { const n = i(0); const s = i(115); const r = new n({ initialize(t) { this.sys = new s(this, t), this.game, this.anims, this.cache, this.registry, this.sound, this.textures, this.events, this.cameras, this.cameras3d, this.add, this.make, this.scene, this.children, this.lights, this.data, this.input, this.load, this.time, this.tweens, this.physics, this.impact, this.matter; }, update() {} }); t.exports = r; }, function (t, e, i) {
  const n = i(0); const s = i(54); const r = i(4); const o = i(3); const a = i(185); const h = i(115); const l = new n({
    initialize(t, e) {
      if (this.game = t, this.keys = {}, this.scenes = [], this._pending = [], this._start = [], this._queue = [], this._data = {}, this.isProcessing = !1, this.isBooted = !1, e) {
        Array.isArray(e) || (e = [e]); for (let i = 0; i < e.length; i++) {
          this._pending.push({
            key: 'default', scene: e[i], autoStart: i === 0, data: {},
          });
        }
      }t.events.once('ready', this.bootQueue, this);
    },
    bootQueue() { if (!this.isBooted) { let t; let e; let i; let n; for (t = 0; t < this._pending.length; t++) { var s; i = (e = this._pending[t]).key, (n = e.scene) instanceof a ? s = this.createSceneFromInstance(i, n) : typeof n === 'object' ? s = this.createSceneFromObject(i, n) : typeof n === 'function' && (s = this.createSceneFromFunction(i, n)), i = s.sys.settings.key, this.keys[i] = s, this.scenes.push(s), this._data[i] && (s.sys.settings.data = this._data[i].data, this._data[i].autoStart && (e.autoStart = !0)), (e.autoStart || s.sys.settings.active) && this._start.push(i); } for (this._pending.length = 0, this._data = {}, this.isBooted = !0, t = 0; t < this._start.length; t++)e = this._start[t], this.start(e); this._start.length = 0; } },
    processQueue() { const t = this._pending.length; const e = this._queue.length; if (t !== 0 || e !== 0) { let i; let n; if (t) { for (i = 0; i < t; i++)n = this._pending[i], this.add(n.key, n.scene, n.autoStart, n.data); for (i = 0; i < this._start.length; i++)n = this._start[i], this.start(n); return this._start.length = 0, void (this._pending.length = 0); } for (i = 0; i < this._queue.length; i++) this[(n = this._queue[i]).op](n.keyA, n.keyB); this._queue.length = 0; } },
    add(t, e, i, n) {
      return void 0 === i && (i = !1), void 0 === n && (n = {}), this.isProcessing || !this.isBooted ? (this._pending.push({
        key: t, scene: e, autoStart: i, data: n,
      }), this.isBooted || (this._data[t] = { data: n }), null) : (t = this.getKey(t, e), e instanceof a ? s = this.createSceneFromInstance(t, e) : typeof e === 'object' ? (e.key = t, s = this.createSceneFromObject(t, e)) : typeof e === 'function' && (s = this.createSceneFromFunction(t, e)), s.sys.settings.data = n, t = s.sys.settings.key, this.keys[t] = s, this.scenes.push(s), (i || s.sys.settings.active) && (this._pending.length ? this._start.push(t) : this.start(t)), s); let s;
    },
    remove(t) { if (this.isProcessing) this._queue.push({ op: 'remove', keyA: t, keyB: null }); else { const e = this.getScene(t); if (!e || e.sys.isTransitioning()) return this; let i = this.scenes.indexOf(e); const n = e.sys.settings.key; i > -1 && (delete this.keys[n], this.scenes.splice(i, 1), this._start.indexOf(n) > -1 && (i = this._start.indexOf(n), this._start.splice(i, 1)), e.sys.destroy()); } return this; },
    bootScene(t) { let e; const i = t.sys; const n = i.settings; t.init && (t.init.call(t, n.data), n.isTransition && i.events.emit('transitioninit', n.transitionFrom, n.transitionDuration)), i.load && (e = i.load).reset(), e && t.preload ? (t.preload.call(t), e.list.size === 0 ? this.create(t) : (n.status = s.LOADING, e.once('complete', this.loadComplete, this), e.start())) : this.create(t); },
    loadComplete(t) { const e = t.scene; this.game.sound.onBlurPausedSounds && this.game.sound.unlock(), this.create(e); },
    payloadComplete(t) { this.bootScene(t.scene); },
    update(t, e) { this.processQueue(), this.isProcessing = !0; for (let i = this.scenes.length - 1; i >= 0; i--) { const n = this.scenes[i].sys; n.settings.status === s.RUNNING && n.step(t, e); } },
    resize(t, e) { for (let i = 0; i < this.scenes.length; i++) { this.scenes[i].sys.resize(t, e); } },
    render(t) { for (let e = 0; e < this.scenes.length; e++) { const i = this.scenes[e].sys; i.settings.visible && i.settings.status >= s.LOADING && i.settings.status < s.SLEEPING && i.render(t); } this.isProcessing = !1; },
    create(t) { const e = t.sys; const i = e.settings; t.create && (t.sys.settings.status = s.CREATING, t.create.call(t, t.sys.settings.data), i.isTransition && e.events.emit('transitionstart', i.transitionFrom, i.transitionDuration)), i.status = s.RUNNING; },
    createSceneFromFunction(t, e) { const i = new e(); if (i instanceof a) { const n = i.sys.settings.key; if (n !== '' && (t = n), this.keys.hasOwnProperty(t)) throw new Error(`Cannot add a Scene with duplicate key: ${t}`); return this.createSceneFromInstance(t, i); } return i.sys = new h(i), i.sys.settings.key = t, i.sys.init(this.game), i.update || (i.update = o), i; },
    createSceneFromInstance(t, e) { const i = e.sys.settings.key; return i !== '' ? t = i : e.sys.settings.key = t, e.sys.init(this.game), e; },
    createSceneFromObject(t, e) { const i = new a(e); const n = i.sys.settings.key; n !== '' ? t = n : i.sys.settings.key = t, i.sys.init(this.game); for (let s = ['init', 'preload', 'create', 'update', 'render'], h = 0; h < s.length; h++) { let l = r(e, s[h], null); s[h] !== 'update' || l || (l = o), l && (i[s[h]] = l); } if (e.hasOwnProperty('extend')) for (const u in e.extend) { const c = e.extend[u]; u === 'data' && i.hasOwnProperty('data') && typeof c === 'object' ? i.data.merge(c) : u !== 'sys' && (i[u] = c); } return i; },
    getKey(t, e) { if (t || (t = 'default'), typeof e === 'function') return t; if (e instanceof a ? t = e.sys.settings.key : typeof e === 'object' && e.hasOwnProperty('key') && (t = e.key), this.keys.hasOwnProperty(t)) throw new Error(`Cannot add a Scene with duplicate key: ${t}`); return t; },
    getScene(t) { if (typeof t === 'string') { if (this.keys[t]) return this.keys[t]; } else for (let e = 0; e < this.scenes.length; e++) if (t === this.scenes[e]) return t; return null; },
    isActive(t) { const e = this.getScene(t); return e ? e.sys.isActive() : null; },
    isVisible(t) { const e = this.getScene(t); return e ? e.sys.isVisible() : null; },
    isSleeping(t) { const e = this.getScene(t); return e ? e.sys.isSleeping() : null; },
    pause(t) { const e = this.getScene(t); return e && e.sys.pause(), this; },
    resume(t) { const e = this.getScene(t); return e && e.sys.resume(), this; },
    sleep(t) { const e = this.getScene(t); return e && !e.sys.isTransitioning() && e.sys.sleep(), this; },
    wake(t) { const e = this.getScene(t); return e && e.sys.wake(), this; },
    start(t, e) { if (!this.isBooted) return this._data[t] = { autoStart: !0, data: e }, this; const i = this.getScene(t); if (i) { let n; if (i.sys.start(e), i.sys.load && (n = i.sys.load), n && i.sys.settings.hasOwnProperty('pack') && (n.reset(), n.addPack({ payload: i.sys.settings.pack }))) return i.sys.settings.status = s.LOADING, n.once('complete', this.payloadComplete, this), n.start(), this; this.bootScene(i); } return this; },
    stop(t) { const e = this.getScene(t); return e && !e.sys.isTransitioning() && e.sys.shutdown(), this; },
    switch(t, e) { const i = this.getScene(t); const n = this.getScene(e); return i && n && i !== n && (this.sleep(t), this.isSleeping(e) ? this.wake(e) : this.start(e)), this; },
    getAt(t) { return this.scenes[t]; },
    getIndex(t) { const e = this.getScene(t); return this.scenes.indexOf(e); },
    bringToTop(t) { if (this.isProcessing) this._queue.push({ op: 'bringToTop', keyA: t, keyB: null }); else { const e = this.getIndex(t); if (e !== -1 && e < this.scenes.length) { const i = this.getScene(t); this.scenes.splice(e, 1), this.scenes.push(i); } } return this; },
    sendToBack(t) { if (this.isProcessing) this._queue.push({ op: 'sendToBack', keyA: t, keyB: null }); else { const e = this.getIndex(t); if (e !== -1 && e > 0) { const i = this.getScene(t); this.scenes.splice(e, 1), this.scenes.unshift(i); } } return this; },
    moveDown(t) { if (this.isProcessing) this._queue.push({ op: 'moveDown', keyA: t, keyB: null }); else { const e = this.getIndex(t); if (e > 0) { const i = e - 1; const n = this.getScene(t); const s = this.getAt(i); this.scenes[e] = s, this.scenes[i] = n; } } return this; },
    moveUp(t) { if (this.isProcessing) this._queue.push({ op: 'moveUp', keyA: t, keyB: null }); else { const e = this.getIndex(t); if (e < this.scenes.length - 1) { const i = e + 1; const n = this.getScene(t); const s = this.getAt(i); this.scenes[e] = s, this.scenes[i] = n; } } return this; },
    moveAbove(t, e) { if (t === e) return this; if (this.isProcessing) this._queue.push({ op: 'moveAbove', keyA: t, keyB: e }); else { const i = this.getIndex(t); const n = this.getIndex(e); if (i !== -1 && n !== -1) { const s = this.getAt(n); this.scenes.splice(n, 1), this.scenes.splice(i + 1, 0, s); } } return this; },
    moveBelow(t, e) { if (t === e) return this; if (this.isProcessing) this._queue.push({ op: 'moveBelow', keyA: t, keyB: e }); else { const i = this.getIndex(t); const n = this.getIndex(e); if (i !== -1 && n !== -1) { const s = this.getAt(n); this.scenes.splice(n, 1), i === 0 ? this.scenes.unshift(s) : this.scenes.splice(i, 0, s); } } return this; },
    queueOp(t, e, i) { return this._queue.push({ op: t, keyA: e, keyB: i }), this; },
    swapPosition(t, e) { if (t === e) return this; if (this.isProcessing) this._queue.push({ op: 'swapPosition', keyA: t, keyB: e }); else { const i = this.getIndex(t); const n = this.getIndex(e); if (i !== n && i !== -1 && n !== -1) { const s = this.getAt(i); this.scenes[i] = this.scenes[n], this.scenes[n] = s; } } return this; },
    dump() { for (var t = [], e = ['pending', 'init', 'start', 'loading', 'creating', 'running', 'paused', 'sleeping', 'shutdown', 'destroyed'], i = 0; i < this.scenes.length; i++) { const n = this.scenes[i].sys; let r = !n.settings.visible || n.settings.status !== s.RUNNING && n.settings.status !== s.PAUSED ? '[-] ' : '[*] '; r += `${n.settings.key} (${e[n.settings.status]})`, t.push(r); }console.log(t.join('\n')); },
    destroy() { for (let t = this.scenes.length - 1; t >= 0; t--) { this.scenes[t].sys.destroy(); } this.update = o, this.scenes = [], this._pending = [], this._start = [], this._queue = [], this.game = null; },
  }); t.exports = l;
}, function (t, e, i) { const n = i(55); t.exports = function (t, e, i, s) { let r; if (void 0 === s && (s = t), !Array.isArray(e)) return (r = t.indexOf(e)) !== -1 ? (n(t, r), i && i.call(s, e), e) : null; for (let o = e.length - 1; o >= 0;) { const a = e[o]; (r = t.indexOf(a)) !== -1 ? (n(t, r), i && i.call(s, a)) : e.pop(), o--; } return e; }; }, function (t, e, i) {
  const n = i(0); const s = i(9); const r = i(6); const o = i(13); const a = i(11); const h = i(1); const l = i(12); const u = i(187); const c = new n({
    Extends: s,
    initialize(t) { s.call(this), this.game = t, this.plugins = [], this.scenePlugins = [], this._pendingGlobal = [], this._pendingScene = [], t.isBooted ? this.boot() : t.events.once('boot', this.boot, this); },
    boot() { let t; let e; let i; let n; let s; let r; const o = this.game.config; let a = o.installGlobalPlugins; for (a = a.concat(this._pendingGlobal), t = 0; t < a.length; t++)e = a[t], i = h(e, 'key', null), n = h(e, 'plugin', null), s = h(e, 'start', !1), r = h(e, 'mapping', null), i && n && this.install(i, n, s, r); for (a = (a = o.installScenePlugins).concat(this._pendingScene), t = 0; t < a.length; t++)e = a[t], i = h(e, 'key', null), n = h(e, 'plugin', null), r = h(e, 'mapping', null), i && n && this.installScenePlugin(i, n, r); this._pendingGlobal = [], this._pendingScene = [], this.game.events.once('destroy', this.destroy, this); },
    addToScene(t, e, i) { let n; let s; let r; const o = this.game; const a = t.scene; const h = t.settings.map; const u = t.settings.isBooted; for (n = 0; n < e.length; n++)o[s = e[n]] && (t[s] = o[s], h.hasOwnProperty(s) && (a[h[s]] = t[s])); for (let c = 0; c < i.length; c++) for (r = i[c], n = 0; n < r.length; n++) if (s = r[n], l.hasCore(s)) { const d = l.getCore(s); const f = new d.plugin(a, this); t[d.mapping] = f, d.custom ? a[d.mapping] = f : h.hasOwnProperty(d.mapping) && (a[h[d.mapping]] = f), u && f.boot(); } for (r = this.plugins, n = 0; n < r.length; n++) { const p = r[n]; p.mapping && (a[p.mapping] = p.plugin); } },
    getDefaultScenePlugins() { let t = this.game.config.defaultPlugins; return t = t.concat(this.scenePlugins); },
    installScenePlugin(t, e, i, n) { if (typeof e === 'function') { if (l.hasCore(t))console.warn(`Scene Plugin key in use: ${t}`); else if (l.register(t, e, i, !0), this.scenePlugins.push(t), n) { const s = new e(n, this); n.sys[t] = s, i && i !== '' && (n[i] = s), s.boot(); } } else console.warn(`Invalid Scene Plugin: ${t}`); },
    install(t, e, i, n) {
      if (void 0 === i && (i = !1), void 0 === n && (n = null), typeof e === 'function') {
        if (l.hasCustom(t))console.warn(`Plugin key in use: ${t}`); else if (n !== null && (i = !0), console.log('install', t, i, n), this.game.isBooted) { if (l.registerCustom(t, e, n), i) return this.start(t); } else {
          this._pendingGlobal.push({
            key: t, plugin: e, start: i, mapping: n,
          });
        }
      } else console.warn(`Invalid Plugin: ${t}`);
    },
    getIndex(t) { for (let e = this.plugins, i = 0; i < e.length; i++) { if (e[i].key === t) return i; } return -1; },
    getEntry(t) { const e = this.getIndex(t); if (e !== -1) return this.plugins[e]; },
    isActive(t) { const e = this.getEntry(t); return e && e.active; },
    start(t, e) { void 0 === e && (e = t); let i = this.getEntry(e); return i && !i.active ? (i.active = !0, i.plugin.start()) : i || (i = this.createEntry(t, e)), i ? i.plugin : null; },
    createEntry(t, e) {
      let i = l.getCustom(t); if (i) {
        const n = new i.plugin(this); i = {
          key: e, plugin: n, active: !0, mapping: i.mapping,
        }, this.plugins.push(i), n.init(), n.start();
      } return i;
    },
    stop(t) { const e = this.getEntry(t); return e && e.active && (e.active = !1, e.plugin.stop()), this; },
    get(t, e) { void 0 === e && (e = !0); let i = this.getEntry(t); if (i) return i.plugin; const n = this.getClass(t); return n && e ? (i = this.createEntry(t, t)) ? i.plugin : null : n || null; },
    getClass(t) { return l.getCustomClass(t); },
    removeGlobalPlugin(t) { const e = this.getEntry(t); e && u(this.plugins, e), l.removeCustom(t); },
    removeScenePlugin(t) { u(this.scenePlugins, t), l.remove(t); },
    registerGameObject(t, e, i) { return e && a.register(t, e), i && o.register(t, i), this; },
    registerFileType(t, e, i) { r.register(t, e), i && i.sys.load && (i.sys.load[t] = e); },
    destroy() { for (let t = 0; t < this.plugins.length; t++) this.plugins[t].plugin.destroy(); this.game = null, this.plugins = [], this.scenePlugins = []; },
  }); t.exports = c;
}, function (t, e, i) {
  const n = new (i(0))({
    initialize(t) { this.manager = t, this.capture = !0, this.enabled = !1, this.target, this.handler; }, boot() { const t = this.manager.config; this.enabled = t.inputTouch, this.target = t.inputTouchEventTarget, this.capture = t.inputTouchCapture, this.target || (this.target = this.manager.game.canvas), this.enabled && this.startListeners(); }, startListeners() { let t; const e = this.manager.queue; const i = this.target; const n = { passive: !0 }; const s = { passive: !1 }; this.capture ? (t = function (t) { t.defaultPrevented || (e.push(t), t.preventDefault()); }, i.addEventListener('touchstart', t, s), i.addEventListener('touchmove', t, s), i.addEventListener('touchend', t, s)) : (t = function (t) { t.defaultPrevented || e.push(t); }, i.addEventListener('touchstart', t, n), i.addEventListener('touchmove', t, n), i.addEventListener('touchend', t, n)), this.handler = t; }, stopListeners() { const t = this.target; t.removeEventListener('touchstart', this.handler), t.removeEventListener('touchmove', this.handler), t.removeEventListener('touchend', this.handler); }, destroy() { this.stopListeners(), this.manager = null; },
  }); t.exports = n;
}, function (t, e, i) {
  const n = i(0); const s = i(7); const r = new n({
    initialize(t, e) { this.manager = t, this.id = e, this.event, this.camera = null, this.buttons = 0, this.position = new s(), this.downX = 0, this.downY = 0, this.downTime = 0, this.upX = 0, this.upY = 0, this.upTime = 0, this.primaryDown = !1, this.dragState = 0, this.isDown = !1, this.dirty = !1, this.justDown = !1, this.justUp = !1, this.justMoved = !1, this.wasTouch = !1, this.movementX = 0, this.movementY = 0; }, positionToCamera(t, e) { return t.getWorldPoint(this.x, this.y, e); }, x: { get() { return this.position.x; }, set(t) { this.position.x = t; } }, y: { get() { return this.position.y; }, set(t) { this.position.y = t; } }, reset() { this.dirty = !1, this.justDown = !1, this.justUp = !1, this.justMoved = !1, this.movementX = 0, this.movementY = 0; }, touchmove(t) { this.event = t, this.x = this.manager.transformX(t.changedTouches[0].pageX), this.y = this.manager.transformY(t.changedTouches[0].pageY), this.justMoved = !0, this.dirty = !0, this.wasTouch = !0; }, move(t) { t.buttons && (this.buttons = t.buttons), this.event = t, this.x = this.manager.transformX(t.pageX), this.y = this.manager.transformY(t.pageY), this.manager.mouse.locked && (this.movementX += t.movementX || t.mozMovementX || t.webkitMovementX || 0, this.movementY += t.movementY || t.mozMovementY || t.webkitMovementY || 0), this.justMoved = !0, this.dirty = !0, this.wasTouch = !1; }, down(t, e) { t.buttons && (this.buttons = t.buttons), this.event = t, this.x = this.manager.transformX(t.pageX), this.y = this.manager.transformY(t.pageY), t.button === 0 && (this.primaryDown = !0, this.downX = this.x, this.downY = this.y, this.downTime = e), this.justDown = !0, this.isDown = !0, this.dirty = !0, this.wasTouch = !1; }, touchstart(t, e) { this.buttons = 1, this.event = t, this.x = this.manager.transformX(t.changedTouches[0].pageX), this.y = this.manager.transformY(t.changedTouches[0].pageY), this.primaryDown = !0, this.downX = this.x, this.downY = this.y, this.downTime = e, this.justDown = !0, this.isDown = !0, this.dirty = !0, this.wasTouch = !0; }, up(t, e) { t.buttons && (this.buttons = t.buttons), this.event = t, this.x = this.manager.transformX(t.pageX), this.y = this.manager.transformY(t.pageY), t.button === 0 && (this.primaryDown = !1, this.upX = this.x, this.upY = this.y, this.upTime = e), this.justUp = !0, this.isDown = !1, this.dirty = !0, this.wasTouch = !1; }, touchend(t, e) { this.buttons = 0, this.event = t, this.x = this.manager.transformX(t.changedTouches[0].pageX), this.y = this.manager.transformY(t.changedTouches[0].pageY), this.primaryDown = !1, this.upX = this.x, this.upY = this.y, this.upTime = e, this.justUp = !0, this.isDown = !1, this.dirty = !0, this.wasTouch = !0; }, noButtonDown() { return this.buttons === 0; }, leftButtonDown() { return 1 & this.buttons; }, rightButtonDown() { return 2 & this.buttons; }, middleButtonDown() { return 4 & this.buttons; }, backButtonDown() { return 8 & this.buttons; }, forwardButtonDown() { return 16 & this.buttons; }, destroy() { this.camera = null, this.manager = null, this.position = null; },
  }); t.exports = r;
}, function (t, e, i) {
  const n = i(0); const s = i(118); const r = new n({
    initialize(t) { this.manager = t, this.capture = !0, this.enabled = !1, this.target, this.handler, this.locked = !1; }, boot() { const t = this.manager.config; this.enabled = t.inputMouse, this.target = t.inputMouseEventTarget, this.capture = t.inputMouseCapture, this.target || (this.target = this.manager.game.canvas), t.disableContextMenu && this.disableContextMenu(), this.enabled && this.startListeners(); }, disableContextMenu() { return document.body.addEventListener('contextmenu', (t) => (t.preventDefault(), !1)), this; }, requestPointerLock() { if (s.pointerLock) { const t = this.target; t.requestPointerLock = t.requestPointerLock || t.mozRequestPointerLock || t.webkitRequestPointerLock, t.requestPointerLock(); } }, pointerLockChange(t) { const e = this.target; this.locked = document.pointerLockElement === e || document.mozPointerLockElement === e || document.webkitPointerLockElement === e, this.manager.queue.push(t); }, releasePointerLock() { s.pointerLock && (document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock, document.exitPointerLock()); }, startListeners() { let t; const e = this.manager.queue; const i = this.target; const n = { passive: !0 }; const r = { passive: !1 }; this.capture ? (t = function (t) { t.defaultPrevented || (e.push(t), t.preventDefault()); }, i.addEventListener('mousemove', t, r), i.addEventListener('mousedown', t, r), i.addEventListener('mouseup', t, r)) : (t = function (t) { t.defaultPrevented || e.push(t); }, i.addEventListener('mousemove', t, n), i.addEventListener('mousedown', t, n), i.addEventListener('mouseup', t, n)), this.handler = t, s.pointerLock && (this.pointerLockChange = this.pointerLockChange.bind(this), document.addEventListener('pointerlockchange', this.pointerLockChange, !0), document.addEventListener('mozpointerlockchange', this.pointerLockChange, !0), document.addEventListener('webkitpointerlockchange', this.pointerLockChange, !0)); }, stopListeners() { const t = this.target; t.removeEventListener('mousemove', this.handler), t.removeEventListener('mousedown', this.handler), t.removeEventListener('mouseup', this.handler), s.pointerLock && (document.removeEventListener('pointerlockchange', this.pointerLockChange, !0), document.removeEventListener('mozpointerlockchange', this.pointerLockChange, !0), document.removeEventListener('webkitpointerlockchange', this.pointerLockChange, !0)); }, destroy() { this.stopListeners(), this.manager = null; },
  }); t.exports = r;
}, function (t, e, i) { const n = i(0); const s = i(1); const r = i(511); const o = i(509); const a = new n({ initialize(t, e, i) { if (void 0 === i && (i = {}), e.length < 2) return !1; this.manager = t, this.enabled = !0, this.keyCodes = []; for (let n = 0; n < e.length; n++) { const a = e[n]; typeof a === 'string' ? this.keyCodes.push(a.toUpperCase().charCodeAt(0)) : typeof a === 'number' ? this.keyCodes.push(a) : a.hasOwnProperty('keyCode') && this.keyCodes.push(a.keyCode); } this.current = this.keyCodes[0], this.index = 0, this.size = this.keyCodes.length, this.timeLastMatched = 0, this.matched = !1, this.timeMatched = 0, this.resetOnWrongKey = s(i, 'resetOnWrongKey', !0), this.maxKeyDelay = s(i, 'maxKeyDelay', 0), this.resetOnMatch = s(i, 'resetOnMatch', !1), this.deleteOnMatch = s(i, 'deleteOnMatch', !1); const h = this; const l = function (t) { !h.matched && h.enabled && (r(t, h) && (h.manager.emit('keycombomatch', h, t), h.resetOnMatch ? o(h) : h.deleteOnMatch && h.destroy())); }; this.onKeyDown = l, this.manager.on('keydown', l); }, progress: { get() { return this.index / this.size; } }, destroy() { this.enabled = !1, this.keyCodes = [], this.manager.off('keydown', this.onKeyDown), this.manager = void 0; } }); t.exports = a; }, function (t, e, i) { const n = new (i(0))({ initialize(t) { this.keyCode = t, this.originalEvent = void 0, this.preventDefault = !0, this.enabled = !0, this.isDown = !1, this.isUp = !0, this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.location = 0, this.timeDown = 0, this.duration = 0, this.timeUp = 0, this.repeats = 0, this._justDown = !1, this._justUp = !1; }, reset() { return this.preventDefault = !0, this.enabled = !0, this.isDown = !1, this.isUp = !0, this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.timeDown = 0, this.duration = 0, this.timeUp = 0, this.repeats = 0, this._justDown = !1, this._justUp = !1, this; } }); t.exports = n; }, function (t, e, i) {
  const n = i(0); const s = i(9); const r = i(193); const o = i(116); const a = i(192); const h = i(508); const l = i(507); const u = i(506); const c = new n({
    Extends: s,
    initialize(t) { s.call(this), this.manager = t, this.enabled = !1, this.target, this.keys = [], this.combos = [], this.captures = [], this.queue = [], this.handler; },
    boot() { const t = this.manager.config; this.enabled = t.inputKeyboard, this.target = t.inputKeyboardEventTarget, this.enabled && this.startListeners(); },
    startListeners() { const t = this.queue; const e = this.captures; const i = function (i) { i.defaultPrevented || (t.push(i), e[i.keyCode] && i.preventDefault()); }; this.handler = i, this.target.addEventListener('keydown', i, !1), this.target.addEventListener('keyup', i, !1); },
    stopListeners() { this.target.removeEventListener('keydown', this.handler), this.target.removeEventListener('keyup', this.handler); },
    createCursorKeys() {
      return this.addKeys({
        up: o.UP, down: o.DOWN, left: o.LEFT, right: o.RIGHT, space: o.SPACE, shift: o.SHIFT,
      });
    },
    addKeys(t) { const e = {}; for (const i in t)e[i] = this.addKey(t[i]); return e; },
    addKey(t) { const e = this.keys; return e[t] || (e[t] = new r(t), this.captures[t] = !0), e[t]; },
    removeKey(t) { this.keys[t] && (this.keys[t] = void 0, this.captures[t] = !1); },
    addKeyCapture(t) { Array.isArray(t) || (t = [t]); for (let e = 0; e < t.length; e++) this.captures[t[e]] = !0; },
    removeKeyCapture(t) { Array.isArray(t) || (t = [t]); for (let e = 0; e < t.length; e++) this.captures[t[e]] = !1; },
    createCombo(t, e) { return new a(this, t, e); },
    update() { const t = this.queue.length; if (this.enabled && t !== 0) for (let e = this.queue.splice(0, t), i = this.keys, n = 0; n < t; n++) { const s = e[n]; const r = s.keyCode; s.type === 'keydown' ? (!h[r] || void 0 !== i[r] && !1 !== i[r].isDown || (this.emit(s.type, s), this.emit(`keydown_${h[r]}`, s)), i[r] && l(i[r], s)) : (this.emit(s.type, s), this.emit(`keyup_${h[r]}`, s), i[r] && u(i[r], s)); } },
    shutdown() { this.removeAllListeners(); },
    destroy() { this.stopListeners(), this.removeAllListeners(), this.keys = [], this.combos = [], this.captures = [], this.queue = [], this.handler = void 0, this.manager = null; },
  }); t.exports = c;
}, function (t, e, i) { const n = new (i(0))({ initialize(t, e) { this.pad = t, this.events = t.manager, this.index = e, this.value = 0, this.threshold = 1, this.pressed = !1; }, update(t) { this.value = t.value, this.value >= this.threshold ? this.pressed || (this.pressed = !0, this.events.emit('down', this.pad, this, this.value, t)) : this.pressed && (this.pressed = !1, this.events.emit('up', this.pad, this, this.value, t)); } }); t.exports = n; }, function (t, e, i) { const n = new (i(0))({ initialize(t, e) { this.pad = t, this.events = t.events, this.index = e, this.value = 0, this.threshold = 0.1; }, update(t) { this.value = t; }, getValue() { return Math.abs(this.value) < this.threshold ? 0 : this.value; } }); t.exports = n; }, function (t, e, i) { const n = i(196); const s = i(195); const r = new (i(0))({ initialize(t, e, i) { this.manager = t, this.id = e, this.index = i, this.connected = !0, this.timestamp = 0, this.buttons = [], this.axes = []; }, update(t) { let e; this.timestamp = t.timestamp, this.connected = t.connected; const i = this.axes; const r = this.buttons; for (e = 0; e < t.buttons.length; e++) { const o = t.buttons[e]; void 0 === r[e] && (r[e] = new s(this, e)), r[e].update(o); } for (e = 0; e < t.axes.length; e++) { const a = t.axes[e]; void 0 === i[e] ? i[e] = new n(this, e) : i[e].update(a); } } }); t.exports = r; }, function (t, e, i) {
  const n = i(0); const s = i(9); const r = i(197); const o = new n({
    Extends: s, initialize(t) { s.call(this), this.manager = t, this.enabled = !1, this.target, this.handler, this.gamepads = [], this.queue = []; }, boot() { const t = this.manager.config; this.enabled = t.inputGamepad && this.manager.game.device.input.gamepads, this.target = window, this.enabled && this.startListeners(); }, startListeners() { const t = this.queue; const e = function (e) { e.defaultPrevented || t.push(e); }; this.handler = e; const i = this.target; i.addEventListener('gamepadconnected', e, !1), i.addEventListener('gamepaddisconnected', e, !1), i.addEventListener('gamepadbuttondown', e, !1), i.addEventListener('gamepadbuttonup', e, !1), i.addEventListener('gamepadaxismove', e, !1); }, stopListeners() { const t = this.target; const e = this.handler; t.removeEventListener('gamepadconnected', e), t.removeEventListener('gamepaddisconnected', e), t.removeEventListener('gamepadbuttondown', e), t.removeEventListener('gamepadbuttonup', e), t.removeEventListener('gamepadaxismove', e); }, disconnectAll() { for (let t = 0; t < this.gamepads.length; t++) this.gamepads.connected = !1; }, addPad(t) { const e = new r(this, t.id, t.index); return this.gamepads[t.index] = e, e; }, removePad() {}, refreshPads(t) { if (t) for (let e = 0; e < t.length; e++) { const i = t[e]; i && (void 0 === this.gamepads[i.index] && this.addPad(i), this.gamepads[i.index].update(i)); } else this.disconnectAll(); }, getAll() { for (var t = [], e = 0; e < this.gamepads.length; e++) this.gamepads[e] && t.push(this.gamepads[e]); return t; }, getPad(t) { for (let e = 0; e < this.gamepads.length; e++) if (this.gamepads[e].index === t) return this.gamepads[e]; }, update() { if (this.enabled) { this.refreshPads(navigator.getGamepads()); const t = this.queue.length; if (t !== 0) for (let e = this.queue.splice(0, t), i = 0; i < t; i++) { var n; const s = e[i]; switch (s.type) { case 'gamepadconnected': n = this.getPad(s.gamepad.index), this.emit('connected', n, s); break; case 'gamepaddisconnected': n = this.getPad(s.gamepad.index), this.emit('disconnected', n, s); } } } }, destroy() { this.stopListeners(), this.disconnectAll(), this.gamepads = []; }, total: { get() { return this.gamepads.length; } },
  }); t.exports = o;
}, function (t, e, i) {
  const n = i(0); const s = i(9); const r = i(198); const o = i(194); const a = i(191); const h = i(190); const l = i(14); const u = i(189); const c = i(63); const d = i(256); const f = new n({
    initialize(t, e) { this.game = t, this.canvas, this.config = e, this.enabled = !0, this.events = new s(), this.queue = [], this.keyboard = new o(this), this.mouse = new a(this), this.touch = new u(this), this.gamepad = new r(this), this.activePointer = new h(this, 0), this.scale = { x: 1, y: 1 }, this.globalTopOnly = !0, this.ignoreEvents = !1, this.bounds = new l(), this._tempPoint = { x: 0, y: 0 }, this._tempHitTest = [], this._tempMatrix = new c(), t.events.once('boot', this.boot, this); }, boot() { this.canvas = this.game.canvas, this.updateBounds(), this.keyboard.boot(), this.mouse.boot(), this.touch.boot(), this.gamepad.boot(), this.game.events.on('prestep', this.update, this), this.game.events.once('destroy', this.destroy, this); }, updateBounds() { const t = this.bounds; const e = this.canvas.getBoundingClientRect(); t.x = e.left + window.pageXOffset - document.documentElement.clientLeft, t.y = e.top + window.pageYOffset - document.documentElement.clientTop, t.width = e.width, t.height = e.height; }, resize() { this.updateBounds(); const t = this.game.config.width; const e = this.game.config.height; const i = this.bounds.width; const n = this.bounds.height; this.scale.x = t / i, this.scale.y = e / n; }, update(t) { this.keyboard.update(), this.gamepad.update(), this.ignoreEvents = !1; const e = this.queue.length; const i = this.activePointer; if (i.reset(), this.enabled && e !== 0) { this.updateBounds(), this.scale.x = this.game.config.width / this.bounds.width, this.scale.y = this.game.config.height / this.bounds.height; for (let n = this.queue.splice(0, e), s = 0; s < e; s++) { const r = n[s]; switch (r.type) { case 'mousemove': i.move(r, t); break; case 'mousedown': i.down(r, t); break; case 'mouseup': i.up(r, t); break; case 'touchmove': i.touchmove(r, t); break; case 'touchstart': i.touchstart(r, t); break; case 'touchend': i.touchend(r, t); break; case 'pointerlockchange': this.events.emit('pointerlockchange', r, this.mouse.locked); } } } }, hitTest(t, e, i, n, s) { void 0 === s && (s = this._tempHitTest); const r = this._tempPoint; const o = n.width; const a = n.height; if (s.length = 0, !(t >= n.x && e >= n.y && t <= n.x + o && e <= n.y + a)) return s; n.getWorldPoint(t, e, r); for (let h = n.cull(i), l = { x: 0, y: 0 }, u = this.game.config.resolution, c = this._tempMatrix, f = 0; f < h.length; f++) { const p = h[f]; if (p.input && p.input.enabled && p.willRender()) { const g = r.x * u + n.scrollX * p.scrollFactorX - n.scrollX; const v = r.y * u + n.scrollY * p.scrollFactorY - n.scrollY; p.parentContainer ? (p.getWorldTransformMatrix(c), d(g, v, c.tx, c.ty, c.rotation, c.scaleX, c.scaleY, l)) : d(g, v, p.x, p.y, p.rotation, p.scaleX, p.scaleY, l), this.pointWithinHitArea(p, l.x, l.y) && s.push(p); } } return s; }, pointWithinHitArea(t, e, i) { const n = t.input; return e += t.displayOriginX, i += t.displayOriginY, !!n.hitAreaCallback(n.hitArea, e, i, t) && (n.localX = e, n.localY = i, !0); }, pointWithinInteractiveObject(t, e, i) { return !!t.hitArea && (e += t.gameObject.displayOriginX, i += t.gameObject.displayOriginY, t.localX = e, t.localY = i, t.hitAreaCallback(t.hitArea, e, i, t)); }, transformX(t) { return (t - this.bounds.left) * this.scale.x; }, transformY(t) { return (t - this.bounds.top) * this.scale.y; }, getOffsetX() { return this.bounds.left; }, getOffsetY() { return this.bounds.top; }, getScaleX() { return this.game.config.width / this.bounds.width; }, getScaleY() { return this.game.config.height / this.bounds.height; }, destroy() { this.events.removeAllListeners(), this.keyboard.destroy(), this.mouse.destroy(), this.touch.destroy(), this.gamepad.destroy(), this.activePointer.destroy(), this.queue = [], this.game = null; },
  }); t.exports = f;
}, function (t, e) {
  const i = {
    modelMatrixDirty: !1, viewMatrixDirty: !1, projectionMatrixDirty: !1, modelMatrix: null, viewMatrix: null, projectionMatrix: null, mvpInit() { return this.modelMatrixDirty = !0, this.viewMatrixDirty = !0, this.projectionMatrixDirty = !0, this.modelMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this.viewMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this.projectionMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this; }, mvpUpdate() { const t = this.program; return this.modelMatrixDirty && (this.renderer.setMatrix4(t, 'uModelMatrix', !1, this.modelMatrix), this.modelMatrixDirty = !1), this.viewMatrixDirty && (this.renderer.setMatrix4(t, 'uViewMatrix', !1, this.viewMatrix), this.viewMatrixDirty = !1), this.projectionMatrixDirty && (this.renderer.setMatrix4(t, 'uProjectionMatrix', !1, this.projectionMatrix), this.projectionMatrixDirty = !1), this; }, modelIdentity() { const t = this.modelMatrix; return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this.modelMatrixDirty = !0, this; }, modelScale(t, e, i) { const n = this.modelMatrix; return n[0] *= t, n[1] *= t, n[2] *= t, n[3] *= t, n[4] *= e, n[5] *= e, n[6] *= e, n[7] *= e, n[8] *= i, n[9] *= i, n[10] *= i, n[11] *= i, this.modelMatrixDirty = !0, this; }, modelTranslate(t, e, i) { const n = this.modelMatrix; return n[12] = n[0] * t + n[4] * e + n[8] * i + n[12], n[13] = n[1] * t + n[5] * e + n[9] * i + n[13], n[14] = n[2] * t + n[6] * e + n[10] * i + n[14], n[15] = n[3] * t + n[7] * e + n[11] * i + n[15], this.modelMatrixDirty = !0, this; }, modelRotateX(t) { const e = this.modelMatrix; const i = Math.sin(t); const n = Math.cos(t); const s = e[4]; const r = e[5]; const o = e[6]; const a = e[7]; const h = e[8]; const l = e[9]; const u = e[10]; const c = e[11]; return e[4] = s * n + h * i, e[5] = r * n + l * i, e[6] = o * n + u * i, e[7] = a * n + c * i, e[8] = h * n - s * i, e[9] = l * n - r * i, e[10] = u * n - o * i, e[11] = c * n - a * i, this.modelMatrixDirty = !0, this; }, modelRotateY(t) { const e = this.modelMatrix; const i = Math.sin(t); const n = Math.cos(t); const s = e[0]; const r = e[1]; const o = e[2]; const a = e[3]; const h = e[8]; const l = e[9]; const u = e[10]; const c = e[11]; return e[0] = s * n - h * i, e[1] = r * n - l * i, e[2] = o * n - u * i, e[3] = a * n - c * i, e[8] = s * i + h * n, e[9] = r * i + l * n, e[10] = o * i + u * n, e[11] = a * i + c * n, this.modelMatrixDirty = !0, this; }, modelRotateZ(t) { const e = this.modelMatrix; const i = Math.sin(t); const n = Math.cos(t); const s = e[0]; const r = e[1]; const o = e[2]; const a = e[3]; const h = e[4]; const l = e[5]; const u = e[6]; const c = e[7]; return e[0] = s * n + h * i, e[1] = r * n + l * i, e[2] = o * n + u * i, e[3] = a * n + c * i, e[4] = h * n - s * i, e[5] = l * n - r * i, e[6] = u * n - o * i, e[7] = c * n - a * i, this.modelMatrixDirty = !0, this; }, viewIdentity() { const t = this.viewMatrix; return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this.viewMatrixDirty = !0, this; }, viewScale(t, e, i) { const n = this.viewMatrix; return n[0] *= t, n[1] *= t, n[2] *= t, n[3] *= t, n[4] *= e, n[5] *= e, n[6] *= e, n[7] *= e, n[8] *= i, n[9] *= i, n[10] *= i, n[11] *= i, this.viewMatrixDirty = !0, this; }, viewTranslate(t, e, i) { const n = this.viewMatrix; return n[12] = n[0] * t + n[4] * e + n[8] * i + n[12], n[13] = n[1] * t + n[5] * e + n[9] * i + n[13], n[14] = n[2] * t + n[6] * e + n[10] * i + n[14], n[15] = n[3] * t + n[7] * e + n[11] * i + n[15], this.viewMatrixDirty = !0, this; }, viewRotateX(t) { const e = this.viewMatrix; const i = Math.sin(t); const n = Math.cos(t); const s = e[4]; const r = e[5]; const o = e[6]; const a = e[7]; const h = e[8]; const l = e[9]; const u = e[10]; const c = e[11]; return e[4] = s * n + h * i, e[5] = r * n + l * i, e[6] = o * n + u * i, e[7] = a * n + c * i, e[8] = h * n - s * i, e[9] = l * n - r * i, e[10] = u * n - o * i, e[11] = c * n - a * i, this.viewMatrixDirty = !0, this; }, viewRotateY(t) { const e = this.viewMatrix; const i = Math.sin(t); const n = Math.cos(t); const s = e[0]; const r = e[1]; const o = e[2]; const a = e[3]; const h = e[8]; const l = e[9]; const u = e[10]; const c = e[11]; return e[0] = s * n - h * i, e[1] = r * n - l * i, e[2] = o * n - u * i, e[3] = a * n - c * i, e[8] = s * i + h * n, e[9] = r * i + l * n, e[10] = o * i + u * n, e[11] = a * i + c * n, this.viewMatrixDirty = !0, this; }, viewRotateZ(t) { const e = this.viewMatrix; const i = Math.sin(t); const n = Math.cos(t); const s = e[0]; const r = e[1]; const o = e[2]; const a = e[3]; const h = e[4]; const l = e[5]; const u = e[6]; const c = e[7]; return e[0] = s * n + h * i, e[1] = r * n + l * i, e[2] = o * n + u * i, e[3] = a * n + c * i, e[4] = h * n - s * i, e[5] = l * n - r * i, e[6] = u * n - o * i, e[7] = c * n - a * i, this.viewMatrixDirty = !0, this; }, viewLoad2D(t) { const e = this.viewMatrix; return e[0] = t[0], e[1] = t[1], e[2] = 0, e[3] = 0, e[4] = t[2], e[5] = t[3], e[6] = 0, e[7] = 0, e[8] = t[4], e[9] = t[5], e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this.viewMatrixDirty = !0, this; }, viewLoad(t) { const e = this.viewMatrix; return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], this.viewMatrixDirty = !0, this; }, projIdentity() { const t = this.projectionMatrix; return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this.projectionMatrixDirty = !0, this; }, projOrtho(t, e, i, n, s, r) { const o = this.projectionMatrix; const a = 1 / (t - e); const h = 1 / (i - n); const l = 1 / (s - r); return o[0] = -2 * a, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = -2 * h, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = 2 * l, o[11] = 0, o[12] = (t + e) * a, o[13] = (n + i) * h, o[14] = (r + s) * l, o[15] = 1, this.projectionMatrixDirty = !0, this; }, projPersp(t, e, i, n) { const s = this.projectionMatrix; const r = 1 / Math.tan(t / 2); const o = 1 / (i - n); return s[0] = r / e, s[1] = 0, s[2] = 0, s[3] = 0, s[4] = 0, s[5] = r, s[6] = 0, s[7] = 0, s[8] = 0, s[9] = 0, s[10] = (n + i) * o, s[11] = -1, s[12] = 0, s[13] = 0, s[14] = 2 * n * i * o, s[15] = 0, this.projectionMatrixDirty = !0, this; },
  }; t.exports = i;
}, function (t, e, i) { let n; let s; let r; const o = i(22); const a = { supportInverseAlpha: !1, supportNewBlendModes: !1 }; t.exports = (void 0 !== document && (a.supportNewBlendModes = (n = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/', s = 'AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==', (r = new Image()).onload = function () { const t = new Image(); t.onload = function () { const e = o.create(t, 6, 1).getContext('2d'); if (e.globalCompositeOperation = 'multiply', e.drawImage(r, 0, 0), e.drawImage(t, 2, 0), !e.getImageData(2, 0, 1, 1)) return !1; const i = e.getImageData(2, 0, 1, 1).data; o.remove(t), a.supportNewBlendModes = i[0] === 255 && i[1] === 0 && i[2] === 0; }, t.src = `${n}/wCKxvRF${s}`; }, r.src = `${n}AP804Oa6${s}`, !1), a.supportInverseAlpha = (function () { const t = o.create(this, 2, 1).getContext('2d'); t.fillStyle = 'rgba(10, 20, 30, 0.5)', t.fillRect(0, 0, 1, 1); const e = t.getImageData(0, 0, 1, 1); if (e === null) return !1; t.putImageData(e, 1, 0); const i = t.getImageData(1, 0, 1, 1); return i.data[0] === e.data[0] && i.data[1] === e.data[1] && i.data[2] === e.data[2] && i.data[3] === e.data[3]; }())), a); }, function (t, e, i) { t.exports = { Fade: i(558), Flash: i(557), Shake: i(556) }; }, function (t, e, i) { const n = i(204); const s = new (i(0))({ initialize(t) { this.game = t, this.binary = new n(), this.bitmapFont = new n(), this.json = new n(), this.physics = new n(), this.shader = new n(), this.audio = new n(), this.text = new n(), this.obj = new n(), this.tilemap = new n(), this.xml = new n(), this.custom = {}, this.game.events.once('destroy', this.destroy, this); }, addCustom(t) { return this.custom.hasOwnProperty(t) || (this.custom[t] = new n()), this.custom[t]; }, destroy() { for (let t = ['binary', 'bitmapFont', 'json', 'physics', 'shader', 'audio', 'text', 'obj', 'tilemap', 'xml'], e = 0; e < t.length; e++) this[t[e]].destroy(), this[t[e]] = null; for (const i in this.custom) this.custom[i].destroy(); this.custom = null, this.game = null; } }); t.exports = s; }, function (t, e, i) {
  const n = i(0); const s = i(122); const r = i(9); const o = new n({
    initialize() { this.entries = new s(), this.events = new r(); }, add(t, e) { return this.entries.set(t, e), this.events.emit('add', this, t, e), this; }, has(t) { return this.entries.has(t); }, exists(t) { return this.entries.has(t); }, get(t) { return this.entries.get(t); }, remove(t) { const e = this.get(t); return e && (this.entries.delete(t), this.events.emit('remove', this, t, e.data)), this; }, destroy() { this.entries.clear(), this.events.removeAllListeners(), this.entries = null, this.events = null; },
  }); t.exports = o;
}, function (t, e, i) {
  const n = i(208); const s = i(0); const r = i(122); const o = i(9); const a = i(4); const h = i(130); const l = new s({
    Extends: o, initialize(t) { o.call(this), this.game = t, this.textureManager = null, this.globalTimeScale = 1, this.anims = new r(), this.paused = !1, this.name = 'AnimationManager', t.events.once('boot', this.boot, this); }, boot() { this.textureManager = this.game.textures, this.game.events.once('destroy', this.destroy, this); }, add(t, e) { if (!this.anims.has(t)) return e.key = t, this.anims.set(t, e), this.emit('add', t, e), this; console.warn('Animation with key', t, 'already exists'); }, create(t) { const e = t.key; if (e && !this.anims.has(e)) { const i = new n(this, e, t); return this.anims.set(e, i), this.emit('add', e, i), i; }console.warn(`Invalid Animation Key, or Key already in use: ${e}`); }, fromJSON(t, e) { void 0 === e && (e = !1), e && this.anims.clear(), typeof t === 'string' && (t = JSON.parse(t)); const i = []; if (t.hasOwnProperty('anims') && Array.isArray(t.anims)) { for (let n = 0; n < t.anims.length; n++)i.push(this.create(t.anims[n])); t.hasOwnProperty('globalTimeScale') && (this.globalTimeScale = t.globalTimeScale); } else t.hasOwnProperty('key') && t.type === 'frame' && i.push(this.create(t)); return i; }, generateFrameNames(t, e) { const i = a(e, 'prefix', ''); const n = a(e, 'start', 0); let s = a(e, 'end', 0); const r = a(e, 'suffix', ''); const o = a(e, 'zeroPad', 0); const l = a(e, 'outputArray', []); let u = a(e, 'frames', !1); const c = this.textureManager.get(t); if (!c) return l; let d; let f; const p = n < s ? 1 : -1; if (s += p, e) if (Array.isArray(u)) for (d = 0; d < u.length; d++)f = i + h(u[d], o, '0', 1) + r, c.has(f) && l.push({ key: t, frame: f }); else for (d = n; d !== s; d += p)f = i + h(d, o, '0', 1) + r, c.has(f) && l.push({ key: t, frame: f }); else for (u = c.getFrameNames(), d = 0; d < u.length; d++)l.push({ key: t, frame: u[d] }); return l; }, generateFrameNumbers(t, e) { let i; const n = a(e, 'start', 0); let s = a(e, 'end', -1); const r = a(e, 'first', !1); const o = a(e, 'outputArray', []); const h = a(e, 'frames', !1); const l = this.textureManager.get(t); if (!l) return o; if (r && l.has(r) && o.push({ key: t, frame: r }), Array.isArray(h)) for (i = 0; i < h.length; i++)l.has(h[i]) && o.push({ key: t, frame: h[i] }); else for (s === -1 && (s = l.frameTotal), i = n; i <= s; i++)l.has(i) && o.push({ key: t, frame: i }); return o; }, get(t) { return this.anims.get(t); }, load(t, e, i) { const n = this.get(e); return n && n.load(t, i), t; }, pauseAll() { return this.paused || (this.paused = !0, this.emit('pauseall')), this; }, play(t, e) { if (Array.isArray(e) || (e = [e]), this.get(t)) { for (let i = 0; i < e.length; i++)e[i].anims.play(t); return this; } }, remove(t) { const e = this.get(t); return e && (this.emit('remove', t, e), this.anims.delete(t)), e; }, resumeAll() { return this.paused && (this.paused = !1, this.emit('resumeall')), this; }, staggerPlay(t, e, i) { if (void 0 === i && (i = 0), Array.isArray(e) || (e = [e]), this.get(t)) { for (let n = 0; n < e.length; n++)e[n].anims.delayedPlay(i * n, t); return this; } }, toJSON(t) { if (void 0 !== t && t !== '') return this.anims.get(t).toJSON(); const e = { anims: [], globalTimeScale: this.globalTimeScale }; return this.anims.each((t, i) => { e.anims.push(i.toJSON()); }), e; }, destroy() { this.anims.clear(), this.textureManager = null, this.game = null; },
  }); t.exports = l;
}, function (t, e, i) { const n = new (i(0))({ initialize(t, e, i, n) { this.textureKey = t, this.textureFrame = e, this.index = i, this.frame = n, this.isFirst = !1, this.isLast = !1, this.prevFrame = null, this.nextFrame = null, this.duration = 0, this.progress = 0; }, toJSON() { return { key: this.textureKey, frame: this.textureFrame, duration: this.duration }; }, destroy() { this.frame = void 0; } }); t.exports = n; }, function (t, e) { t.exports = function (t, e, i) { if (!e.length) return NaN; if (e.length === 1) return e[0]; let n; let s; let r = 1; if (i) { if (t < e[0][i]) return e[0]; for (;e[r][i] < t;)r++; } else for (;e[r] < t;)r++; return r > e.length && (r = e.length), i ? (n = e[r - 1][i], (s = e[r][i]) - t <= t - n ? e[r] : e[r - 1]) : (n = e[r - 1], (s = e[r]) - t <= t - n ? s : n); }; }, function (t, e, i) {
  const n = i(23); const s = i(0); const r = i(207); const o = i(206); const a = i(4); const h = new s({
    initialize(t, e, i) { this.manager = t, this.key = e, this.type = 'frame', this.frames = this.getFrames(t.textureManager, a(i, 'frames', []), a(i, 'defaultTextureKey', null)), this.frameRate = a(i, 'frameRate', null), this.duration = a(i, 'duration', null), this.duration === null && this.frameRate === null ? (this.frameRate = 24, this.duration = this.frameRate / this.frames.length * 1e3) : this.duration && this.frameRate === null ? this.frameRate = this.frames.length / (this.duration / 1e3) : this.duration = this.frames.length / this.frameRate * 1e3, this.msPerFrame = 1e3 / this.frameRate, this.skipMissedFrames = a(i, 'skipMissedFrames', !0), this.delay = a(i, 'delay', 0), this.repeat = a(i, 'repeat', 0), this.repeatDelay = a(i, 'repeatDelay', 0), this.yoyo = a(i, 'yoyo', !1), this.showOnStart = a(i, 'showOnStart', !1), this.hideOnComplete = a(i, 'hideOnComplete', !1), this.paused = !1, this.manager.on('pauseall', this.pause, this), this.manager.on('resumeall', this.resume, this); },
    addFrame(t) { return this.addFrameAt(this.frames.length, t); },
    addFrameAt(t, e) { const i = this.getFrames(this.manager.textureManager, e); if (i.length > 0) { if (t === 0) this.frames = i.concat(this.frames); else if (t === this.frames.length) this.frames = this.frames.concat(i); else { const n = this.frames.slice(0, t); const s = this.frames.slice(t); this.frames = n.concat(i, s); } this.updateFrameSequence(); } return this; },
    checkFrame(t) { return t >= 0 && t < this.frames.length; },
    completeAnimation(t) { this.hideOnComplete && (t.parent.visible = !1), t.stop(); },
    getFirstTick(t, e) { void 0 === e && (e = !0), t.accumulator = 0, t.nextTick = t.msPerFrame + t.currentFrame.duration, e && (t.nextTick += t._delay); },
    getFrameAt(t) { return this.frames[t]; },
    getFrames(t, e, i) { let n; let s; let r; let h; const l = []; let u = 1; if (typeof e === 'string') { h = e; const c = t.get(h).getFrameNames(); e = [], c.forEach((t, i) => { e.push({ key: h, frame: i }); }); } if (!Array.isArray(e) || e.length === 0) return l; for (r = 0; r < e.length; r++) { const d = e[r]; const f = a(d, 'key', i); if (f) { const p = a(d, 'frame', 0); const g = t.getFrame(f, p); (s = new o(f, p, u, g)).duration = a(d, 'duration', 0), s.isFirst = !n, n && (n.nextFrame = s, s.prevFrame = n), l.push(s), n = s, u++; } } if (l.length > 0) { s.isLast = !0, s.nextFrame = l[0], l[0].prevFrame = s; const v = 1 / (l.length - 1); for (r = 0; r < l.length; r++)l[r].progress = r * v; } return l; },
    getNextTick(t) { t.accumulator -= t.nextTick, t.nextTick = t.msPerFrame + t.currentFrame.duration; },
    load(t, e) { e >= this.frames.length && (e = 0), t.currentAnim !== this && (t.currentAnim = this, t.frameRate = this.frameRate, t.duration = this.duration, t.msPerFrame = this.msPerFrame, t.skipMissedFrames = this.skipMissedFrames, t._timeScale = 1, t._delay = this.delay, t._repeat = this.repeat, t._repeatDelay = this.repeatDelay, t._yoyo = this.yoyo), t.updateFrame(this.frames[e]); },
    getFrameByProgress(t) { return t = n(t, 0, 1), r(t, this.frames, 'progress'); },
    nextFrame(t) { const e = t.currentFrame; e.isLast ? t._yoyo ? (t.forward = !1, t.updateFrame(e.prevFrame), this.getNextTick(t)) : t.repeatCounter > 0 ? this.repeatAnimation(t) : this.completeAnimation(t) : (t.updateFrame(e.nextFrame), this.getNextTick(t)); },
    previousFrame(t) { const e = t.currentFrame; e.isFirst ? t.repeatCounter > 0 ? this.repeatAnimation(t) : this.completeAnimation(t) : (t.updateFrame(e.prevFrame), this.getNextTick(t)); },
    removeFrame(t) { const e = this.frames.indexOf(t); return e !== -1 && this.removeFrameAt(e), this; },
    removeFrameAt(t) { return this.frames.splice(t, 1), this.updateFrameSequence(), this; },
    repeatAnimation(t) { if (t._pendingStop === 2) return this.completeAnimation(t); t._repeatDelay > 0 && !1 === t.pendingRepeat ? (t.pendingRepeat = !0, t.accumulator -= t.nextTick, t.nextTick += t._repeatDelay) : (t.repeatCounter--, t.forward = !0, t.updateFrame(t.currentFrame.nextFrame), t.isPlaying && (this.getNextTick(t), t.pendingRepeat = !1, t.parent.emit('animationrepeat', this, t.currentFrame, t.repeatCounter))); },
    setFrame(t) { t.forward ? this.nextFrame(t) : this.previousFrame(t); },
    toJSON() {
      const t = {
        key: this.key, type: this.type, frames: [], frameRate: this.frameRate, duration: this.duration, skipMissedFrames: this.skipMissedFrames, delay: this.delay, repeat: this.repeat, repeatDelay: this.repeatDelay, yoyo: this.yoyo, showOnStart: this.showOnStart, hideOnComplete: this.hideOnComplete,
      }; return this.frames.forEach((e) => { t.frames.push(e.toJSON()); }), t;
    },
    updateFrameSequence() { for (let t = this.frames.length, e = 1 / (t - 1), i = 0; i < t; i++) { const n = this.frames[i]; n.index = i + 1, n.isFirst = !1, n.isLast = !1, n.progress = i * e, i === 0 ? (n.isFirst = !0, n.isLast = t === 1, n.prevFrame = this.frames[t - 1], n.nextFrame = this.frames[i + 1]) : i === t - 1 ? (n.isLast = !0, n.prevFrame = this.frames[t - 2], n.nextFrame = this.frames[0]) : t > 1 && (n.prevFrame = this.frames[i - 1], n.nextFrame = this.frames[i + 1]); } return this; },
    pause() { return this.paused = !0, this; },
    resume() { return this.paused = !1, this; },
    destroy() { this.manager.off('pauseall', this.pause, this), this.manager.off('resumeall', this.resume, this), this.manager.remove(this.key); for (let t = 0; t < this.frames.length; t++) this.frames[t].destroy(); this.frames = [], this.manager = null; },
  }); t.exports = h;
}, function (t, e, i) { const n = i(39); t.exports = function (t) { return n(t, -180, 180); }; }, function (t, e, i) { const n = i(39); t.exports = function (t) { return n(t, -Math.PI, Math.PI); }; }, function (t, e, i) {
  const n = new (i(0))({
    initialize(t, e) { this.geometryMask = e; }, setShape(t) { this.geometryMask = t; }, preRenderWebGL(t, e, i) { const n = t.gl; const s = this.geometryMask; t.flush(), n.enable(n.STENCIL_TEST), n.clear(n.STENCIL_BUFFER_BIT), n.colorMask(!1, !1, !1, !1), n.stencilFunc(n.NOTEQUAL, 1, 1), n.stencilOp(n.REPLACE, n.REPLACE, n.REPLACE), s.renderWebGL(t, s, 0, i), t.flush(), n.colorMask(!0, !0, !0, !0), n.stencilFunc(n.EQUAL, 1, 1), n.stencilOp(n.INVERT, n.INVERT, n.INVERT); }, postRenderWebGL(t) { const e = t.gl; t.flush(), e.disable(e.STENCIL_TEST); }, preRenderCanvas(t, e, i) { const n = this.geometryMask; t.currentContext.save(), n.renderCanvas(t, n, 0, i, void 0, null, !0), t.currentContext.clip(); }, postRenderCanvas(t) { t.currentContext.restore(); }, destroy() { this.geometryMask = null; },
  }); t.exports = n;
}, function (t, e, i) {
  const n = new (i(0))({
    initialize(t, e) { const i = t.sys.game.renderer; if (this.bitmapMask = e, this.maskTexture = null, this.mainTexture = null, this.dirty = !0, this.mainFramebuffer = null, this.maskFramebuffer = null, this.invertAlpha = !1, i && i.gl) { const n = i.width; const s = i.height; const r = (n & n - 1) == 0 && (s & s - 1) == 0; const o = i.gl; const a = r ? o.REPEAT : o.CLAMP_TO_EDGE; const h = o.LINEAR; this.mainTexture = i.createTexture2D(0, h, h, a, a, o.RGBA, null, n, s), this.maskTexture = i.createTexture2D(0, h, h, a, a, o.RGBA, null, n, s), this.mainFramebuffer = i.createFramebuffer(n, s, this.mainTexture, !1), this.maskFramebuffer = i.createFramebuffer(n, s, this.maskTexture, !1), i.onContextRestored(function (t) { const e = t.width; const i = t.height; const n = (e & e - 1) == 0 && (i & i - 1) == 0; const s = t.gl; const r = n ? s.REPEAT : s.CLAMP_TO_EDGE; const o = s.LINEAR; this.mainTexture = t.createTexture2D(0, o, o, r, r, s.RGBA, null, e, i), this.maskTexture = t.createTexture2D(0, o, o, r, r, s.RGBA, null, e, i), this.mainFramebuffer = t.createFramebuffer(e, i, this.mainTexture, !1), this.maskFramebuffer = t.createFramebuffer(e, i, this.maskTexture, !1); }, this); } }, setBitmap(t) { this.bitmapMask = t; }, preRenderWebGL(t, e, i) { t.pipelines.BitmapMaskPipeline.beginMask(this, e, i); }, postRenderWebGL(t) { t.pipelines.BitmapMaskPipeline.endMask(this); }, preRenderCanvas() {}, postRenderCanvas() {}, destroy() { this.bitmapMask = null, this.mainTexture = null, this.maskTexture = null, this.mainFramebuffer = null, this.maskFramebuffer = null; },
  }); t.exports = n;
}, function (t, e) { let i; i = (function () { return this; }()); try { i = i || Function('return this')() || (0, eval)('this'); } catch (t) { typeof window === 'object' && (i = window); }t.exports = i; }, function (t, e, i) {
  const n = i(26); const s = i(102); const r = i(319); const o = i(311); t.exports = function (t, e, i, a, h, l, u, c) {
    void 0 === i && (i = 32), void 0 === a && (a = 32), void 0 === h && (h = 10), void 0 === l && (l = 10), void 0 === c && (c = !1); let d = null; if (Array.isArray(u))d = r(void 0 !== e ? e : 'map', n.ARRAY_2D, u, i, a, c); else if (void 0 !== e) { const f = t.cache.tilemap.get(e); f ? d = r(e, f.format, f.data, i, a, c) : console.warn(`No map data found for key ${e}`); } return d === null && (d = new s({
      tileWidth: i, tileHeight: a, width: h, height: l,
    })), new o(t, d);
  };
}, function (t, e, i) {
  const n = i(26); const s = i(103); const r = i(102); const o = i(65); t.exports = function (t, e, i, a, h) {
    for (var l = new s({ tileWidth: i, tileHeight: a }), u = new r({
        name: t, tileWidth: i, tileHeight: a, format: n.ARRAY_2D, layers: [l],
      }), c = [], d = e.length, f = 0, p = 0; p < e.length; p++) { c[p] = []; for (var g = e[p], v = 0; v < g.length; v++) { const y = parseInt(g[v], 10); Number.isNaN(y) || y === -1 ? c[p][v] = h ? null : new o(l, -1, v, p, i, a) : c[p][v] = new o(l, y, v, p, i, a); }f === 0 && (f = g.length); } return u.width = l.width = f, u.height = l.height = d, u.widthInPixels = l.widthInPixels = f * i, u.heightInPixels = l.heightInPixels = d * a, l.data = c, u;
  };
}, function (t, e) { t.exports = function (t, e, i) { const n = i.collideIndexes.indexOf(t); e && n === -1 ? i.collideIndexes.push(t) : e || n === -1 || i.collideIndexes.splice(n, 1); }; }, function (t, e, i) { const n = i(65); const s = i(104); const r = i(218); const o = i(66); t.exports = function (t, e, i, a, h) { if (!s(e, i, h)) return null; void 0 === a && (a = !0); const l = h.data[i][e]; const u = l && l.collides; if (t instanceof n)h.data[i][e] === null && (h.data[i][e] = new n(h, t.index, e, i, t.width, t.height)), h.data[i][e].copy(t); else { const c = t; h.data[i][e] === null ? h.data[i][e] = new n(h, c, e, i, h.tileWidth, h.tileHeight) : h.data[i][e].index = c; } const d = h.data[i][e]; const f = h.collideIndexes.indexOf(d.index) !== -1; return o(d, f), a && u !== d.collides && r(e, i, h), d; }; }, function (t, e, i) { const n = i(137); t.exports = function (t, e, i) { const s = n(t, e, !0, i); const r = n(t, e - 1, !0, i); const o = n(t, e + 1, !0, i); const a = n(t - 1, e, !0, i); const h = n(t + 1, e, !0, i); const l = s && s.collides; return l && (s.faceTop = !0, s.faceBottom = !0, s.faceLeft = !0, s.faceRight = !0), r && r.collides && (l && (s.faceTop = !1), r.faceBottom = !l), o && o.collides && (l && (s.faceBottom = !1), o.faceTop = !l), a && a.collides && (l && (s.faceLeft = !1), a.faceRight = !l), h && h.collides && (l && (s.faceRight = !1), h.faceLeft = !l), s && !s.collides && s.resetFaces(), s; }; }, function (t, e, i) {
  const n = {}; t.exports = n; const s = i(301); const r = i(49); const o = i(80); n.create = function (t) {
    return r.extend({
      id: r.nextId(), type: 'composite', parent: null, isModified: !1, bodies: [], constraints: [], composites: [], label: 'Composite', plugin: {},
    }, t);
  }, n.setModified = function (t, e, i, s) { if (t.isModified = e, i && t.parent && n.setModified(t.parent, e, i, s), s) for (let r = 0; r < t.composites.length; r++) { const o = t.composites[r]; n.setModified(o, e, i, s); } }, n.add = function (t, e) { const i = [].concat(e); s.trigger(t, 'beforeAdd', { object: e }); for (let o = 0; o < i.length; o++) { const a = i[o]; switch (a.type) { case 'body': if (a.parent !== a) { r.warn('Composite.add: skipped adding a compound body part (you must add its parent instead)'); break; }n.addBody(t, a); break; case 'constraint': n.addConstraint(t, a); break; case 'composite': n.addComposite(t, a); break; case 'mouseConstraint': n.addConstraint(t, a.constraint); } } return s.trigger(t, 'afterAdd', { object: e }), t; }, n.remove = function (t, e, i) { const r = [].concat(e); s.trigger(t, 'beforeRemove', { object: e }); for (let o = 0; o < r.length; o++) { const a = r[o]; switch (a.type) { case 'body': n.removeBody(t, a, i); break; case 'constraint': n.removeConstraint(t, a, i); break; case 'composite': n.removeComposite(t, a, i); break; case 'mouseConstraint': n.removeConstraint(t, a.constraint); } } return s.trigger(t, 'afterRemove', { object: e }), t; }, n.addComposite = function (t, e) { return t.composites.push(e), e.parent = t, n.setModified(t, !0, !0, !1), t; }, n.removeComposite = function (t, e, i) { const s = t.composites.indexOf(e); if (s !== -1 && (n.removeCompositeAt(t, s), n.setModified(t, !0, !0, !1)), i) for (let r = 0; r < t.composites.length; r++)n.removeComposite(t.composites[r], e, !0); return t; }, n.removeCompositeAt = function (t, e) { return t.composites.splice(e, 1), n.setModified(t, !0, !0, !1), t; }, n.addBody = function (t, e) { return t.bodies.push(e), n.setModified(t, !0, !0, !1), t; }, n.removeBody = function (t, e, i) { const s = t.bodies.indexOf(e); if (s !== -1 && (n.removeBodyAt(t, s), n.setModified(t, !0, !0, !1)), i) for (let r = 0; r < t.composites.length; r++)n.removeBody(t.composites[r], e, !0); return t; }, n.removeBodyAt = function (t, e) { return t.bodies.splice(e, 1), n.setModified(t, !0, !0, !1), t; }, n.addConstraint = function (t, e) { return t.constraints.push(e), n.setModified(t, !0, !0, !1), t; }, n.removeConstraint = function (t, e, i) { const s = t.constraints.indexOf(e); if (s !== -1 && n.removeConstraintAt(t, s), i) for (let r = 0; r < t.composites.length; r++)n.removeConstraint(t.composites[r], e, !0); return t; }, n.removeConstraintAt = function (t, e) { return t.constraints.splice(e, 1), n.setModified(t, !0, !0, !1), t; }, n.clear = function (t, e, i) { if (i) for (let s = 0; s < t.composites.length; s++)n.clear(t.composites[s], e, !0); return e ? t.bodies = t.bodies.filter((t) => t.isStatic) : t.bodies.length = 0, t.constraints.length = 0, t.composites.length = 0, n.setModified(t, !0, !0, !1), t; }, n.allBodies = function (t) { for (var e = [].concat(t.bodies), i = 0; i < t.composites.length; i++)e = e.concat(n.allBodies(t.composites[i])); return e; }, n.allConstraints = function (t) { for (var e = [].concat(t.constraints), i = 0; i < t.composites.length; i++)e = e.concat(n.allConstraints(t.composites[i])); return e; }, n.allComposites = function (t) { for (var e = [].concat(t.composites), i = 0; i < t.composites.length; i++)e = e.concat(n.allComposites(t.composites[i])); return e; }, n.get = function (t, e, i) { let s; let r; switch (i) { case 'body': s = n.allBodies(t); break; case 'constraint': s = n.allConstraints(t); break; case 'composite': s = n.allComposites(t).concat(t); } return s ? (r = s.filter((t) => t.id.toString() === e.toString())).length === 0 ? null : r[0] : null; }, n.move = function (t, e, i) { return n.remove(t, e), n.add(i, e), t; }, n.rebase = function (t) { for (let e = n.allBodies(t).concat(n.allConstraints(t)).concat(n.allComposites(t)), i = 0; i < e.length; i++)e[i].id = r.nextId(); return n.setModified(t, !0, !0, !1), t; }, n.translate = function (t, e, i) { for (let s = i ? n.allBodies(t) : t.bodies, r = 0; r < s.length; r++)o.translate(s[r], e); return n.setModified(t, !0, !0, !1), t; }, n.rotate = function (t, e, i, s) { for (let r = Math.cos(e), a = Math.sin(e), h = s ? n.allBodies(t) : t.bodies, l = 0; l < h.length; l++) { const u = h[l]; const c = u.position.x - i.x; const d = u.position.y - i.y; o.setPosition(u, { x: i.x + (c * r - d * a), y: i.y + (c * a + d * r) }), o.rotate(u, e); } return n.setModified(t, !0, !0, !1), t; }, n.scale = function (t, e, i, s, r) { for (let a = r ? n.allBodies(t) : t.bodies, h = 0; h < a.length; h++) { const l = a[h]; const u = l.position.x - s.x; const c = l.position.y - s.y; o.setPosition(l, { x: s.x + u * e, y: s.y + c * i }), o.scale(l, e, i); } return n.setModified(t, !0, !0, !1), t; }, n.bounds = function (t) { for (var e = Matter.Composite.allBodies(t), i = [], n = 0; n < e.length; n += 1) { const s = e[n]; i.push(s.bounds.min, s.bounds.max); } return Matter.Bounds.create(i); };
}, function (t, e, i) { const n = {}; t.exports = n; const s = i(140); const r = i(49); const o = i(80); const a = i(139); const h = i(123); const l = i(1013); n.rectangle = function (t, e, i, n, a) { a = a || {}; const h = { label: 'Rectangle Body', position: { x: t, y: e }, vertices: s.fromPath(`L 0 0 L ${i} 0 L ${i} ${n} L 0 ${n}`) }; if (a.chamfer) { const l = a.chamfer; h.vertices = s.chamfer(h.vertices, l.radius, l.quality, l.qualityMin, l.qualityMax), delete a.chamfer; } return o.create(r.extend({}, h, a)); }, n.trapezoid = function (t, e, i, n, a, h) { h = h || {}; let l; const u = i * (a *= 0.5); const c = u + (1 - 2 * a) * i; const d = c + u; l = a < 0.5 ? `L 0 0 L ${u} ${-n} L ${c} ${-n} L ${d} 0` : `L 0 0 L ${c} ${-n} L ${d} 0`; const f = { label: 'Trapezoid Body', position: { x: t, y: e }, vertices: s.fromPath(l) }; if (h.chamfer) { const p = h.chamfer; f.vertices = s.chamfer(f.vertices, p.radius, p.quality, p.qualityMin, p.qualityMax), delete h.chamfer; } return o.create(r.extend({}, f, h)); }, n.circle = function (t, e, i, s, o) { s = s || {}; const a = { label: 'Circle Body', circleRadius: i }; o = o || 25; let h = Math.ceil(Math.max(10, Math.min(o, i))); return h % 2 == 1 && (h += 1), n.polygon(t, e, h, i, r.extend({}, a, s)); }, n.polygon = function (t, e, i, a, h) { if (h = h || {}, i < 3) return n.circle(t, e, a, h); for (var l = 2 * Math.PI / i, u = '', c = 0.5 * l, d = 0; d < i; d += 1) { const f = c + d * l; const p = Math.cos(f) * a; const g = Math.sin(f) * a; u += `L ${p.toFixed(3)} ${g.toFixed(3)} `; } const v = { label: 'Polygon Body', position: { x: t, y: e }, vertices: s.fromPath(u) }; if (h.chamfer) { const y = h.chamfer; v.vertices = s.chamfer(v.vertices, y.radius, y.quality, y.qualityMin, y.qualityMax), delete h.chamfer; } return o.create(r.extend({}, v, h)); }, n.fromVertices = function (t, e, i, n, u, c, d) { let f; let p; let g; let v; let y; let m; let x; let w; let b; for (n = n || {}, p = [], u = void 0 !== u && u, c = void 0 !== c ? c : 0.01, d = void 0 !== d ? d : 10, l || r.warn('Bodies.fromVertices: poly-decomp.js required. Could not decompose vertices. Fallback to convex hull.'), r.isArray(i[0]) || (i = [i]), w = 0; w < i.length; w += 1) if (v = i[w], (g = s.isConvex(v)) || !l)v = g ? s.clockwiseSort(v) : s.hull(v), p.push({ position: { x: t, y: e }, vertices: v }); else { const T = v.map((t) => [t.x, t.y]); l.makeCCW(T), !1 !== c && l.removeCollinearPoints(T, c); const S = l.quickDecomp(T); for (y = 0; y < S.length; y++) { const A = S[y].map((t) => ({ x: t[0], y: t[1] })); d > 0 && s.area(A) < d || p.push({ position: s.centre(A), vertices: A }); } } for (y = 0; y < p.length; y++)p[y] = o.create(r.extend(p[y], n)); if (u) for (y = 0; y < p.length; y++) { const C = p[y]; for (m = y + 1; m < p.length; m++) { const M = p[m]; if (a.overlaps(C.bounds, M.bounds)) { const _ = C.vertices; const E = M.vertices; for (x = 0; x < C.vertices.length; x++) for (b = 0; b < M.vertices.length; b++) { const P = h.magnitudeSquared(h.sub(_[(x + 1) % _.length], E[b])); const L = h.magnitudeSquared(h.sub(_[x], E[(b + 1) % E.length])); P < 5 && L < 5 && (_[x].isInternal = !0, E[b].isInternal = !0); } } } } return p.length > 1 ? (f = o.create(r.extend({ parts: p.slice(0) }, n)), o.setPosition(f, { x: t, y: e }), f) : p[0]; }; }, function (t, e, i) {
  const n = i(172); function s(t) { if (!(this instanceof s)) return new s(t, ['.left', '.top', '.right', '.bottom']); this._maxEntries = Math.max(4, t || 9), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear(); } function r(t, e, i) { if (!i) return e.indexOf(t); for (let n = 0; n < e.length; n++) if (i(t, e[n])) return n; return -1; } function o(t, e) { a(t, 0, t.children.length, e, t); } function a(t, e, i, n, s) { s || (s = g(null)), s.minX = 1 / 0, s.minY = 1 / 0, s.maxX = -1 / 0, s.maxY = -1 / 0; for (var r, o = e; o < i; o++)r = t.children[o], h(s, t.leaf ? n(r) : r); return s; } function h(t, e) { return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), t.maxY = Math.max(t.maxY, e.maxY), t; } function l(t, e) { return t.minX - e.minX; } function u(t, e) { return t.minY - e.minY; } function c(t) { return (t.maxX - t.minX) * (t.maxY - t.minY); } function d(t) { return t.maxX - t.minX + (t.maxY - t.minY); } function f(t, e) { return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY; } function p(t, e) { return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY; } function g(t) {
    return {
      children: t, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0,
    };
  } function v(t, e, i, s, r) { for (var o, a = [e, i]; a.length;)(i = a.pop()) - (e = a.pop()) <= s || (o = e + Math.ceil((i - e) / s / 2) * s, n(t, o, e, i, r), a.push(e, o, o, i)); }s.prototype = {
    all() { return this._all(this.data, []); },
    search(t) { let e = this.data; const i = []; const n = this.toBBox; if (!p(t, e)) return i; for (var s, r, o, a, h = []; e;) { for (s = 0, r = e.children.length; s < r; s++)o = e.children[s], p(t, a = e.leaf ? n(o) : o) && (e.leaf ? i.push(o) : f(t, a) ? this._all(o, i) : h.push(o)); e = h.pop(); } return i; },
    collides(t) { let e = this.data; const i = this.toBBox; if (!p(t, e)) return !1; for (var n, s, r, o, a = []; e;) { for (n = 0, s = e.children.length; n < s; n++) if (r = e.children[n], p(t, o = e.leaf ? i(r) : r)) { if (e.leaf || f(t, o)) return !0; a.push(r); }e = a.pop(); } return !1; },
    load(t) { if (!t || !t.length) return this; if (t.length < this._minEntries) { for (let e = 0, i = t.length; e < i; e++) this.insert(t[e]); return this; } let n = this._build(t.slice(), 0, t.length - 1, 0); if (this.data.children.length) if (this.data.height === n.height) this._splitRoot(this.data, n); else { if (this.data.height < n.height) { const s = this.data; this.data = n, n = s; } this._insert(n, this.data.height - n.height - 1, !0); } else this.data = n; return this; },
    insert(t) { return t && this._insert(t, this.data.height - 1), this; },
    clear() { return this.data = g([]), this; },
    remove(t, e) { if (!t) return this; for (var i, n, s, o, a = this.data, h = this.toBBox(t), l = [], u = []; a || l.length;) { if (a || (a = l.pop(), n = l[l.length - 1], i = u.pop(), o = !0), a.leaf && (s = r(t, a.children, e)) !== -1) return a.children.splice(s, 1), l.push(a), this._condense(l), this; o || a.leaf || !f(a, h) ? n ? (i++, a = n.children[i], o = !1) : a = null : (l.push(a), u.push(i), i = 0, n = a, a = a.children[0]); } return this; },
    toBBox(t) { return t; },
    compareMinX: l,
    compareMinY: u,
    toJSON() { return this.data; },
    fromJSON(t) { return this.data = t, this; },
    _all(t, e) { for (let i = []; t;)t.leaf ? e.push.apply(e, t.children) : i.push.apply(i, t.children), t = i.pop(); return e; },
    _build(t, e, i, n) { let s; const r = i - e + 1; let a = this._maxEntries; if (r <= a) return o(s = g(t.slice(e, i + 1)), this.toBBox), s; n || (n = Math.ceil(Math.log(r) / Math.log(a)), a = Math.ceil(r / Math.pow(a, n - 1))), (s = g([])).leaf = !1, s.height = n; let h; let l; let u; let c; const d = Math.ceil(r / a); const f = d * Math.ceil(Math.sqrt(a)); for (v(t, e, i, f, this.compareMinX), h = e; h <= i; h += f) for (v(t, h, u = Math.min(h + f - 1, i), d, this.compareMinY), l = h; l <= u; l += d)c = Math.min(l + d - 1, u), s.children.push(this._build(t, l, c, n - 1)); return o(s, this.toBBox), s; },
    _chooseSubtree(t, e, i, n) { for (var s, r, o, a, h, l, u, d, f, p; n.push(e), !e.leaf && n.length - 1 !== i;) { for (u = d = 1 / 0, s = 0, r = e.children.length; s < r; s++)h = c(o = e.children[s]), f = t, p = o, (l = (Math.max(p.maxX, f.maxX) - Math.min(p.minX, f.minX)) * (Math.max(p.maxY, f.maxY) - Math.min(p.minY, f.minY)) - h) < d ? (d = l, u = h < u ? h : u, a = o) : l === d && h < u && (u = h, a = o); e = a || e.children[0]; } return e; },
    _insert(t, e, i) { const n = this.toBBox; const s = i ? t : n(t); const r = []; const o = this._chooseSubtree(s, this.data, e, r); for (o.children.push(t), h(o, s); e >= 0 && r[e].children.length > this._maxEntries;) this._split(r, e), e--; this._adjustParentBBoxes(s, r, e); },
    _split(t, e) { const i = t[e]; const n = i.children.length; const s = this._minEntries; this._chooseSplitAxis(i, s, n); const r = this._chooseSplitIndex(i, s, n); const a = g(i.children.splice(r, i.children.length - r)); a.height = i.height, a.leaf = i.leaf, o(i, this.toBBox), o(a, this.toBBox), e ? t[e - 1].children.push(a) : this._splitRoot(i, a); },
    _splitRoot(t, e) { this.data = g([t, e]), this.data.height = t.height + 1, this.data.leaf = !1, o(this.data, this.toBBox); },
    _chooseSplitIndex(t, e, i) { let n; let s; let r; let o; let h; let l; let u; let d; let f; let p; let g; let v; let y; let m; for (l = u = 1 / 0, n = e; n <= i - e; n++)s = a(t, 0, n, this.toBBox), r = a(t, n, i, this.toBBox), f = s, p = r, void 0, void 0, void 0, void 0, g = Math.max(f.minX, p.minX), v = Math.max(f.minY, p.minY), y = Math.min(f.maxX, p.maxX), m = Math.min(f.maxY, p.maxY), o = Math.max(0, y - g) * Math.max(0, m - v), h = c(s) + c(r), o < l ? (l = o, d = n, u = h < u ? h : u) : o === l && h < u && (u = h, d = n); return d; },
    _chooseSplitAxis(t, e, i) { const n = t.leaf ? this.compareMinX : l; const s = t.leaf ? this.compareMinY : u; this._allDistMargin(t, e, i, n) < this._allDistMargin(t, e, i, s) && t.children.sort(n); },
    _allDistMargin(t, e, i, n) { t.children.sort(n); let s; let r; const o = this.toBBox; const l = a(t, 0, e, o); const u = a(t, i - e, i, o); let c = d(l) + d(u); for (s = e; s < i - e; s++)r = t.children[s], h(l, t.leaf ? o(r) : r), c += d(l); for (s = i - e - 1; s >= e; s--)r = t.children[s], h(u, t.leaf ? o(r) : r), c += d(u); return c; },
    _adjustParentBBoxes(t, e, i) { for (let n = i; n >= 0; n--)h(e[n], t); },
    _condense(t) { for (var e, i = t.length - 1; i >= 0; i--)t[i].children.length === 0 ? i > 0 ? (e = t[i - 1].children).splice(e.indexOf(t[i]), 1) : this.clear() : o(t[i], this.toBBox); },
    compareMinX(t, e) { return t.left - e.left; },
    compareMinY(t, e) { return t.top - e.top; },
    toBBox(t) {
      return {
        minX: t.left, minY: t.top, maxX: t.right, maxY: t.bottom,
      };
    },
  }, t.exports = s;
}, function (t, e, i) {
  const n = new (i(0))({
    initialize() { this._pending = [], this._active = [], this._destroy = [], this._toProcess = 0; }, add(t) { return this._pending.push(t), this._toProcess++, this; }, remove(t) { return this._destroy.push(t), this._toProcess++, this; }, update() { if (this._toProcess === 0) return this._active; let t; let e; let i = this._destroy; const n = this._active; for (t = 0; t < i.length; t++) { e = i[t]; const s = n.indexOf(e); s !== -1 && n.splice(s, 1); } for (i.length = 0, i = this._pending, t = 0; t < i.length; t++)e = i[t], this._active.push(e); return i.length = 0, this._toProcess = 0, this._active; }, getActive() { return this._active; }, destroy() { this._pending = [], this._active = [], this._destroy = []; },
  }); t.exports = n;
}, function (t, e, i) {
  const n = i(0); const s = i(17); const r = i(19); const o = i(6); const a = i(1); const h = i(8); const l = new n({
    Extends: r,
    initialize(t, e, i, n) {
      let s = 'txt'; if (h(e)) { const o = e; e = a(o, 'key'), i = a(o, 'url'), n = a(o, 'xhrSettings'), s = a(o, 'extension', s); } const l = {
        type: 'text', cache: t.cacheManager.text, extension: s, responseType: 'text', key: e, url: i, xhrSettings: n,
      }; r.call(this, t, l);
    },
    onProcess() { this.state = s.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete(); },
  }); o.register('text', function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new l(this, t[n])); else this.addFile(new l(this, t, e, i)); return this; }), t.exports = l;
}, function (t, e) { t.exports = function (t, e, i, n) { const s = Math.cos(n); const r = Math.sin(n); let o = t.x1 - e; let a = t.y1 - i; return t.x1 = o * s - a * r + e, t.y1 = o * r + a * s + i, o = t.x2 - e, a = t.y2 - i, t.x2 = o * s - a * r + e, t.y2 = o * r + a * s + i, o = t.x3 - e, a = t.y3 - i, t.x3 = o * s - a * r + e, t.y3 = o * r + a * s + i, t; }; }, function (t, e, i) { const n = i(71); const s = i(5); t.exports = function (t, e, i, r) { void 0 === r && (r = []); const o = t.getLineA(); const a = t.getLineB(); const h = t.getLineC(); const l = n(o); const u = n(a); const c = n(h); const d = l + u + c; e || (e = d / i); for (let f = 0; f < e; f++) { let p = d * (f / e); let g = 0; const v = new s(); p < l ? (g = p / l, v.x = o.x1 + (o.x2 - o.x1) * g, v.y = o.y1 + (o.y2 - o.y1) * g) : p > l + u ? (g = (p -= l + u) / c, v.x = h.x1 + (h.x2 - h.x1) * g, v.y = h.y1 + (h.y2 - h.y1) * g) : (g = (p -= l) / u, v.x = a.x1 + (a.x2 - a.x1) * g, v.y = a.y1 + (a.y2 - a.y1) * g), r.push(v); } return r; }; }, function (t, e, i) { const n = i(5); const s = i(71); t.exports = function (t, e, i) { void 0 === i && (i = new n()); const r = t.getLineA(); const o = t.getLineB(); const a = t.getLineC(); if (e <= 0 || e >= 1) return i.x = r.x1, i.y = r.y1, i; const h = s(r); const l = s(o); const u = s(a); let c = (h + l + u) * e; let d = 0; return c < h ? (d = c / h, i.x = r.x1 + (r.x2 - r.x1) * d, i.y = r.y1 + (r.y2 - r.y1) * d) : c > h + l ? (d = (c -= h + l) / u, i.x = a.x1 + (a.x2 - a.x1) * d, i.y = a.y1 + (a.y2 - a.y1) * d) : (d = (c -= h) / l, i.x = o.x1 + (o.x2 - o.x1) * d, i.y = o.y1 + (o.y2 - o.y1) * d), i; }; }, function (t, e) { t.exports = function (t) { return t.height === 0 ? NaN : t.width / t.height; }; }, function (t, e) { t.exports = function (t, e, i) { for (var n = !1, s = -1, r = t.points.length - 1; ++s < t.points.length; r = s) { const o = t.points[s].x; const a = t.points[s].y; const h = t.points[r].x; const l = t.points[r].y; (a <= i && i < l || l <= i && i < a) && e < (h - o) * (i - a) / (l - a) + o && (n = !n); } return n; }; }, function (t, e) { t.exports = function (t, e, i, n) { const s = Math.cos(n); const r = Math.sin(n); let o = t.x1 - e; let a = t.y1 - i; return t.x1 = o * s - a * r + e, t.y1 = o * r + a * s + i, o = t.x2 - e, a = t.y2 - i, t.x2 = o * s - a * r + e, t.y2 = o * r + a * s + i, t; }; }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === i && (i = !1), void 0 === n && (n = []); for (var s, r, o, a, h, l, u = t.x3 - t.x1, c = t.y3 - t.y1, d = t.x2 - t.x1, f = t.y2 - t.y1, p = u * u + c * c, g = u * d + c * f, v = d * d + f * f, y = p * v - g * g, m = y === 0 ? 0 : 1 / y, x = t.x1, w = t.y1, b = 0; b < e.length && (r = (p * (l = d * (o = e[b].x - x) + f * (a = e[b].y - w)) - g * (h = u * o + c * a)) * m, !((s = (v * h - g * l) * m) >= 0 && r >= 0 && s + r < 1 && (n.push({ x: e[b].x, y: e[b].y }), i))); b++);return n; }; }, function (t, e, i) {
  const n = i(0); const s = i(144); const r = new n({
    Extends: s, initialize(t, e, i, n, r) { s.call(this, t, e, i, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0], [16777215, 16777215, 16777215, 16777215, 16777215, 16777215], [1, 1, 1, 1, 1, 1], n, r), this.resetPosition(); }, topLeftX: { get() { return this.x + this.vertices[0]; }, set(t) { this.vertices[0] = t - this.x, this.vertices[6] = t - this.x; } }, topLeftY: { get() { return this.y + this.vertices[1]; }, set(t) { this.vertices[1] = t - this.y, this.vertices[7] = t - this.y; } }, topRightX: { get() { return this.x + this.vertices[10]; }, set(t) { this.vertices[10] = t - this.x; } }, topRightY: { get() { return this.y + this.vertices[11]; }, set(t) { this.vertices[11] = t - this.y; } }, bottomLeftX: { get() { return this.x + this.vertices[2]; }, set(t) { this.vertices[2] = t - this.x; } }, bottomLeftY: { get() { return this.y + this.vertices[3]; }, set(t) { this.vertices[3] = t - this.y; } }, bottomRightX: { get() { return this.x + this.vertices[4]; }, set(t) { this.vertices[4] = t - this.x, this.vertices[8] = t - this.x; } }, bottomRightY: { get() { return this.y + this.vertices[5]; }, set(t) { this.vertices[5] = t - this.y, this.vertices[9] = t - this.y; } }, topLeftAlpha: { get() { return this.alphas[0]; }, set(t) { this.alphas[0] = t, this.alphas[3] = t; } }, topRightAlpha: { get() { return this.alphas[5]; }, set(t) { this.alphas[5] = t; } }, bottomLeftAlpha: { get() { return this.alphas[1]; }, set(t) { this.alphas[1] = t; } }, bottomRightAlpha: { get() { return this.alphas[2]; }, set(t) { this.alphas[2] = t, this.alphas[4] = t; } }, topLeftColor: { get() { return this.colors[0]; }, set(t) { this.colors[0] = t, this.colors[3] = t; } }, topRightColor: { get() { return this.colors[5]; }, set(t) { this.colors[5] = t; } }, bottomLeftColor: { get() { return this.colors[1]; }, set(t) { this.colors[1] = t; } }, bottomRightColor: { get() { return this.colors[2]; }, set(t) { this.colors[2] = t, this.colors[4] = t; } }, setTopLeft(t, e) { return this.topLeftX = t, this.topLeftY = e, this; }, setTopRight(t, e) { return this.topRightX = t, this.topRightY = e, this; }, setBottomLeft(t, e) { return this.bottomLeftX = t, this.bottomLeftY = e, this; }, setBottomRight(t, e) { return this.bottomRightX = t, this.bottomRightY = e, this; }, resetPosition() { const t = this.x; const e = this.y; const i = Math.floor(this.width / 2); const n = Math.floor(this.height / 2); return this.setTopLeft(t - i, e - n), this.setTopRight(t + i, e - n), this.setBottomLeft(t - i, e + n), this.setBottomRight(t + i, e + n), this; }, resetAlpha() { const t = this.alphas; return t[0] = 1, t[1] = 1, t[2] = 1, t[3] = 1, t[4] = 1, t[5] = 1, this; }, resetColors() { const t = this.colors; return t[0] = 16777215, t[1] = 16777215, t[2] = 16777215, t[3] = 16777215, t[4] = 16777215, t[5] = 16777215, this; }, reset() { return this.resetPosition(), this.resetAlpha(), this.resetColors(); },
  }); t.exports = r;
}, function (t, e, i) {
  const n = i(22); const s = i(0); const r = i(15); const o = i(20); const a = i(2); const h = i(398); const l = i(884); const u = new s({
    Extends: a, Mixins: [r.Alpha, r.BlendMode, r.Depth, r.Flip, r.GetBounds, r.Mask, r.Origin, r.Pipeline, r.ScaleMode, r.ScrollFactor, r.Size, r.Texture, r.Tint, r.Transform, r.Visible, l], initialize(t, e, i, s, r, l, u) { const c = t.sys.game.renderer; a.call(this, t, 'TileSprite'), this.tilePositionX = 0, this.tilePositionY = 0, this.dirty = !0, this.tileTexture = null, this.renderer = c, this.setTexture(l, u), this.setPosition(e, i), this.setSize(s, r), this.setOriginFromFrame(), this.initPipeline('TextureTintPipeline'), this.potWidth = h(this.frame.width), this.potHeight = h(this.frame.height), this.canvasPattern = null, this.canvasBuffer = n.create2D(this, this.potWidth, this.potHeight), this.canvasBufferCtx = this.canvasBuffer.getContext('2d'), this.oldFrame = null, this.updateTileTexture(), t.sys.game.config.renderType === o.WEBGL && t.sys.game.renderer.onContextRestored(function (t) { const e = t.gl; this.tileTexture = null, this.dirty = !0, this.tileTexture = t.createTexture2D(0, e.LINEAR, e.LINEAR, e.REPEAT, e.REPEAT, e.RGBA, this.canvasBuffer, this.potWidth, this.potHeight); }, this); }, setTilePosition(t, e) { return void 0 !== t && (this.tilePositionX = t), void 0 !== e && (this.tilePositionY = e), this; }, updateTileTexture() { (this.dirty || this.oldFrame !== this.frame) && (this.oldFrame = this.frame, this.canvasBufferCtx.clearRect(0, 0, this.canvasBuffer.width, this.canvasBuffer.height), this.renderer.gl ? (this.canvasBufferCtx.drawImage(this.frame.source.image, this.frame.cutX, this.frame.cutY, this.frame.cutWidth, this.frame.cutHeight, 0, 0, this.potWidth, this.potHeight), this.tileTexture = this.renderer.canvasToTexture(this.canvasBuffer, this.tileTexture)) : (this.canvasBuffer.width = this.frame.cutWidth, this.canvasBuffer.height = this.frame.cutHeight, this.canvasBufferCtx.drawImage(this.frame.source.image, this.frame.cutX, this.frame.cutY, this.frame.cutWidth, this.frame.cutHeight, 0, 0, this.frame.cutWidth, this.frame.cutHeight), this.canvasPattern = this.canvasBufferCtx.createPattern(this.canvasBuffer, 'repeat')), this.dirty = !1); }, preDestroy() { this.renderer && this.renderer.gl && this.renderer.deleteTexture(this.tileTexture), n.remove(this.canvasBuffer), this.canvasPattern = null, this.canvasBufferCtx = null, this.canvasBuffer = null, this.renderer = null; },
  }); t.exports = u;
}, function (t, e, i) {
  const n = i(22); const s = i(0); const r = i(15); const o = i(20); const a = i(2); const h = i(892); const l = i(889); const u = i(888); const c = new s({
    Extends: a, Mixins: [r.Alpha, r.BlendMode, r.ComputedSize, r.Depth, r.Flip, r.GetBounds, r.Mask, r.MatrixStack, r.Origin, r.Pipeline, r.ScaleMode, r.ScrollFactor, r.Tint, r.Transform, r.Visible, h], initialize(t, e, i, s, r) { if (void 0 === s && (s = 32), void 0 === r && (r = 32), a.call(this, t, 'RenderTexture'), this.initMatrixStack(), this.renderer = t.sys.game.renderer, this.globalTint = 16777215, this.globalAlpha = 1, this.renderer.type === o.WEBGL) { const h = this.renderer.gl; this.gl = h, this.fill = u.fill, this.clear = u.clear, this.draw = u.draw, this.drawFrame = u.drawFrame, this.texture = this.renderer.createTexture2D(0, h.NEAREST, h.NEAREST, h.CLAMP_TO_EDGE, h.CLAMP_TO_EDGE, h.RGBA, null, s, r, !1), this.framebuffer = this.renderer.createFramebuffer(s, r, this.texture, !1); } else this.renderer.type === o.CANVAS && (this.fill = l.fill, this.clear = l.clear, this.draw = l.draw, this.drawFrame = l.drawFrame, this.canvas = n.create2D(this, s, r), this.context = this.canvas.getContext('2d')); this.setPosition(e, i), this.setSize(s, r), this.initPipeline('TextureTintPipeline'); }, setGlobalTint(t) { return this.globalTint = t, this; }, setGlobalAlpha(t) { return this.globalAlpha = t, this; }, preDestroy() { this.renderer && this.renderer.gl && (this.renderer.deleteTexture(this.texture), this.renderer.deleteFramebuffer(this.framebuffer)); },
  }); t.exports = c;
}, function (t, e, i) {
  const n = i(0); const s = i(15); const r = i(2); const o = i(445); const a = i(92); const h = i(443); const l = i(896); const u = new n({
    Extends: r, Mixins: [s.Depth, s.Visible, s.Pipeline, l], initialize(t, e, i, n) { if (r.call(this, t, 'ParticleEmitterManager'), this.blendMode = -1, this.timeScale = 1, this.texture = null, this.frame = null, this.frameNames = [], i === null || typeof i !== 'object' && !Array.isArray(i) || (n = i, i = null), this.setTexture(e, i), this.initPipeline('TextureTintPipeline'), this.emitters = new a(this), this.wells = new a(this), n) { Array.isArray(n) || (n = [n]); for (let s = 0; s < n.length; s++) this.createEmitter(n[s]); } }, setTexture(t, e) { return this.texture = this.scene.sys.textures.get(t), this.setFrame(e); }, setFrame(t) { return this.frame = this.texture.get(t), this.frameNames = this.texture.getFramesFromTextureSource(this.frame.sourceIndex), this.defaultFrame = this.frame, this; }, setEmitterFrames(t, e) { Array.isArray(t) || (t = [t]); const i = e.frames; i.length = 0; for (let n = 0; n < t.length; n++) { const s = t[n]; this.frameNames.indexOf(s) !== -1 && i.push(this.texture.get(s)); } return i.length > 0 ? e.defaultFrame = i[0] : e.defaultFrame = this.defaultFrame, this; }, addEmitter(t) { return this.emitters.add(t); }, createEmitter(t) { return this.addEmitter(new h(this, t)); }, addGravityWell(t) { return this.wells.add(t); }, createGravityWell(t) { return this.addGravityWell(new o(t)); }, emitParticle(t, e, i) { for (let n = this.emitters.list, s = 0; s < n.length; s++) { const r = n[s]; r.active && r.emitParticle(t, e, i); } return this; }, emitParticleAt(t, e, i) { return this.emitParticle(i, t, e); }, pause() { return this.active = !1, this; }, resume() { return this.active = !0, this; }, getProcessors() { return this.wells.getAll('active', !0); }, preUpdate(t, e) { e *= this.timeScale; for (let i = this.emitters.list, n = 0; n < i.length; n++) { const s = i[n]; s.active && s.preUpdate(t, e); } },
  }); t.exports = u;
}, function (t, e, i) { t.exports = i(408); }, function (t, e, i) { t.exports = { In: i(411), Out: i(410), InOut: i(409) }; }, function (t, e, i) { t.exports = { In: i(414), Out: i(413), InOut: i(412) }; }, function (t, e, i) { t.exports = { In: i(417), Out: i(416), InOut: i(415) }; }, function (t, e, i) { t.exports = { In: i(420), Out: i(419), InOut: i(418) }; }, function (t, e, i) { t.exports = i(421); }, function (t, e, i) { t.exports = { In: i(424), Out: i(423), InOut: i(422) }; }, function (t, e, i) { t.exports = { In: i(427), Out: i(426), InOut: i(425) }; }, function (t, e, i) { t.exports = { In: i(430), Out: i(429), InOut: i(428) }; }, function (t, e, i) { t.exports = { In: i(433), Out: i(432), InOut: i(431) }; }, function (t, e, i) { t.exports = { In: i(436), Out: i(435), InOut: i(434) }; }, function (t, e, i) { t.exports = { In: i(439), Out: i(438), InOut: i(437) }; }, function (t, e) { t.exports = function (t, e) { return Math.random() * (e - t) + t; }; }, function (t, e, i) { const n = i(111); n.Area = i(459), n.Circumference = i(169), n.CircumferencePoint = i(110), n.Clone = i(458), n.Contains = i(53), n.ContainsPoint = i(457), n.ContainsRect = i(456), n.CopyFrom = i(455), n.Equals = i(454), n.GetBounds = i(453), n.GetPoint = i(171), n.GetPoints = i(170), n.Offset = i(452), n.OffsetPoint = i(451), n.Random = i(131), t.exports = n; }, function (t, e, i) {
  const n = i(0); const s = i(15); const r = i(2); const o = i(462); const a = i(901); const h = new n({
    Extends: r, Mixins: [s.Alpha, s.BlendMode, s.Depth, s.Mask, s.Origin, s.Pipeline, s.ScrollFactor, s.Texture, s.Tint, s.Transform, s.Visible, a], initialize(t, e, i, n, s, o) { void 0 === s && (s = ''), r.call(this, t, 'DynamicBitmapText'), this.font = n; const a = this.scene.sys.cache.bitmapFont.get(n); this.fontData = a.data, this.text = '', this.fontSize = o || this.fontData.size, this.letterSpacing = 0, this.setText(s), this.setTexture(a.texture, a.frame), this.setPosition(e, i), this.setOrigin(0, 0), this.initPipeline('TextureTintPipeline'), this._bounds = this.getTextBounds(), this.scrollX = 0, this.scrollY = 0, this.cropWidth = 0, this.cropHeight = 0, this.displayCallback; }, setSize(t, e) { return this.cropWidth = t, this.cropHeight = e, this; }, setDisplayCallback(t) { return this.displayCallback = t, this; }, setFontSize(t) { return this.fontSize = t, this; }, setText(t) { return t || t === 0 || (t = ''), Array.isArray(t) && (t = t.join('\n')), t !== this.text && (this.text = t.toString(), this.updateDisplayOrigin()), this; }, setScrollX(t) { return this.scrollX = t, this; }, setScrollY(t) { return this.scrollY = t, this; }, getTextBounds(t) { return this._bounds = o(this, t), this._bounds; }, width: { get() { return this.getTextBounds(!1), this._bounds.global.width; } }, height: { get() { return this.getTextBounds(!1), this._bounds.global.height; } }, toJSON() { const t = s.ToJSON(this); const e = { font: this.font, text: this.text, fontSize: this.fontSize }; return t.data = e, t; },
  }); t.exports = h;
}, function (t, e, i) {
  const n = i(146); const s = i(0); const r = i(15); const o = i(2); const a = i(14); const h = i(904); const l = i(460); const u = i(7); const c = new s({
    Extends: o, Mixins: [r.Alpha, r.BlendMode, r.ComputedSize, r.Depth, r.ScrollFactor, r.Transform, r.Visible, h], initialize(t, e, i, n) { o.call(this, t, 'Container'), this.list = [], this.exclusive = !0, this.maxSize = -1, this.position = 0, this.localTransform = new r.TransformMatrix(), this.tempTransformMatrix = new r.TransformMatrix(), this._displayList = t.sys.displayList, this._sortKey = '', this._sysEvents = t.sys.events, this.setPosition(e, i), this.clearAlpha(), n && this.add(n); }, originX: { get() { return 0.5; } }, originY: { get() { return 0.5; } }, displayOriginX: { get() { return 0.5 * this.width; } }, displayOriginY: { get() { return 0.5 * this.height; } }, setExclusive(t) { return void 0 === t && (t = !0), this.exclusive = t, this; }, getBounds(t) { if (void 0 === t && (t = new a()), t.setTo(this.x, this.y, 0, 0), this.list.length > 0) for (let e = this.list, i = new a(), n = 0; n < e.length; n++) { const s = e[n]; s.getBounds && (s.getBounds(i), l(i, t, t)); } return t; }, addHandler(t) { t.once('destroy', this.remove, this), this.exclusive && (this._displayList.remove(t), t.parentContainer && t.parentContainer.remove(t), t.parentContainer = this), this._sysEvents.off('shutdown', t.destroy, t); }, removeHandler(t) { t.off('destroy', this.remove), this.exclusive && (t.parentContainer = null, this._sysEvents.once('shutdown', t.destroy, t)); }, pointToContainer(t, e) { if (void 0 === e && (e = new u()), this.parentContainer) return this.parentContainer.pointToContainer(t, e); const i = this.tempTransformMatrix; return i.applyITRS(this.x, this.y, this.rotation, this.scaleX, this.scaleY), i.invert(), i.transformPoint(t.x, t.y, e), e; }, getBoundsTransformMatrix() { return this.getWorldTransformMatrix(this.tempTransformMatrix); }, add(t) { return n.Add(this.list, t, this.maxSize, this.addHandler, this), this; }, addAt(t, e) { return n.AddAt(this.list, t, e, this.maxSize, this.addHandler, this), this; }, getAt(t) { return this.list[t]; }, getIndex(t) { return this.list.indexOf(t); }, sort(t) { return t && (this._sortKey = t, n.StableSort.inplace(this.list, this.sortHandler)), this; }, sortHandler(t, e) { return t[this._sortKey] - e[this._sortKey]; }, getByName(t) { return n.GetFirst(this.list, 'name', t); }, getRandom(t, e) { return n.GetRandom(this.list, t, e); }, getFirst(t, e, i, s) { return n.GetFirstElement(this.list, t, e, i, s); }, getAll(t, e, i, s) { return n.GetAll(this.list, t, e, i, s); }, count(t, e, i, s) { return n.CountAllMatching(this.list, t, e, i, s); }, swap(t, e) { return n.Swap(this.list, t, e), this; }, moveTo(t, e) { return n.MoveTo(this.list, t, e), this; }, remove(t, e) { let i = n.Remove(this.list, t, this.removeHandler, this); if (e && i) { Array.isArray(i) || (i = [i]); for (let s = 0; s < i.length; s++)i[s].destroy(); } return this; }, removeAt(t, e) { const i = n.RemoveAt(this.list, t, this.removeHandler, this); return e && i && i.destroy(), this; }, removeBetween(t, e, i) { const s = n.RemoveBetween(this.list, t, e, this.removeHandler, this); if (i) for (let r = 0; r < s.length; r++)s[r].destroy(); return this; }, removeAll(t) { const e = n.RemoveBetween(this.list, 0, this.list.length, this.removeHandler, this); if (t) for (let i = 0; i < e.length; i++)e[i].destroy(); return this; }, bringToTop(t) { return n.BringToTop(this.list, t), this; }, sendToBack(t) { return n.SendToBack(this.list, t), this; }, moveUp(t) { return n.MoveUp(this.list, t), this; }, moveDown(t) { return n.MoveDown(this.list, t), this; }, reverse() { return this.list.reverse(), this; }, shuffle() { return n.Shuffle(this.list), this; }, replace(t, e, i) { return n.Replace(this.list, t, e) && (this.addHandler(e), this.removeHandler(t), i && t.destroy()), this; }, exists(t) { return this.list.indexOf(t) > -1; }, setAll(t, e, i, s) { return n.SetAll(this.list, t, e, i, s), this; }, each(t, e) { let i; const n = [null]; const s = this.list.slice(); const r = s.length; for (i = 2; i < arguments.length; i++)n.push(arguments[i]); for (i = 0; i < r; i++)n[0] = s[i], t.apply(e, n); return this; }, iterate(t, e) { let i; const n = [null]; for (i = 2; i < arguments.length; i++)n.push(arguments[i]); for (i = 0; i < this.list.length; i++)n[0] = this.list[i], t.apply(e, n); return this; }, length: { get() { return this.list.length; } }, first: { get() { return this.position = 0, this.list.length > 0 ? this.list[0] : null; } }, last: { get() { return this.list.length > 0 ? (this.position = this.list.length - 1, this.list[this.position]) : null; } }, next: { get() { return this.position < this.list.length ? (this.position++, this.list[this.position]) : null; } }, previous: { get() { return this.position > 0 ? (this.position--, this.list[this.position]) : null; } }, preDestroy() { this.removeAll(!!this.exclusive), this.localTransform.destroy(), this.tempTransformMatrix.destroy(), this.list = [], this._displayList = null; },
  }); t.exports = c;
}, function (t, e, i) {
  const n = i(908); const s = i(905); const r = i(0); const o = i(15); const a = i(125); const h = i(2); const l = i(92); const u = new r({
    Extends: h, Mixins: [o.Alpha, o.BlendMode, o.Depth, o.Mask, o.Pipeline, o.ScaleMode, o.ScrollFactor, o.Size, o.Texture, o.Transform, o.Visible, n], initialize(t, e, i, n, s) { h.call(this, t, 'Blitter'), this.setTexture(n, s), this.setPosition(e, i), this.initPipeline('TextureTintPipeline'), this.children = new l(), this.renderList = [], this.dirty = !1; }, create(t, e, i, n, r) { void 0 === n && (n = !0), void 0 === r && (r = this.children.length), void 0 === i ? i = this.frame : i instanceof a || (i = this.texture.get(i)); const o = new s(this, t, e, i, n); return this.children.addAt(o, r, !1), this.dirty = !0, o; }, createFromCallback(t, e, i, n) { for (var s = this.createMultiple(e, i, n), r = 0; r < s.length; r++) { const o = s[r]; t.call(this, o, r); } return s; }, createMultiple(t, e, i) { void 0 === e && (e = this.frame.name), void 0 === i && (i = !0), Array.isArray(e) || (e = [e]); const n = []; const s = this; return e.forEach((e) => { for (let r = 0; r < t; r++)n.push(s.create(0, 0, e, i)); }), n; }, childCanRender(t) { return t.visible && t.alpha > 0; }, getRenderList() { return this.dirty && (this.renderList = this.children.list.filter(this.childCanRender, this), this.dirty = !1), this.renderList; }, clear() { this.children.removeAll(), this.dirty = !0; }, preDestroy() { this.children.destroy(), this.renderList = []; },
  }); t.exports = u;
}, function (t, e, i) {
  const n = i(0); const s = i(15); const r = i(2); const o = i(462); const a = i(912); const h = i(911); const l = new n({
    Extends: r,
    Mixins: [s.Alpha, s.BlendMode, s.Depth, s.Mask, s.Origin, s.Pipeline, s.ScaleMode, s.ScrollFactor, s.Texture, s.Tint, s.Transform, s.Visible, h],
    initialize(t, e, i, n, s, o) { void 0 === s && (s = ''), r.call(this, t, 'BitmapText'), this.font = n; const a = this.scene.sys.cache.bitmapFont.get(n); this.fontData = a.data, this.text = '', this.fontSize = o || this.fontData.size, this.letterSpacing = 0, this.setText(s), this.setTexture(a.texture, a.frame), this.setPosition(e, i), this.setOrigin(0, 0), this.initPipeline('TextureTintPipeline'), this._bounds = this.getTextBounds(); },
    setFontSize(t) { return this.fontSize = t, this; },
    setLetterSpacing(t) { return void 0 === t && (t = 0), this.letterSpacing = t, this; },
    setText(t) { return t || t === 0 || (t = ''), Array.isArray(t) && (t = t.join('\n')), t !== this.text && (this.text = t.toString(), this.updateDisplayOrigin()), this; },
    getTextBounds(t) { return this._bounds = o(this, t), this._bounds; },
    width: { get() { return this.getTextBounds(!1), this._bounds.global.width; } },
    height: { get() { return this.getTextBounds(!1), this._bounds.global.height; } },
    toJSON() {
      const t = s.ToJSON(this); const e = {
        font: this.font, text: this.text, fontSize: this.fontSize, letterSpacing: this.letterSpacing,
      }; return t.data = e, t;
    },
  }); l.ParseFromAtlas = a, t.exports = l;
}, function (t, e, i) { const n = i(4); const s = i(94); const r = function (t, e, i) { for (var n = [], s = 0; s < t.length; s++) for (let r = 0; r < e.length; r++) for (let o = 0; o < i; o++)n.push({ a: t[s], b: e[r] }); return n; }; t.exports = function (t, e, i) { const o = n(i, 'max', 0); const a = n(i, 'qty', 1); const h = n(i, 'random', !1); const l = n(i, 'randomB', !1); let u = n(i, 'repeat', 0); const c = n(i, 'yoyo', !1); let d = []; if (l && s(e), u === -1) if (o === 0)u = 0; else { let f = t.length * e.length * a; c && (f *= 2), u = Math.ceil(o / f); } for (let p = 0; p <= u; p++) { const g = r(t, e, a); h && s(g), d = d.concat(g), c && (g.reverse(), d = d.concat(g)); } return o && d.splice(o), d; }; }, function (t, e) { t.exports = function (t) { return t > 0 ? Math.ceil(t) : Math.floor(t); }; }, function (t, e) { t.exports = function (t) { return t && t[0].toUpperCase() + t.slice(1); }; }, function (t, e, i) { const n = i(7); t.exports = function (t, e, i, s, r, o, a, h) { void 0 === h && (h = new n()); const l = Math.sin(-r); const u = Math.cos(-r); const c = u * o; const d = -l * o; const f = l * a; const p = u * a; const g = c * p - d * f; const v = p / g; const y = -d / g; const m = -f / g; const x = c / g; const w = (f * s - p * i) / g; const b = -(c * s - d * i) / g; return h.x = t * v + e * m + w, h.y = t * y + e * x + b, h; }; }, function (t, e, i) {
  function n(t, e, i) { i = i || 2; let n; let a; let h; let l; let u; let f; let g; const v = e && e.length; const y = v ? e[0] * i : t.length; let m = s(t, 0, y, i, !0); const x = []; if (!m) return x; if (v && (m = (function (t, e, i, n) { let o; let a; let h; let l; let u; const f = []; for (o = 0, a = e.length; o < a; o++)h = e[o] * n, l = o < a - 1 ? e[o + 1] * n : t.length, (u = s(t, h, l, n, !1)) === u.next && (u.steiner = !0), f.push(p(u)); for (f.sort(c), o = 0; o < f.length; o++)d(f[o], i), i = r(i, i.next); return i; }(t, e, m, i))), t.length > 80 * i) { n = h = t[0], a = l = t[1]; for (let w = i; w < y; w += i)u = t[w], f = t[w + 1], u < n && (n = u), f < a && (a = f), u > h && (h = u), f > l && (l = f); g = Math.max(h - n, l - a); } return o(m, x, i, n, a, g), x; } function s(t, e, i, n, s) { let r; let o; if (s === C(t, e, i, n) > 0) for (r = e; r < i; r += n)o = T(r, t[r], t[r + 1], o); else for (r = i - n; r >= e; r -= n)o = T(r, t[r], t[r + 1], o); return o && m(o, o.next) && (S(o), o = o.next), o; } function r(t, e) { if (!t) return t; e || (e = t); let i; let n = t; do { if (i = !1, n.steiner || !m(n, n.next) && y(n.prev, n, n.next) !== 0)n = n.next; else { if (S(n), (n = e = n.prev) === n.next) return null; i = !0; } } while (i || n !== e); return e; } function o(t, e, i, n, s, c, d) { if (t) { !d && c && (function (t, e, i, n) { let s = t; do { s.z === null && (s.z = f(s.x, s.y, e, i, n)), s.prevZ = s.prev, s.nextZ = s.next, s = s.next; } while (s !== t); s.prevZ.nextZ = null, s.prevZ = null, (function (t) { let e; let i; let n; let s; let r; let o; let a; let h; let l = 1; do { for (i = t, t = null, r = null, o = 0; i;) { for (o++, n = i, a = 0, e = 0; e < l && (a++, n = n.nextZ); e++);for (h = l; a > 0 || h > 0 && n;)a !== 0 && (h === 0 || !n || i.z <= n.z) ? (s = i, i = i.nextZ, a--) : (s = n, n = n.nextZ, h--), r ? r.nextZ = s : t = s, s.prevZ = r, r = s; i = n; }r.nextZ = null, l *= 2; } while (o > 1); }(s)); }(t, n, s, c)); for (var p, g, v = t; t.prev !== t.next;) if (p = t.prev, g = t.next, c ? h(t, n, s, c) : a(t))e.push(p.i / i), e.push(t.i / i), e.push(g.i / i), S(t), t = g.next, v = g.next; else if ((t = g) === v) { d ? d === 1 ? o(t = l(t, e, i), e, i, n, s, c, 2) : d === 2 && u(t, e, i, n, s, c) : o(r(t), e, i, n, s, c, 1); break; } } } function a(t) { const e = t.prev; const i = t; const n = t.next; if (y(e, i, n) >= 0) return !1; for (let s = t.next.next; s !== t.prev;) { if (g(e.x, e.y, i.x, i.y, n.x, n.y, s.x, s.y) && y(s.prev, s, s.next) >= 0) return !1; s = s.next; } return !0; } function h(t, e, i, n) { const s = t.prev; const r = t; const o = t.next; if (y(s, r, o) >= 0) return !1; for (var a = s.x < r.x ? s.x < o.x ? s.x : o.x : r.x < o.x ? r.x : o.x, h = s.y < r.y ? s.y < o.y ? s.y : o.y : r.y < o.y ? r.y : o.y, l = s.x > r.x ? s.x > o.x ? s.x : o.x : r.x > o.x ? r.x : o.x, u = s.y > r.y ? s.y > o.y ? s.y : o.y : r.y > o.y ? r.y : o.y, c = f(a, h, e, i, n), d = f(l, u, e, i, n), p = t.nextZ; p && p.z <= d;) { if (p !== t.prev && p !== t.next && g(s.x, s.y, r.x, r.y, o.x, o.y, p.x, p.y) && y(p.prev, p, p.next) >= 0) return !1; p = p.nextZ; } for (p = t.prevZ; p && p.z >= c;) { if (p !== t.prev && p !== t.next && g(s.x, s.y, r.x, r.y, o.x, o.y, p.x, p.y) && y(p.prev, p, p.next) >= 0) return !1; p = p.prevZ; } return !0; } function l(t, e, i) { let n = t; do { const s = n.prev; const r = n.next.next; !m(s, r) && x(s, n, n.next, r) && w(s, r) && w(r, s) && (e.push(s.i / i), e.push(n.i / i), e.push(r.i / i), S(n), S(n.next), n = t = r), n = n.next; } while (n !== t); return n; } function u(t, e, i, n, s, a) { let h = t; do { for (let l = h.next.next; l !== h.prev;) { if (h.i !== l.i && v(h, l)) { let u = b(h, l); return h = r(h, h.next), u = r(u, u.next), o(h, e, i, n, s, a), void o(u, e, i, n, s, a); }l = l.next; }h = h.next; } while (h !== t); } function c(t, e) { return t.x - e.x; } function d(t, e) { if (e = (function (t, e) { let i; let n = e; const s = t.x; const r = t.y; let o = -1 / 0; do { if (r <= n.y && r >= n.next.y && n.next.y !== n.y) { const a = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y); if (a <= s && a > o) { if (o = a, a === s) { if (r === n.y) return n; if (r === n.next.y) return n.next; }i = n.x < n.next.x ? n : n.next; } }n = n.next; } while (n !== e); if (!i) return null; if (s === o) return i.prev; let h; const l = i; const u = i.x; const c = i.y; let d = 1 / 0; n = i.next; for (;n !== l;)s >= n.x && n.x >= u && s !== n.x && g(r < c ? s : o, r, u, c, r < c ? o : s, r, n.x, n.y) && ((h = Math.abs(r - n.y) / (s - n.x)) < d || h === d && n.x > i.x) && w(n, t) && (i = n, d = h), n = n.next; return i; }(t, e))) { const i = b(e, t); r(i, i.next); } } function f(t, e, i, n, s) { return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) / s) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) / s) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1; } function p(t) { let e = t; let i = t; do { e.x < i.x && (i = e), e = e.next; } while (e !== t); return i; } function g(t, e, i, n, s, r, o, a) { return (s - o) * (e - a) - (t - o) * (r - a) >= 0 && (t - o) * (n - a) - (i - o) * (e - a) >= 0 && (i - o) * (r - a) - (s - o) * (n - a) >= 0; } function v(t, e) { return t.next.i !== e.i && t.prev.i !== e.i && !(function (t, e) { let i = t; do { if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && x(i, i.next, t, e)) return !0; i = i.next; } while (i !== t); return !1; }(t, e)) && w(t, e) && w(e, t) && (function (t, e) { let i = t; let n = !1; const s = (t.x + e.x) / 2; const r = (t.y + e.y) / 2; do { i.y > r != i.next.y > r && i.next.y !== i.y && s < (i.next.x - i.x) * (r - i.y) / (i.next.y - i.y) + i.x && (n = !n), i = i.next; } while (i !== t); return n; }(t, e)); } function y(t, e, i) { return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y); } function m(t, e) { return t.x === e.x && t.y === e.y; } function x(t, e, i, n) { return !!(m(t, e) && m(i, n) || m(t, n) && m(i, e)) || y(t, e, i) > 0 != y(t, e, n) > 0 && y(i, n, t) > 0 != y(i, n, e) > 0; } function w(t, e) { return y(t.prev, t, t.next) < 0 ? y(t, e, t.next) >= 0 && y(t, t.prev, e) >= 0 : y(t, e, t.prev) < 0 || y(t, t.next, e) < 0; } function b(t, e) { const i = new A(t.i, t.x, t.y); const n = new A(e.i, e.x, e.y); const s = t.next; const r = e.prev; return t.next = e, e.prev = t, i.next = s, s.prev = i, n.next = i, i.prev = n, r.next = n, n.prev = r, n; } function T(t, e, i, n) { const s = new A(t, e, i); return n ? (s.next = n.next, s.prev = n, n.next.prev = s, n.next = s) : (s.prev = s, s.next = s), s; } function S(t) { t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ); } function A(t, e, i) { this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1; } function C(t, e, i, n) { for (var s = 0, r = e, o = i - n; r < i; r += n)s += (t[o] - t[r]) * (t[r + 1] + t[o + 1]), o = r; return s; }t.exports = n, n.deviation = function (t, e, i, n) { const s = e && e.length; const r = s ? e[0] * i : t.length; let o = Math.abs(C(t, 0, r, i)); if (s) for (var a = 0, h = e.length; a < h; a++) { const l = e[a] * i; const u = a < h - 1 ? e[a + 1] * i : t.length; o -= Math.abs(C(t, l, u, i)); } let c = 0; for (a = 0; a < n.length; a += 3) { const d = n[a] * i; const f = n[a + 1] * i; const p = n[a + 2] * i; c += Math.abs((t[d] - t[p]) * (t[f + 1] - t[d + 1]) - (t[d] - t[f]) * (t[p + 1] - t[d + 1])); } return o === 0 && c === 0 ? 0 : Math.abs((c - o) / o); }, n.flatten = function (t) { for (var e = t[0][0].length, i = { vertices: [], holes: [], dimensions: e }, n = 0, s = 0; s < t.length; s++) { for (let r = 0; r < t[s].length; r++) for (let o = 0; o < e; o++)i.vertices.push(t[s][r][o]); s > 0 && (n += t[s - 1].length, i.holes.push(n)); } return i; };
}, function (t, e, i) {
  const n = i(0); const s = i(117); const r = i(257); const o = i(200); const a = i(522); const h = i(521); const l = i(27); const u = i(83); const c = function (t, e, i, n, s) { this.x = t, this.y = e, this.width = i, this.rgb = n, this.alpha = s; }; const d = function (t, e, i, n, s) { this.points = [], this.pointsLength = 1, this.points[0] = new c(t, e, i, n, s); }; const f = new Float32Array([1, 0, 0, 1, 0, 0]); const p = new Float32Array(6e3); let g = 0; const v = []; const y = new n({
    Extends: u,
    Mixins: [o],
    initialize(t) {
      u.call(this, {
        game: t.game,
        renderer: t.renderer,
        gl: t.renderer.gl,
        topology: t.topology ? t.topology : t.renderer.gl.TRIANGLES,
        vertShader: t.vertShader ? t.vertShader : h,
        fragShader: t.fragShader ? t.fragShader : a,
        vertexCapacity: t.vertexCapcity ? t.vertexCapacity : 12e3,
        vertexSize: t.vertexSize ? t.vertexSize : 2 * Float32Array.BYTES_PER_ELEMENT + 4 * Uint8Array.BYTES_PER_ELEMENT,
        attributes: [{
          name: 'inPosition', size: 2, type: t.renderer.gl.FLOAT, normalized: !1, offset: 0,
        }, {
          name: 'inTint', size: 4, type: t.renderer.gl.UNSIGNED_BYTE, normalized: !0, offset: 2 * Float32Array.BYTES_PER_ELEMENT,
        }],
      }), this.vertexViewF32 = new Float32Array(this.vertexData), this.vertexViewU32 = new Uint32Array(this.vertexData), this.tempTriangle = [{
        x: 0, y: 0, width: 0, rgb: 16777215, alpha: 1,
      }, {
        x: 0, y: 0, width: 0, rgb: 16777215, alpha: 1,
      }, {
        x: 0, y: 0, width: 0, rgb: 16777215, alpha: 1,
      }, {
        x: 0, y: 0, width: 0, rgb: 16777215, alpha: 1,
      }], this.polygonCache = [], this.mvpInit();
    },
    onBind() { return u.prototype.onBind.call(this), this.mvpUpdate(), this; },
    resize(t, e, i) { return u.prototype.resize.call(this, t, e, i), this.projOrtho(0, this.width, this.height, 0, -1e3, 1e3), this; },
    batchFillRect(t, e, i, n, s, r, o, a, h, u, c, d, f, p, g, v, y, m) { this.renderer.setPipeline(this), this.vertexCount + 6 > this.vertexCapacity && this.flush(); const x = this.vertexViewF32; const w = this.vertexViewU32; const b = this.vertexCount * this.vertexComponentCount; const T = r + a; const S = o + h; const A = m[0]; const C = m[1]; const M = m[2]; const _ = m[3]; const E = d * A + f * M; const P = d * C + f * _; const L = p * A + g * M; const F = p * C + g * _; const k = v * A + y * M + m[4]; const R = v * C + y * _ + m[5]; const O = r * E + o * L + k; const B = r * P + o * F + R; const D = r * E + S * L + k; const I = r * P + S * F + R; const z = T * E + S * L + k; const Y = T * P + S * F + R; const X = T * E + o * L + k; const N = T * P + o * F + R; const V = l.getTintAppendFloatAlphaAndSwap(u, c); x[b + 0] = O, x[b + 1] = B, w[b + 2] = V, x[b + 3] = D, x[b + 4] = I, w[b + 5] = V, x[b + 6] = z, x[b + 7] = Y, w[b + 8] = V, x[b + 9] = O, x[b + 10] = B, w[b + 11] = V, x[b + 12] = z, x[b + 13] = Y, w[b + 14] = V, x[b + 15] = X, x[b + 16] = N, w[b + 17] = V, this.vertexCount += 6; },
    batchFillTriangle(t, e, i, n, s, r, o, a, h, u, c, d, f, p, g, v, y, m, x, w) { this.renderer.setPipeline(this), this.vertexCount + 3 > this.vertexCapacity && this.flush(); const b = this.vertexViewF32; const T = this.vertexViewU32; const S = this.vertexCount * this.vertexComponentCount; const A = w[0]; const C = w[1]; const M = w[2]; const _ = w[3]; const E = p * A + g * M; const P = p * C + g * _; const L = v * A + y * M; const F = v * C + y * _; const k = m * A + x * M + w[4]; const R = m * C + x * _ + w[5]; const O = r * E + o * L + k; const B = r * P + o * F + R; const D = a * E + h * L + k; const I = a * P + h * F + R; const z = u * E + c * L + k; const Y = u * P + c * F + R; const X = l.getTintAppendFloatAlphaAndSwap(d, f); b[S + 0] = O, b[S + 1] = B, T[S + 2] = X, b[S + 3] = D, b[S + 4] = I, T[S + 5] = X, b[S + 6] = z, b[S + 7] = Y, T[S + 8] = X, this.vertexCount += 3; },
    batchStrokeTriangle(t, e, i, n, s, r, o, a, h, l, u, c, d, f, p, g, v, y, m, x, w) { const b = this.tempTriangle; b[0].x = r, b[0].y = o, b[0].width = c, b[0].rgb = d, b[0].alpha = f, b[1].x = a, b[1].y = h, b[1].width = c, b[1].rgb = d, b[1].alpha = f, b[2].x = l, b[2].y = u, b[2].width = c, b[2].rgb = d, b[2].alpha = f, b[3].x = r, b[3].y = o, b[3].width = c, b[3].rgb = d, b[3].alpha = f, this.batchStrokePath(t, e, i, n, s, b, c, d, f, p, g, v, y, m, x, !1, w); },
    batchFillPath(t, e, i, n, s, o, a, h, u, c, d, f, p, g, v) { this.renderer.setPipeline(this); for (var y, m, x, w, b, T, S, A, C, M, _, E, P, L, F, k, R, O = o.length, B = this.polygonCache, D = this.vertexViewF32, I = this.vertexViewU32, z = 0, Y = v[0], X = v[1], N = v[2], V = v[3], W = u * Y + c * N, G = u * X + c * V, U = d * Y + f * N, H = d * X + f * V, j = p * Y + g * N + v[4], q = p * X + g * V + v[5], K = l.getTintAppendFloatAlphaAndSwap(a, h), J = 0; J < O; ++J)m = o[J], B.push(m.x, m.y); O = (y = r(B)).length; for (let Z = 0; Z < O; Z += 3)x = 2 * y[Z + 0], w = 2 * y[Z + 1], b = 2 * y[Z + 2], this.vertexCount + 3 > this.vertexCapacity && this.flush(), z = this.vertexCount * this.vertexComponentCount, E = (T = B[x + 0]) * W + (S = B[x + 1]) * U + j, P = T * G + S * H + q, L = (A = B[w + 0]) * W + (C = B[w + 1]) * U + j, F = A * G + C * H + q, k = (M = B[b + 0]) * W + (_ = B[b + 1]) * U + j, R = M * G + _ * H + q, D[z + 0] = E, D[z + 1] = P, I[z + 2] = K, D[z + 3] = L, D[z + 4] = F, I[z + 5] = K, D[z + 6] = k, D[z + 7] = R, I[z + 8] = K, this.vertexCount += 3; B.length = 0; },
    batchStrokePath(t, e, i, n, s, r, o, a, h, u, c, d, f, p, g, v, y) { let m; let x; this.renderer.setPipeline(this); for (var w, b, T, S, A = r.length, C = this.polygonCache, M = this.vertexViewF32, _ = this.vertexViewU32, E = l.getTintAppendFloatAlphaAndSwap, P = 0; P + 1 < A; P += 1)m = r[P], x = r[P + 1], S = this.batchLine(t, e, i, n, s, m.x, m.y, x.x, x.y, m.width / 2, x.width / 2, m.rgb, x.rgb, h, u, c, d, f, p, g, y), C.push(S); for (let L = 1, F = C.length; L < F; ++L) this.vertexCount + 6 > this.vertexCapacity && this.flush(), w = C[L - 1] || C[F - 1], b = C[L], M[(T = this.vertexCount * this.vertexComponentCount) + 0] = w[6], M[T + 1] = w[7], _[T + 2] = E(w[8], h), M[T + 3] = w[0], M[T + 4] = w[1], _[T + 5] = E(w[2], h), M[T + 6] = b[9], M[T + 7] = b[10], _[T + 8] = E(b[11], h), M[T + 9] = w[0], M[T + 10] = w[1], _[T + 11] = E(w[2], h), M[T + 12] = w[6], M[T + 13] = w[7], _[T + 14] = E(w[8], h), M[T + 15] = b[3], M[T + 16] = b[4], _[T + 17] = E(b[5], h), this.vertexCount += 6; C.length = 0; },
    batchLine(t, e, i, n, s, r, o, a, h, u, c, d, f, p, g, v, y, m, x, w, b) { this.renderer.setPipeline(this), this.vertexCount + 6 > this.vertexCapacity && this.flush(); const T = b[0]; const S = b[1]; const A = b[2]; const C = b[3]; const M = g * T + v * A; const _ = g * S + v * C; const E = y * T + m * A; const P = y * S + m * C; const L = x * T + w * A + b[4]; const F = x * S + w * C + b[5]; const k = this.vertexViewF32; const R = this.vertexViewU32; const O = a - r; const B = h - o; const D = Math.sqrt(O * O + B * B); const I = u * (h - o) / D; const z = u * (r - a) / D; const Y = c * (h - o) / D; const X = c * (r - a) / D; const N = a - Y; const V = h - X; const W = r - I; const G = o - z; const U = a + Y; const H = h + X; const j = r + I; const q = o + z; const K = N * M + V * E + L; const J = N * _ + V * P + F; const Z = W * M + G * E + L; const Q = W * _ + G * P + F; const $ = U * M + H * E + L; const tt = U * _ + H * P + F; const et = j * M + q * E + L; const it = j * _ + q * P + F; const nt = l.getTintAppendFloatAlphaAndSwap; const st = nt(d, p); const rt = nt(f, p); const ot = this.vertexCount * this.vertexComponentCount; return k[ot + 0] = K, k[ot + 1] = J, R[ot + 2] = rt, k[ot + 3] = Z, k[ot + 4] = Q, R[ot + 5] = st, k[ot + 6] = $, k[ot + 7] = tt, R[ot + 8] = rt, k[ot + 9] = Z, k[ot + 10] = Q, R[ot + 11] = st, k[ot + 12] = et, k[ot + 13] = it, R[ot + 14] = st, k[ot + 15] = $, k[ot + 16] = tt, R[ot + 17] = rt, this.vertexCount += 6, [K, J, f, Z, Q, d, $, tt, f, et, it, d]; },
    batchGraphics(t, e, i) { if (!(t.commandBuffer.length <= 0)) { let n = null; i && (n = i.matrix), this.renderer.setPipeline(this); let r; let o; let a; let h; let l; let u; let y; let m; const x = e.scrollX * t.scrollFactorX; const w = e.scrollY * t.scrollFactorY; const b = t.x; const T = t.y; const S = t.scaleX; const A = t.scaleY; const C = t.rotation; const M = t.commandBuffer; const _ = t.alpha; let E = 1; let P = 1; let L = 0; let F = 0; let k = 1; const R = e.matrix.matrix; let O = null; let B = 0; let D = 0; let I = 0; let z = 0; let Y = 0; let X = 0; let N = 0; let V = 0; let W = 0; let G = 0; let U = null; const H = Math.sin; const j = Math.cos; const q = 2 * Math.PI; const K = H(C); const J = j(C); let Z = J * S; let Q = K * S; let $ = -K * A; let tt = J * A; let et = b; let it = T; const nt = R[0]; const st = R[1]; const rt = R[2]; let ot = R[3]; const at = R[4]; const ht = R[5]; if (n) { const lt = n[0]; const ut = n[1]; const ct = n[2]; const dt = n[3]; const ft = n[4]; const pt = n[5]; const gt = -x; const vt = -w; const yt = lt * nt + ut * rt; const mt = lt * st + ut * ot; const xt = ct * nt + dt * rt; const wt = ct * st + dt * ot; r = Z * yt + Q * xt, o = Z * mt + Q * wt, a = $ * yt + tt * xt, h = $ * mt + tt * wt, l = et * yt + it * xt + (ft * nt + pt * rt + (gt * nt + vt * rt + at)), u = et * mt + it * wt + (ft * st + pt * ot + (gt * st + vt * ot + ht)); } else r = Z * nt + Q * rt, o = Z * st + Q * ot, a = $ * nt + tt * rt, h = $ * st + tt * ot, l = (et -= x) * nt + (it -= w) * rt + at, u = et * st + it * ot + ht; v.length = 0; for (let bt = 0, Tt = M.length; bt < Tt; ++bt) switch (ot = M[bt]) { case s.ARC: for (B = 0, Y = M[bt + 1], X = M[bt + 2], N = M[bt + 3], V = M[bt + 4], W = M[bt + 5], G = M[bt + 6], O === null && (O = new d(Y + j(V) * N, X + H(V) * N, k, L, E * _), v.push(O), B += 0.01), W -= V, G ? W < -q ? W = -q : W > 0 && (W = W % q - q) : W > q ? W = q : W < 0 && (W = q + W % q); B < 1;)D = Y + j(z = W * B + V) * N, I = X + H(z) * N, O.points.push(new c(D, I, k, L, E * _)), B += 0.01; D = Y + j(z = W + V) * N, I = X + H(z) * N, O.points.push(new c(D, I, k, L, E * _)), bt += 6; break; case s.LINE_STYLE: k = M[bt + 1], L = M[bt + 2], E = M[bt + 3], bt += 3; break; case s.FILL_STYLE: F = M[bt + 1], P = M[bt + 2], bt += 2; break; case s.BEGIN_PATH: v.length = 0, O = null; break; case s.CLOSE_PATH: O && O.points.length && O.points.push(O.points[0]); break; case s.FILL_PATH: for (y = 0, m = v.length; y < m; ++y) this.batchFillPath(b, T, S, A, C, v[y].points, F, P * _, r, o, a, h, l, u, f); break; case s.STROKE_PATH: for (y = 0, m = v.length; y < m; ++y)U = v[y], this.batchStrokePath(b, T, S, A, C, U.points, k, L, E * _, r, o, a, h, l, u, U === this._lastPath, f); break; case s.FILL_RECT: this.batchFillRect(b, T, S, A, C, M[bt + 1], M[bt + 2], M[bt + 3], M[bt + 4], F, P * _, r, o, a, h, l, u, f), bt += 4; break; case s.FILL_TRIANGLE: this.batchFillTriangle(b, T, S, A, C, M[bt + 1], M[bt + 2], M[bt + 3], M[bt + 4], M[bt + 5], M[bt + 6], F, P * _, r, o, a, h, l, u, f), bt += 6; break; case s.STROKE_TRIANGLE: this.batchStrokeTriangle(b, T, S, A, C, M[bt + 1], M[bt + 2], M[bt + 3], M[bt + 4], M[bt + 5], M[bt + 6], k, L, E * _, r, o, a, h, l, u, f), bt += 6; break; case s.LINE_TO: O !== null ? O.points.push(new c(M[bt + 1], M[bt + 2], k, L, E * _)) : (O = new d(M[bt + 1], M[bt + 2], k, L, E * _), v.push(O)), bt += 2; break; case s.MOVE_TO: O = new d(M[bt + 1], M[bt + 2], k, L, E * _), v.push(O), bt += 2; break; case s.LINE_FX_TO: O !== null ? O.points.push(new c(M[bt + 1], M[bt + 2], M[bt + 3], M[bt + 4], M[bt + 5] * _)) : (O = new d(M[bt + 1], M[bt + 2], M[bt + 3], M[bt + 4], M[bt + 5] * _), v.push(O)), bt += 5; break; case s.MOVE_FX_TO: O = new d(M[bt + 1], M[bt + 2], M[bt + 3], M[bt + 4], M[bt + 5] * _), v.push(O), bt += 5; break; case s.SAVE: p[g + 0] = f[0], p[g + 1] = f[1], p[g + 2] = f[2], p[g + 3] = f[3], p[g + 4] = f[4], p[g + 5] = f[5], g += 6; break; case s.RESTORE: g -= 6, f[0] = p[g + 0], f[1] = p[g + 1], f[2] = p[g + 2], f[3] = p[g + 3], f[4] = p[g + 4], f[5] = p[g + 5]; break; case s.TRANSLATE: Y = M[bt + 1], X = M[bt + 2], f[4] = f[0] * Y + f[2] * X + f[4], f[5] = f[1] * Y + f[3] * X + f[5], bt += 2; break; case s.SCALE: Y = M[bt + 1], X = M[bt + 2], f[0] *= Y, f[1] *= Y, f[2] *= X, f[3] *= X, bt += 2; break; case s.ROTATE: Y = H(X = M[bt + 1]), X = j(X), Z = f[0], Q = f[1], $ = f[2], tt = f[3], f[0] = X * Z + Y * $, f[1] = X * Q + Y * tt, f[2] = -Y * Z + X * $, f[3] = -Y * Q + X * tt, bt += 1; break; default: console.error(`Phaser: Invalid Graphics Command ID ${ot}`); } } },
    drawStaticTilemapLayer() {},
    drawEmitterManager() {},
    drawBlitter() {},
    batchSprite() {},
    batchMesh() {},
    batchBitmapText() {},
    batchDynamicBitmapText() {},
    batchText() {},
    batchDynamicTilemapLayer() {},
    batchTileSprite() {},
  }); t.exports = y;
}, function (t, e, i) {
  const n = i(0); const s = i(524); const r = i(523); const o = i(83); const a = new n({
    Extends: o,
    initialize(t) {
      o.call(this, {
        game: t.game,
        renderer: t.renderer,
        gl: t.renderer.gl,
        topology: t.topology ? t.topology : t.renderer.gl.TRIANGLES,
        vertShader: t.vertShader ? t.vertShader : r,
        fragShader: t.fragShader ? t.fragShader : s,
        vertexCapacity: t.vertexCapacity ? t.vertexCapacity : 3,
        vertexSize: t.vertexSize ? t.vertexSize : 2 * Float32Array.BYTES_PER_ELEMENT,
        vertices: new Float32Array([-1, 1, -1, -7, 7, 1]).buffer,
        attributes: [{
          name: 'inPosition', size: 2, type: t.renderer.gl.FLOAT, normalized: !1, offset: 0,
        }],
      }), this.vertexViewF32 = new Float32Array(this.vertexData), this.maxQuads = 1, this.resolutionDirty = !0;
    },
    onBind() { o.prototype.onBind.call(this); const t = this.renderer; const e = this.program; return this.resolutionDirty && (t.setFloat2(e, 'uResolution', this.width, this.height), t.setInt1(e, 'uMainSampler', 0), t.setInt1(e, 'uMaskSampler', 1), this.resolutionDirty = !1), this; },
    resize(t, e, i) { return o.prototype.resize.call(this, t, e, i), this.resolutionDirty = !0, this; },
    beginMask(t, e, i) { const n = t.bitmapMask; const s = this.renderer; const r = this.gl; const o = n.visible; n && r && (s.setFramebuffer(t.maskFramebuffer), r.clearColor(0, 0, 0, 0), r.clear(r.COLOR_BUFFER_BIT), n.visible = !0, n.renderWebGL(s, n, 0, i), n.visible = o, s.flush(), s.setFramebuffer(t.mainFramebuffer), r.clearColor(0, 0, 0, 0), r.clear(r.COLOR_BUFFER_BIT)); },
    endMask(t) { const e = t.bitmapMask; const i = this.renderer; const n = this.gl; e && (i.setFramebuffer(null), i.setPipeline(this), i.setTexture2D(t.maskTexture, 1), i.setTexture2D(t.mainTexture, 0), i.setInt1(this.program, 'uInvertMaskAlpha', t.invertAlpha), n.drawArrays(this.topology, 0, 3)); },
  }); t.exports = a;
}, function (t, e) { t.exports = function (t, e, i) { e || (e = 'image/png'), i || (i = 0.92); const n = t.getContext('experimental-webgl'); const s = new Uint8Array(n.drawingBufferWidth * n.drawingBufferHeight * 4); n.readPixels(0, 0, n.drawingBufferWidth, n.drawingBufferHeight, n.RGBA, n.UNSIGNED_BYTE, s); let r; const o = document.createElement('canvas'); const a = o.getContext('2d'); o.width = n.drawingBufferWidth, o.height = n.drawingBufferHeight; for (let h = (r = a.getImageData(0, 0, o.width, o.height)).data, l = 0; l < o.height; l += 1) for (let u = 0; u < o.width; u += 1) { const c = 4 * ((o.height - l) * o.width + u); const d = 4 * (l * o.width + u); h[d + 0] = s[c + 0], h[d + 1] = s[c + 1], h[d + 2] = s[c + 2], h[d + 3] = s[c + 3]; }a.putImageData(r, 0, 0); const f = o.toDataURL(e, i); const p = new Image(); return p.src = f, p; }; }, function (t, e, i) {
  const n = i(0); const s = i(20); const r = i(84); const o = i(55); const a = i(27); const h = i(260); const l = i(259); const u = i(258); const c = i(147); const d = i(126); const f = new n({
    initialize(t) {
      const e = this; const i = t.config; const n = {
        alpha: i.transparent, depth: !1, antialias: i.antialias, premultipliedAlpha: i.premultipliedAlpha, stencil: !0, preserveDrawingBuffer: i.preserveDrawingBuffer, failIfMajorPerformanceCaveat: i.failIfMajorPerformanceCaveat, powerPreference: i.powerPreference,
      }; this.config = {
        clearBeforeRender: i.clearBeforeRender, pixelArt: i.pixelArt, backgroundColor: i.backgroundColor, contextCreation: n, resolution: i.resolution, autoResize: i.autoResize, roundPixels: i.roundPixels, maxTextures: i.maxTextures, maxTextureSize: i.maxTextureSize,
      }, this.game = t, this.type = s.WEBGL, this.width = t.config.width, this.height = t.config.height, this.canvas = t.canvas, this.lostContextCallbacks = [], this.restoredContextCallbacks = [], this.blendModes = [], this.nativeTextures = [], this.contextLost = !1, this.pipelines = null, this.snapshotState = { callback: null, type: null, encoder: null }, this.currentActiveTextureUnit = 0, this.currentTextures = new Array(16), this.currentFramebuffer = null, this.currentPipeline = null, this.currentProgram = null, this.currentVertexBuffer = null, this.currentIndexBuffer = null, this.currentBlendMode = 1 / 0, this.currentScissorEnabled = !1, this.currentScissor = new Uint32Array([0, 0, this.width, this.height]), this.currentScissorIdx = 0, this.scissorStack = new Uint32Array(4e3), this.canvas.addEventListener('webglcontextlost', (t) => { e.contextLost = !0, t.preventDefault(); for (let i = 0; i < e.lostContextCallbacks.length; ++i) { const n = e.lostContextCallbacks[i]; n[0].call(n[1], e); } }, !1), this.canvas.addEventListener('webglcontextrestored', () => { e.contextLost = !1, e.init(e.config); for (let t = 0; t < e.restoredContextCallbacks.length; ++t) { const i = e.restoredContextCallbacks[t]; i[0].call(i[1], e); } }, !1), this.gl = null, this.supportedExtensions = null, this.extensions = {}, this.glFormats = [], this.compression = { ETC1: !1, PVRTC: !1, S3TC: !1 }, this.init(this.config);
    },
    init(t) { let e; const i = this.canvas; const n = t.backgroundColor; if (!(e = this.game.config.context ? this.game.config.context : i.getContext('webgl', t.contextCreation) || i.getContext('experimental-webgl', t.contextCreation)) || e.isContextLost()) throw this.contextLost = !0, new Error('This browser does not support WebGL. Try using the Canvas pipeline.'); this.gl = e, this.game.context = e; for (let r = 0; r <= 16; r++) this.blendModes.push({ func: [e.ONE, e.ONE_MINUS_SRC_ALPHA], equation: e.FUNC_ADD }); this.blendModes[1].func = [e.ONE, e.DST_ALPHA], this.blendModes[2].func = [e.DST_COLOR, e.ONE_MINUS_SRC_ALPHA], this.blendModes[3].func = [e.ONE, e.ONE_MINUS_SRC_COLOR], this.glFormats[0] = e.BYTE, this.glFormats[1] = e.SHORT, this.glFormats[2] = e.UNSIGNED_BYTE, this.glFormats[3] = e.UNSIGNED_SHORT, this.glFormats[4] = e.FLOAT; const o = e.getSupportedExtensions(); t.maxTextures || (t.maxTextures = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)), t.maxTextureSize || (t.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE)); const a = 'WEBGL_compressed_texture_'; const h = `WEBKIT_${a}`; this.compression.ETC1 = e.getExtension(`${a}etc1`) || e.getExtension(`${h}etc1`), this.compression.PVRTC = e.getExtension(`${a}pvrtc`) || e.getExtension(`${h}pvrtc`), this.compression.S3TC = e.getExtension(`${a}s3tc`) || e.getExtension(`${h}s3tc`), this.supportedExtensions = o, e.disable(e.DEPTH_TEST), e.disable(e.CULL_FACE), e.disable(e.SCISSOR_TEST), e.enable(e.BLEND), e.clearColor(n.redGL, n.greenGL, n.blueGL, 1); for (let f = 0; f < this.currentTextures.length; ++f) this.currentTextures[f] = null; return this.pipelines = {}, this.addPipeline('TextureTintPipeline', new d({ game: this.game, renderer: this })), this.addPipeline('FlatTintPipeline', new u({ game: this.game, renderer: this })), this.addPipeline('BitmapMaskPipeline', new l({ game: this.game, renderer: this })), this.addPipeline('Light2D', new c({ game: this.game, renderer: this })), this.setBlendMode(s.BlendModes.NORMAL), this.resize(this.width, this.height), this; },
    resize(t, e) { const i = this.gl; const n = this.pipelines; const s = this.config.resolution; for (const r in this.width = Math.floor(t * s), this.height = Math.floor(e * s), this.canvas.width = this.width, this.canvas.height = this.height, this.config.autoResize && (this.canvas.style.width = `${this.width / s}px`, this.canvas.style.height = `${this.height / s}px`), i.viewport(0, 0, this.width, this.height), n)n[r].resize(t, e, s); return this.currentScissor.set([0, 0, this.width, this.height]), this; },
    onContextRestored(t, e) { return this.restoredContextCallbacks.push([t, e]), this; },
    onContextLost(t, e) { return this.lostContextCallbacks.push([t, e]), this; },
    hasExtension(t) { return !!this.supportedExtensions && this.supportedExtensions.indexOf(t); },
    getExtension(t) { return this.hasExtension(t) ? (t in this.extensions || (this.extensions[t] = this.gl.getExtension(t)), this.extensions[t]) : null; },
    flush() { this.currentPipeline && this.currentPipeline.flush(); },
    hasPipeline(t) { return t in this.pipelines; },
    getPipeline(t) { return this.hasPipeline(t) ? this.pipelines[t] : null; },
    removePipeline(t) { return delete this.pipelines[t], this; },
    addPipeline(t, e) { return this.hasPipeline(t) ? console.warn('Pipeline', t, ' already exists.') : this.pipelines[t] = e, e.name = t, this.pipelines[t].resize(this.width, this.height, this.config.resolution), e; },
    setScissor(t, e, i, n) { const s = this.gl; const r = this.currentScissor; const o = t === 0 && e === 0 && i === s.canvas.width && n === s.canvas.height && i >= 0 && n >= 0; return r[0] === t && r[1] === e && r[2] === i && r[3] === n || this.flush(), r[0] = t, r[1] = e, r[2] = i, r[3] = n, this.currentScissorEnabled = o, o ? (s.disable(s.SCISSOR_TEST), this) : (s.enable(s.SCISSOR_TEST), s.scissor(t, s.drawingBufferHeight - e - n, i, n), this); },
    pushScissor(t, e, i, n) { const s = this.scissorStack; const r = this.currentScissorIdx; const o = this.currentScissor; return s[r + 0] = o[0], s[r + 1] = o[1], s[r + 2] = o[2], s[r + 3] = o[3], this.currentScissorIdx += 4, this.setScissor(t, e, i, n), this; },
    popScissor() { const t = this.scissorStack; const e = this.currentScissorIdx - 4; const i = t[e + 0]; const n = t[e + 1]; const s = t[e + 2]; const r = t[e + 3]; return this.currentScissorIdx = e, this.setScissor(i, n, s, r), this; },
    setPipeline(t) { return this.currentPipeline === t && this.currentPipeline.vertexBuffer === this.currentVertexBuffer && this.currentPipeline.program === this.currentProgram || (this.flush(), this.currentPipeline = t, this.currentPipeline.bind()), this.currentPipeline.onBind(), this.currentPipeline; },
    setBlendMode(t) { const e = this.gl; const i = this.blendModes[t]; return t !== s.BlendModes.SKIP_CHECK && this.currentBlendMode !== t && (this.flush(), e.enable(e.BLEND), e.blendEquation(i.equation), i.func.length > 2 ? e.blendFuncSeparate(i.func[0], i.func[1], i.func[2], i.func[3]) : e.blendFunc(i.func[0], i.func[1]), this.currentBlendMode = t), this; },
    addBlendMode(t, e) { return this.blendModes.push({ func: t, equation: e }) - 1; },
    updateBlendMode(t, e, i) { return this.blendModes[t] && (this.blendModes[t].func = e, i && (this.blendModes[t].equation = i)), this; },
    removeBlendMode(t) { return t > 16 && this.blendModes[t] && this.blendModes.splice(t, 1), this; },
    setTexture2D(t, e) { const i = this.gl; return t !== this.currentTextures[e] && (this.flush(), this.currentActiveTextureUnit !== e && (i.activeTexture(i.TEXTURE0 + e), this.currentActiveTextureUnit = e), i.bindTexture(i.TEXTURE_2D, t), this.currentTextures[e] = t), this; },
    setFramebuffer(t) { const e = this.gl; return t !== this.currentFramebuffer && (this.flush(), e.bindFramebuffer(e.FRAMEBUFFER, t), this.currentFramebuffer = t), this; },
    setProgram(t) { const e = this.gl; return t !== this.currentProgram && (this.flush(), e.useProgram(t), this.currentProgram = t), this; },
    setVertexBuffer(t) { const e = this.gl; return t !== this.currentVertexBuffer && (this.flush(), e.bindBuffer(e.ARRAY_BUFFER, t), this.currentVertexBuffer = t), this; },
    setIndexBuffer(t) { const e = this.gl; return t !== this.currentIndexBuffer && (this.flush(), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t), this.currentIndexBuffer = t), this; },
    createTextureFromSource(t, e, i, n) { const o = this.gl; let a = o.NEAREST; let h = o.CLAMP_TO_EDGE; return e = t ? t.width : e, i = t ? t.height : i, r(e, i) && (h = o.REPEAT), n === s.ScaleModes.LINEAR ? a = o.LINEAR : (n === s.ScaleModes.NEAREST || this.config.pixelArt) && (a = o.NEAREST), t || typeof e !== 'number' || typeof i !== 'number' ? this.createTexture2D(0, a, a, h, h, o.RGBA, t) : this.createTexture2D(0, a, a, h, h, o.RGBA, null, e, i); },
    createTexture2D(t, e, i, n, s, r, o, a, h, l) { const u = this.gl; const c = u.createTexture(); return l = void 0 === l || l === null || l, this.setTexture2D(c, 0), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MIN_FILTER, e), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MAG_FILTER, i), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_S, s), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_T, n), u.pixelStorei(u.UNPACK_PREMULTIPLY_ALPHA_WEBGL, l), o === null || void 0 === o ? u.texImage2D(u.TEXTURE_2D, t, r, a, h, 0, r, u.UNSIGNED_BYTE, null) : (u.texImage2D(u.TEXTURE_2D, t, r, r, u.UNSIGNED_BYTE, o), a = o.width, h = o.height), this.setTexture2D(null, 0), c.isAlphaPremultiplied = l, c.isRenderTexture = !1, c.width = a, c.height = h, this.nativeTextures.push(c), c; },
    createFramebuffer(t, e, i, n) {
      let s; const r = this.gl; const o = r.createFramebuffer(); if (this.setFramebuffer(o), n) { const a = r.createRenderbuffer(); r.bindRenderbuffer(r.RENDERBUFFER, a), r.renderbufferStorage(r.RENDERBUFFER, r.DEPTH_STENCIL, t, e), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, a); } if (i.isRenderTexture = !0, i.isAlphaPremultiplied = !1, r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, i, 0), (s = r.checkFramebufferStatus(r.FRAMEBUFFER)) !== r.FRAMEBUFFER_COMPLETE) {
        throw new Error(`Framebuffer incomplete. Framebuffer status: ${{
          36054: 'Incomplete Attachment', 36055: 'Missing Attachment', 36057: 'Incomplete Dimensions', 36061: 'Framebuffer Unsupported',
        }[s]}`);
      } return o.renderTexture = i, this.setFramebuffer(null), o;
    },
    createProgram(t, e) { const i = this.gl; const n = i.createProgram(); const s = i.createShader(i.VERTEX_SHADER); const r = i.createShader(i.FRAGMENT_SHADER); if (i.shaderSource(s, t), i.shaderSource(r, e), i.compileShader(s), i.compileShader(r), !i.getShaderParameter(s, i.COMPILE_STATUS)) throw new Error(`Failed to compile Vertex Shader:\n${i.getShaderInfoLog(s)}`); if (!i.getShaderParameter(r, i.COMPILE_STATUS)) throw new Error(`Failed to compile Fragment Shader:\n${i.getShaderInfoLog(r)}`); if (i.attachShader(n, s), i.attachShader(n, r), i.linkProgram(n), !i.getProgramParameter(n, i.LINK_STATUS)) throw new Error(`Failed to link program:\n${i.getProgramInfoLog(n)}`); return n; },
    createVertexBuffer(t, e) { const i = this.gl; const n = i.createBuffer(); return this.setVertexBuffer(n), i.bufferData(i.ARRAY_BUFFER, t, e), this.setVertexBuffer(null), n; },
    createIndexBuffer(t, e) { const i = this.gl; const n = i.createBuffer(); return this.setIndexBuffer(n), i.bufferData(i.ELEMENT_ARRAY_BUFFER, t, e), this.setIndexBuffer(null), n; },
    deleteTexture(t) { const e = this.nativeTextures.indexOf(t); return e !== -1 && o(this.nativeTextures, e), this.gl.deleteTexture(t), this; },
    deleteFramebuffer(t) { return this.gl.deleteFramebuffer(t), this; },
    deleteProgram(t) { return this.gl.deleteProgram(t), this; },
    deleteBuffer(t) { return this.gl.deleteBuffer(t), this; },
    preRenderCamera(t) { const e = this.config.resolution; const i = Math.floor(t.x * e); const n = Math.floor(t.y * e); const s = Math.floor(t.width * e); const r = Math.floor(t.height * e); if (this.pushScissor(i, n, s, r), t.backgroundColor.alphaGL > 0) { const o = t.backgroundColor; const h = this.pipelines.FlatTintPipeline; h.batchFillRect(0, 0, 1, 1, 0, t.x, t.y, t.width, t.height, a.getTintFromFloats(o.redGL, o.greenGL, o.blueGL, 1), o.alphaGL, 1, 0, 0, 1, 0, 0, [1, 0, 0, 1, 0, 0]), h.flush(); } },
    postRenderCamera(t) { const e = this.pipelines.FlatTintPipeline; const i = t.flashEffect.postRenderWebGL(e, a.getTintFromFloats); (t.fadeEffect.postRenderWebGL(e, a.getTintFromFloats) || i) && e.flush(), this.popScissor(); },
    preRender() { if (!this.contextLost) { const t = this.gl; const e = this.config.backgroundColor; const i = this.pipelines; for (const n in t.clearColor(e.redGL, e.greenGL, e.blueGL, e.alphaGL), this.config.clearBeforeRender && t.clear(t.COLOR_BUFFER_BIT | t.DEPTH_BUFFER_BIT | t.STENCIL_BUFFER_BIT), i)i[n].onPreRender(); } },
    render(t, e, i, n) { if (!this.contextLost) { const r = e.list; const o = r.length; const a = this.pipelines; for (const h in a)a[h].onRender(t, n); this.preRenderCamera(n); for (let l = 0; l < o; ++l) { const u = r[l]; u.willRender() && (u.blendMode !== this.currentBlendMode && this.setBlendMode(u.blendMode), u.mask && u.mask.preRenderWebGL(this, u, n), u.renderWebGL(this, u, i, n), u.mask && u.mask.postRenderWebGL(this, u)); } this.flush(), this.setBlendMode(s.BlendModes.NORMAL), this.postRenderCamera(n); } },
    postRender() { if (!this.contextLost) { this.snapshotState.callback && (this.snapshotState.callback(h(this.canvas, this.snapshotState.type, this.snapshotState.encoder)), this.snapshotState.callback = null); const t = this.pipelines; for (const e in t)t[e].onPostRender(); } },
    snapshot(t, e, i) { return this.snapshotState.callback = t, this.snapshotState.type = e, this.snapshotState.encoder = i, this; },
    canvasToTexture(t, e) { const i = this.gl; if (e) this.setTexture2D(e, 0), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, i.RGBA, i.UNSIGNED_BYTE, t), e.width = t.width, e.height = t.height, this.setTexture2D(null, 0); else { let n = i.CLAMP_TO_EDGE; r(t.width, t.height) && (n = i.REPEAT), e = this.createTexture2D(0, i.NEAREST, i.NEAREST, n, n, i.RGBA, t, t.width, t.height, !0); } return e; },
    setTextureFilter(t, e) { const i = this.gl; const n = [i.LINEAR, i.NEAREST][e]; return this.setTexture2D(t, 0), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, n), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, n), this.setTexture2D(null, 0), this; },
    setFloat1(t, e, i) { return this.setProgram(t), this.gl.uniform1f(this.gl.getUniformLocation(t, e), i), this; },
    setFloat2(t, e, i, n) { return this.setProgram(t), this.gl.uniform2f(this.gl.getUniformLocation(t, e), i, n), this; },
    setFloat3(t, e, i, n, s) { return this.setProgram(t), this.gl.uniform3f(this.gl.getUniformLocation(t, e), i, n, s), this; },
    setFloat4(t, e, i, n, s, r) { return this.setProgram(t), this.gl.uniform4f(this.gl.getUniformLocation(t, e), i, n, s, r), this; },
    setInt1(t, e, i) { return this.setProgram(t), this.gl.uniform1i(this.gl.getUniformLocation(t, e), i), this; },
    setInt2(t, e, i, n) { return this.setProgram(t), this.gl.uniform2i(this.gl.getUniformLocation(t, e), i, n), this; },
    setInt3(t, e, i, n, s) { return this.setProgram(t), this.gl.uniform3i(this.gl.getUniformLocation(t, e), i, n, s), this; },
    setInt4(t, e, i, n, s, r) { return this.setProgram(t), this.gl.uniform4i(this.gl.getUniformLocation(t, e), i, n, s, r), this; },
    setMatrix2(t, e, i, n) { return this.setProgram(t), this.gl.uniformMatrix2fv(this.gl.getUniformLocation(t, e), i, n), this; },
    setMatrix3(t, e, i, n) { return this.setProgram(t), this.gl.uniformMatrix3fv(this.gl.getUniformLocation(t, e), i, n), this; },
    setMatrix4(t, e, i, n) { return this.setProgram(t), this.gl.uniformMatrix4fv(this.gl.getUniformLocation(t, e), i, n), this; },
    getMaxTextures() { return this.config.maxTextures; },
    getMaxTextureSize() { return this.config.maxTextureSize; },
    destroy() { for (const t in this.pipelines) this.pipelines[t].destroy(), delete this.pipelines[t]; for (let e = 0; e < this.nativeTextures.length; ++e) this.deleteTexture(this.nativeTextures[e]), delete this.nativeTextures[e]; delete this.gl, delete this.game, this.contextLost = !0, this.extensions = {}, this.nativeTextures.length = 0; },
  }); t.exports = f;
}, function (t, e, i) { const n = i(50); const s = i(201); t.exports = function () { const t = []; const e = s.supportNewBlendModes; return t[n.NORMAL] = 'source-over', t[n.ADD] = 'lighter', t[n.MULTIPLY] = e ? 'multiply' : 'source-over', t[n.SCREEN] = e ? 'screen' : 'source-over', t[n.OVERLAY] = e ? 'overlay' : 'source-over', t[n.DARKEN] = e ? 'darken' : 'source-over', t[n.LIGHTEN] = e ? 'lighten' : 'source-over', t[n.COLOR_DODGE] = e ? 'color-dodge' : 'source-over', t[n.COLOR_BURN] = e ? 'color-burn' : 'source-over', t[n.HARD_LIGHT] = e ? 'hard-light' : 'source-over', t[n.SOFT_LIGHT] = e ? 'soft-light' : 'source-over', t[n.DIFFERENCE] = e ? 'difference' : 'source-over', t[n.EXCLUSION] = e ? 'exclusion' : 'source-over', t[n.HUE] = e ? 'hue' : 'source-over', t[n.SATURATION] = e ? 'saturation' : 'source-over', t[n.COLOR] = e ? 'color' : 'source-over', t[n.LUMINOSITY] = e ? 'luminosity' : 'source-over', t; }; }, function (t, e) { let i = !1; const n = function (t, e, n) { const s = this.currentContext; const r = t.frame; const o = r.canvasData; this.currentBlendMode !== t.blendMode && (this.currentBlendMode = t.blendMode, s.globalCompositeOperation = this.blendModes[t.blendMode]), this.currentAlpha !== t.alpha && (this.currentAlpha = t.alpha, s.globalAlpha = t.alpha), this.currentScaleMode !== t.scaleMode && (this.currentScaleMode = t.scaleMode); let a = r.x; let h = r.y; let l = 1; let u = 1; t.flipX ? (l = -1, a -= o.dWidth - t.displayOriginX) : a -= t.displayOriginX, t.flipY ? (u = -1, h -= o.dHeight - t.displayOriginY) : h -= t.displayOriginY; let c = t.x - e.scrollX * t.scrollFactorX; let d = t.y - e.scrollY * t.scrollFactorY; if (i && (c |= 0, d |= 0, a |= 0, h |= 0), s.save(), n) { const f = n.matrix; s.transform(f[0], f[1], f[2], f[3], f[4], f[5]); }s.translate(c, d), s.rotate(t.rotation), s.scale(t.scaleX, t.scaleY), s.scale(l, u), s.drawImage(r.source.image, o.sx, o.sy, o.sWidth, o.sHeight, a, h, o.dWidth, o.dHeight), s.restore(); }; t.exports = function (t) { return i = t, n; }; }, function (t, e) { t.exports = function (t, e, i) { void 0 === e && (e = 'image/png'), void 0 === i && (i = 0.92); const n = t.toDataURL(e, i); const s = new Image(); return s.src = n, s; }; }, function (t, e) { let i = !1; const n = function (t, e, n) { const s = this.currentContext; const r = n.canvasData; i && (t |= 0, e |= 0), s.drawImage(n.source.image, r.sx, r.sy, r.sWidth, r.sHeight, t, e, r.dWidth, r.dHeight); }; t.exports = function (t) { return i = t, n; }; }, function (t, e, i) {
  const n = i(265); const s = i(264); const r = i(0); const o = i(20); const a = i(263); const h = i(262); const l = i(58); const u = i(128); const c = new r({
    initialize(t) {
      this.game = t, this.type = o.CANVAS, this.drawCount = 0, this.width = t.config.width, this.height = t.config.height, this.config = {
        clearBeforeRender: t.config.clearBeforeRender, pixelArt: t.config.pixelArt, backgroundColor: t.config.backgroundColor, resolution: t.config.resolution, autoResize: t.config.autoResize, roundPixels: t.config.roundPixels,
      }, this.scaleMode = t.config.pixelArt ? l.NEAREST : l.LINEAR, this.gameCanvas = t.canvas, this.gameContext = this.game.config.context ? this.game.config.context : this.gameCanvas.getContext('2d'), this.currentContext = this.gameContext, this.drawImage = a(this.config.roundPixels), this.blitImage = n(this.config.roundPixels), this.blendModes = h(), this.currentAlpha = 1, this.currentBlendMode = 0, this.currentScaleMode = 0, this.snapshotCallback = null, this.snapshotType = null, this.snapshotEncoder = null, this.init();
    },
    init() { this.resize(this.width, this.height); },
    resize(t, e) { const i = this.config.resolution; this.width = t * i, this.height = e * i, this.gameCanvas.width = this.width, this.gameCanvas.height = this.height, this.config.autoResize && (this.gameCanvas.style.width = `${this.width / i}px`, this.gameCanvas.style.height = `${this.height / i}px`), this.scaleMode === l.NEAREST && u.disable(this.gameContext); },
    onContextLost() {},
    onContextRestored() {},
    resetTransform() { this.currentContext.setTransform(1, 0, 0, 1, 0, 0); },
    setBlendMode(t) { return this.currentBlendMode !== t && (this.currentContext.globalCompositeOperation = t, this.currentBlendMode = t), this.currentBlendMode; },
    setAlpha(t) { return this.currentAlpha !== t && (this.currentContext.globalAlpha = t, this.currentAlpha = t), this.currentAlpha; },
    preRender() { const t = this.gameContext; const e = this.config; const i = this.width; const n = this.height; e.clearBeforeRender && t.clearRect(0, 0, i, n), e.transparent || (t.fillStyle = e.backgroundColor.rgba, t.fillRect(0, 0, i, n)), this.drawCount = 0; },
    render(t, e, i, n) { const s = t.sys.context; const r = n.x !== 0 || n.y !== 0 || n.width !== s.canvas.width || n.height !== s.canvas.height; const o = e.list; const a = this.config.resolution; this.currentContext = s, n.transparent || (s.fillStyle = n.backgroundColor.rgba, s.fillRect(n.x, n.y, n.width, n.height)), this.currentAlpha !== 1 && (s.globalAlpha = 1, this.currentAlpha = 1), this.currentBlendMode !== 0 && (s.globalCompositeOperation = 'source-over', this.currentBlendMode = 0), this.currentScaleMode = 0, this.drawCount += o.length, r && (s.save(), s.beginPath(), s.rect(n.x * a, n.y * a, n.width * a, n.height * a), s.clip()); const h = n.matrix.matrix; s.setTransform(h[0], h[1], h[2], h[3], h[4], h[5]); for (let l = 0; l < o.length; l++) { const u = o[l]; u.mask && u.mask.preRenderCanvas(this, u, n), u.renderCanvas(this, u, i, n), u.mask && u.mask.postRenderCanvas(this, u, n); }s.setTransform(1, 0, 0, 1, 0, 0), s.globalCompositeOperation = 'source-over', n.flashEffect.postRenderCanvas(s), n.fadeEffect.postRenderCanvas(s), r && s.restore(); },
    postRender() { const t = this.gameContext; t.globalAlpha = 1, t.globalCompositeOperation = 'source-over', this.currentAlpha = 1, this.currentBlendMode = 0, this.snapshotCallback && (this.snapshotCallback(s(this.gameCanvas, this.snapshotType, this.snapshotEncoder)), this.snapshotCallback = null); },
    snapshot(t, e, i) { this.snapshotCallback = t, this.snapshotType = e, this.snapshotEncoder = i; },
    destroy() { this.gameCanvas = null, this.gameContext = null, this.game = null; },
  }); t.exports = c;
}, function (t, e, i) {
  const n = i(0); const s = i(3); const r = new n({
    initialize() { this.isRunning = !1, this.callback = s, this.tick = 0, this.isSetTimeOut = !1, this.timeOutID = null, this.lastTime = 0; const t = this; this.step = function e(i) { t.lastTime = t.tick, t.tick = i, t.callback(i), t.timeOutID = window.requestAnimationFrame(e); }, this.stepTimeout = function e() { const i = Date.now(); const n = Math.max(16 + t.lastTime - i, 0); t.lastTime = t.tick, t.tick = i, t.callback(i), t.timeOutID = window.setTimeout(e, n); }; }, start(t, e) { this.isRunning || (this.callback = t, this.isSetTimeOut = e, this.isRunning = !0, this.timeOutID = e ? window.setTimeout(this.stepTimeout, 0) : window.requestAnimationFrame(this.step)); }, stop() { this.isRunning = !1, this.isSetTimeOut ? clearTimeout(this.timeOutID) : window.cancelAnimationFrame(this.timeOutID); }, destroy() { this.stop(), this.callback = s; },
  }); t.exports = r;
}, function (t, e) { t.exports = function (t) { t.parentNode && t.parentNode.removeChild(t); }; }, function (t, e) { t.exports = function (t) { let e = ''; try { window.DOMParser ? e = (new DOMParser()).parseFromString(t, 'text/xml') : (e = new ActiveXObject('Microsoft.XMLDOM')).loadXML(t); } catch (t) { e = null; } return e && e.documentElement && !e.getElementsByTagName('parsererror').length ? e : null; }; }, function (t, e, i) { const n = i(56); t.exports = function (t) { if (document.readyState !== 'complete' && document.readyState !== 'interactive') { var e = function () { document.removeEventListener('deviceready', e, !0), document.removeEventListener('DOMContentLoaded', e, !0), window.removeEventListener('load', e, !0), t(); }; document.body ? n.cordova && !n.cocoonJS ? document.addEventListener('deviceready', e, !1) : (document.addEventListener('DOMContentLoaded', e, !0), window.addEventListener('load', e, !0)) : window.setTimeout(e, 20); } else t(); }; }, function (t, e) { t.exports = function (t, e) { return Math.floor(Math.random() * (e - t + 1) + t); }; }, function (t, e) { t.exports = { setCrisp(t) { return ['optimizeSpeed', 'crisp-edges', '-moz-crisp-edges', '-webkit-optimize-contrast', 'optimize-contrast', 'pixelated'].forEach((e) => { t.style['image-rendering'] = e; }), t.style.msInterpolationMode = 'nearest-neighbor', t; }, setBicubic(t) { return t.style['image-rendering'] = 'auto', t.style.msInterpolationMode = 'bicubic', t; } }; }, function (t, e) { t.exports = function (t, e, i, n, s) { const r = 0.5 * (n - e); const o = 0.5 * (s - i); const a = t * t; return (2 * i - 2 * n + r + o) * (t * a) + (-3 * i + 3 * n - 2 * r - o) * a + r * t + i; }; }, function (t, e, i) { const n = i(14); t.exports = function (t, e) { if (void 0 === e && (e = new n()), t.length === 0) return e; for (var i, s, r, o = Number.MAX_VALUE, a = Number.MAX_VALUE, h = Number.MIN_SAFE_INTEGER, l = Number.MIN_SAFE_INTEGER, u = 0; u < t.length; u++)i = t[u], Array.isArray(i) ? (s = i[0], r = i[1]) : (s = i.x, r = i.y), o = Math.min(o, s), a = Math.min(a, r), h = Math.max(h, s), l = Math.max(l, r); return e.x = o, e.y = a, e.width = h - o, e.height = l - a, e; }; }, function (t, e) {
  t.exports = {
    0: '#000', 1: '#9D9D9D', 2: '#FFF', 3: '#BE2633', 4: '#E06F8B', 5: '#493C2B', 6: '#A46422', 7: '#EB8931', 8: '#F7E26B', 9: '#2F484E', A: '#44891A', B: '#A3CE27', C: '#1B2632', D: '#005784', E: '#31A2F2', F: '#B2DCEF',
  };
}, function (t, e, i) { const n = i(275); const s = i(22); const r = i(4); t.exports = function (t) { const e = r(t, 'data', []); let i = r(t, 'canvas', null); const o = r(t, 'palette', n); const a = r(t, 'pixelWidth', 1); const h = r(t, 'pixelHeight', a); let l = r(t, 'resizeCanvas', !0); let u = r(t, 'clearCanvas', !0); const c = r(t, 'preRender', null); const d = r(t, 'postRender', null); const f = Math.floor(Math.abs(e[0].length * a)); const p = Math.floor(Math.abs(e.length * h)); i || (i = s.create2D(this, f, p), l = !1, u = !1), l && (i.width = f, i.height = p); const g = i.getContext('2d'); u && g.clearRect(0, 0, f, p), c && c(i, g); for (let v = 0; v < e.length; v++) for (let y = e[v], m = 0; m < y.length; m++) { const x = y[m]; x !== '.' && x !== ' ' && (g.fillStyle = o[x], g.fillRect(m * a, v * h, a, h)); } return d && d(i, g), i; }; }, function (t, e, i) {
  var n = new (i(0))({
    initialize(t, e, i, n) { this.x = 0, this.y = 0, this.z = 0, this.w = 0, typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0, this.w = t.w || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = n || 0); }, clone() { return new n(this.x, this.y, this.z, this.w); }, copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z || 0, this.w = t.w || 0, this; }, equals(t) { return this.x === t.x && this.y === t.y && this.z === t.z && this.w === t.w; }, set(t, e, i, n) { return typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0, this.w = t.w || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = n || 0), this; }, add(t) { return this.x += t.x, this.y += t.y, this.z += t.z || 0, this.w += t.w || 0, this; }, subtract(t) { return this.x -= t.x, this.y -= t.y, this.z -= t.z || 0, this.w -= t.w || 0, this; }, scale(t) { return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this; }, length() { const t = this.x; const e = this.y; const i = this.z; const n = this.w; return Math.sqrt(t * t + e * e + i * i + n * n); }, lengthSq() { const t = this.x; const e = this.y; const i = this.z; const n = this.w; return t * t + e * e + i * i + n * n; }, normalize() { const t = this.x; const e = this.y; const i = this.z; const n = this.w; let s = t * t + e * e + i * i + n * n; return s > 0 && (s = 1 / Math.sqrt(s), this.x = t * s, this.y = e * s, this.z = i * s, this.w = n * s), this; }, dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w; }, lerp(t, e) { void 0 === e && (e = 0); const i = this.x; const n = this.y; const s = this.z; const r = this.w; return this.x = i + e * (t.x - i), this.y = n + e * (t.y - n), this.z = s + e * (t.z - s), this.w = r + e * (t.w - r), this; }, multiply(t) { return this.x *= t.x, this.y *= t.y, this.z *= t.z || 1, this.w *= t.w || 1, this; }, divide(t) { return this.x /= t.x, this.y /= t.y, this.z /= t.z || 1, this.w /= t.w || 1, this; }, distance(t) { const e = t.x - this.x; const i = t.y - this.y; const n = t.z - this.z || 0; const s = t.w - this.w || 0; return Math.sqrt(e * e + i * i + n * n + s * s); }, distanceSq(t) { const e = t.x - this.x; const i = t.y - this.y; const n = t.z - this.z || 0; const s = t.w - this.w || 0; return e * e + i * i + n * n + s * s; }, negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this; }, transformMat4(t) { const e = this.x; const i = this.y; const n = this.z; const s = this.w; const r = t.val; return this.x = r[0] * e + r[4] * i + r[8] * n + r[12] * s, this.y = r[1] * e + r[5] * i + r[9] * n + r[13] * s, this.z = r[2] * e + r[6] * i + r[10] * n + r[14] * s, this.w = r[3] * e + r[7] * i + r[11] * n + r[15] * s, this; }, transformQuat(t) { const e = this.x; const i = this.y; const n = this.z; const s = t.x; const r = t.y; const o = t.z; const a = t.w; const h = a * e + r * n - o * i; const l = a * i + o * e - s * n; const u = a * n + s * i - r * e; const c = -s * e - r * i - o * n; return this.x = h * a + c * -s + l * -o - u * -r, this.y = l * a + c * -r + u * -s - h * -o, this.z = u * a + c * -o + h * -r - l * -s, this; }, reset() { return this.x = 0, this.y = 0, this.z = 0, this.w = 0, this; },
  }); n.prototype.sub = n.prototype.subtract, n.prototype.mul = n.prototype.multiply, n.prototype.div = n.prototype.divide, n.prototype.dist = n.prototype.distance, n.prototype.distSq = n.prototype.distanceSq, n.prototype.len = n.prototype.length, n.prototype.lenSq = n.prototype.lengthSq, t.exports = n;
}, function (t, e, i) {
  var n = new (i(0))({
    initialize(t) { this.val = new Float32Array(16), t ? this.copy(t) : this.identity(); }, clone() { return new n(this); }, set(t) { return this.copy(t); }, copy(t) { const e = this.val; const i = t.val; return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], this; }, fromArray(t) { const e = this.val; return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], this; }, zero() { const t = this.val; return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 0, this; }, xyz(t, e, i) { this.identity(); const n = this.val; return n[12] = t, n[13] = e, n[14] = i, this; }, scaling(t, e, i) { this.zero(); const n = this.val; return n[0] = t, n[5] = e, n[10] = i, n[15] = 1, this; }, identity() { const t = this.val; return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this; }, transpose() { const t = this.val; const e = t[1]; const i = t[2]; const n = t[3]; const s = t[6]; const r = t[7]; const o = t[11]; return t[1] = t[4], t[2] = t[8], t[3] = t[12], t[4] = e, t[6] = t[9], t[7] = t[13], t[8] = i, t[9] = s, t[11] = t[14], t[12] = n, t[13] = r, t[14] = o, this; }, invert() { const t = this.val; const e = t[0]; const i = t[1]; const n = t[2]; const s = t[3]; const r = t[4]; const o = t[5]; const a = t[6]; const h = t[7]; const l = t[8]; const u = t[9]; const c = t[10]; const d = t[11]; const f = t[12]; const p = t[13]; const g = t[14]; const v = t[15]; const y = e * o - i * r; const m = e * a - n * r; const x = e * h - s * r; const w = i * a - n * o; const b = i * h - s * o; const T = n * h - s * a; const S = l * p - u * f; const A = l * g - c * f; const C = l * v - d * f; const M = u * g - c * p; const _ = u * v - d * p; const E = c * v - d * g; let P = y * E - m * _ + x * M + w * C - b * A + T * S; return P ? (P = 1 / P, t[0] = (o * E - a * _ + h * M) * P, t[1] = (n * _ - i * E - s * M) * P, t[2] = (p * T - g * b + v * w) * P, t[3] = (c * b - u * T - d * w) * P, t[4] = (a * C - r * E - h * A) * P, t[5] = (e * E - n * C + s * A) * P, t[6] = (g * x - f * T - v * m) * P, t[7] = (l * T - c * x + d * m) * P, t[8] = (r * _ - o * C + h * S) * P, t[9] = (i * C - e * _ - s * S) * P, t[10] = (f * b - p * x + v * y) * P, t[11] = (u * x - l * b - d * y) * P, t[12] = (o * A - r * M - a * S) * P, t[13] = (e * M - i * A + n * S) * P, t[14] = (p * m - f * w - g * y) * P, t[15] = (l * w - u * m + c * y) * P, this) : null; }, adjoint() { const t = this.val; const e = t[0]; const i = t[1]; const n = t[2]; const s = t[3]; const r = t[4]; const o = t[5]; const a = t[6]; const h = t[7]; const l = t[8]; const u = t[9]; const c = t[10]; const d = t[11]; const f = t[12]; const p = t[13]; const g = t[14]; const v = t[15]; return t[0] = o * (c * v - d * g) - u * (a * v - h * g) + p * (a * d - h * c), t[1] = -(i * (c * v - d * g) - u * (n * v - s * g) + p * (n * d - s * c)), t[2] = i * (a * v - h * g) - o * (n * v - s * g) + p * (n * h - s * a), t[3] = -(i * (a * d - h * c) - o * (n * d - s * c) + u * (n * h - s * a)), t[4] = -(r * (c * v - d * g) - l * (a * v - h * g) + f * (a * d - h * c)), t[5] = e * (c * v - d * g) - l * (n * v - s * g) + f * (n * d - s * c), t[6] = -(e * (a * v - h * g) - r * (n * v - s * g) + f * (n * h - s * a)), t[7] = e * (a * d - h * c) - r * (n * d - s * c) + l * (n * h - s * a), t[8] = r * (u * v - d * p) - l * (o * v - h * p) + f * (o * d - h * u), t[9] = -(e * (u * v - d * p) - l * (i * v - s * p) + f * (i * d - s * u)), t[10] = e * (o * v - h * p) - r * (i * v - s * p) + f * (i * h - s * o), t[11] = -(e * (o * d - h * u) - r * (i * d - s * u) + l * (i * h - s * o)), t[12] = -(r * (u * g - c * p) - l * (o * g - a * p) + f * (o * c - a * u)), t[13] = e * (u * g - c * p) - l * (i * g - n * p) + f * (i * c - n * u), t[14] = -(e * (o * g - a * p) - r * (i * g - n * p) + f * (i * a - n * o)), t[15] = e * (o * c - a * u) - r * (i * c - n * u) + l * (i * a - n * o), this; }, determinant() { const t = this.val; const e = t[0]; const i = t[1]; const n = t[2]; const s = t[3]; const r = t[4]; const o = t[5]; const a = t[6]; const h = t[7]; const l = t[8]; const u = t[9]; const c = t[10]; const d = t[11]; const f = t[12]; const p = t[13]; const g = t[14]; const v = t[15]; return (e * o - i * r) * (c * v - d * g) - (e * a - n * r) * (u * v - d * p) + (e * h - s * r) * (u * g - c * p) + (i * a - n * o) * (l * v - d * f) - (i * h - s * o) * (l * g - c * f) + (n * h - s * a) * (l * p - u * f); }, multiply(t) { const e = this.val; const i = e[0]; const n = e[1]; const s = e[2]; const r = e[3]; const o = e[4]; const a = e[5]; const h = e[6]; const l = e[7]; const u = e[8]; const c = e[9]; const d = e[10]; const f = e[11]; const p = e[12]; const g = e[13]; const v = e[14]; const y = e[15]; const m = t.val; let x = m[0]; let w = m[1]; let b = m[2]; let T = m[3]; return e[0] = x * i + w * o + b * u + T * p, e[1] = x * n + w * a + b * c + T * g, e[2] = x * s + w * h + b * d + T * v, e[3] = x * r + w * l + b * f + T * y, x = m[4], w = m[5], b = m[6], T = m[7], e[4] = x * i + w * o + b * u + T * p, e[5] = x * n + w * a + b * c + T * g, e[6] = x * s + w * h + b * d + T * v, e[7] = x * r + w * l + b * f + T * y, x = m[8], w = m[9], b = m[10], T = m[11], e[8] = x * i + w * o + b * u + T * p, e[9] = x * n + w * a + b * c + T * g, e[10] = x * s + w * h + b * d + T * v, e[11] = x * r + w * l + b * f + T * y, x = m[12], w = m[13], b = m[14], T = m[15], e[12] = x * i + w * o + b * u + T * p, e[13] = x * n + w * a + b * c + T * g, e[14] = x * s + w * h + b * d + T * v, e[15] = x * r + w * l + b * f + T * y, this; }, multiplyLocal(t) { const e = []; const i = this.val; const n = t.val; return e[0] = i[0] * n[0] + i[1] * n[4] + i[2] * n[8] + i[3] * n[12], e[1] = i[0] * n[1] + i[1] * n[5] + i[2] * n[9] + i[3] * n[13], e[2] = i[0] * n[2] + i[1] * n[6] + i[2] * n[10] + i[3] * n[14], e[3] = i[0] * n[3] + i[1] * n[7] + i[2] * n[11] + i[3] * n[15], e[4] = i[4] * n[0] + i[5] * n[4] + i[6] * n[8] + i[7] * n[12], e[5] = i[4] * n[1] + i[5] * n[5] + i[6] * n[9] + i[7] * n[13], e[6] = i[4] * n[2] + i[5] * n[6] + i[6] * n[10] + i[7] * n[14], e[7] = i[4] * n[3] + i[5] * n[7] + i[6] * n[11] + i[7] * n[15], e[8] = i[8] * n[0] + i[9] * n[4] + i[10] * n[8] + i[11] * n[12], e[9] = i[8] * n[1] + i[9] * n[5] + i[10] * n[9] + i[11] * n[13], e[10] = i[8] * n[2] + i[9] * n[6] + i[10] * n[10] + i[11] * n[14], e[11] = i[8] * n[3] + i[9] * n[7] + i[10] * n[11] + i[11] * n[15], e[12] = i[12] * n[0] + i[13] * n[4] + i[14] * n[8] + i[15] * n[12], e[13] = i[12] * n[1] + i[13] * n[5] + i[14] * n[9] + i[15] * n[13], e[14] = i[12] * n[2] + i[13] * n[6] + i[14] * n[10] + i[15] * n[14], e[15] = i[12] * n[3] + i[13] * n[7] + i[14] * n[11] + i[15] * n[15], this.fromArray(e); }, translate(t) { const e = t.x; const i = t.y; const n = t.z; const s = this.val; return s[12] = s[0] * e + s[4] * i + s[8] * n + s[12], s[13] = s[1] * e + s[5] * i + s[9] * n + s[13], s[14] = s[2] * e + s[6] * i + s[10] * n + s[14], s[15] = s[3] * e + s[7] * i + s[11] * n + s[15], this; }, scale(t) { const e = t.x; const i = t.y; const n = t.z; const s = this.val; return s[0] *= e, s[1] *= e, s[2] *= e, s[3] *= e, s[4] *= i, s[5] *= i, s[6] *= i, s[7] *= i, s[8] *= n, s[9] *= n, s[10] *= n, s[11] *= n, this; }, makeRotationAxis(t, e) { const i = Math.cos(e); const n = Math.sin(e); const s = 1 - i; const r = t.x; const o = t.y; const a = t.z; const h = s * r; const l = s * o; return this.set(h * r + i, h * o - n * a, h * a + n * o, 0, h * o + n * a, l * o + i, l * a - n * r, 0, h * a - n * o, l * a + n * r, s * a * a + i, 0, 0, 0, 0, 1), this; }, rotate(t, e) { const i = this.val; let n = e.x; let s = e.y; let r = e.z; let o = Math.sqrt(n * n + s * s + r * r); if (Math.abs(o) < 1e-6) return null; n *= o = 1 / o, s *= o, r *= o; const a = Math.sin(t); const h = Math.cos(t); const l = 1 - h; const u = i[0]; const c = i[1]; const d = i[2]; const f = i[3]; const p = i[4]; const g = i[5]; const v = i[6]; const y = i[7]; const m = i[8]; const x = i[9]; const w = i[10]; const b = i[11]; const T = n * n * l + h; const S = s * n * l + r * a; const A = r * n * l - s * a; const C = n * s * l - r * a; const M = s * s * l + h; const _ = r * s * l + n * a; const E = n * r * l + s * a; const P = s * r * l - n * a; const L = r * r * l + h; return i[0] = u * T + p * S + m * A, i[1] = c * T + g * S + x * A, i[2] = d * T + v * S + w * A, i[3] = f * T + y * S + b * A, i[4] = u * C + p * M + m * _, i[5] = c * C + g * M + x * _, i[6] = d * C + v * M + w * _, i[7] = f * C + y * M + b * _, i[8] = u * E + p * P + m * L, i[9] = c * E + g * P + x * L, i[10] = d * E + v * P + w * L, i[11] = f * E + y * P + b * L, this; }, rotateX(t) { const e = this.val; const i = Math.sin(t); const n = Math.cos(t); const s = e[4]; const r = e[5]; const o = e[6]; const a = e[7]; const h = e[8]; const l = e[9]; const u = e[10]; const c = e[11]; return e[4] = s * n + h * i, e[5] = r * n + l * i, e[6] = o * n + u * i, e[7] = a * n + c * i, e[8] = h * n - s * i, e[9] = l * n - r * i, e[10] = u * n - o * i, e[11] = c * n - a * i, this; }, rotateY(t) { const e = this.val; const i = Math.sin(t); const n = Math.cos(t); const s = e[0]; const r = e[1]; const o = e[2]; const a = e[3]; const h = e[8]; const l = e[9]; const u = e[10]; const c = e[11]; return e[0] = s * n - h * i, e[1] = r * n - l * i, e[2] = o * n - u * i, e[3] = a * n - c * i, e[8] = s * i + h * n, e[9] = r * i + l * n, e[10] = o * i + u * n, e[11] = a * i + c * n, this; }, rotateZ(t) { const e = this.val; const i = Math.sin(t); const n = Math.cos(t); const s = e[0]; const r = e[1]; const o = e[2]; const a = e[3]; const h = e[4]; const l = e[5]; const u = e[6]; const c = e[7]; return e[0] = s * n + h * i, e[1] = r * n + l * i, e[2] = o * n + u * i, e[3] = a * n + c * i, e[4] = h * n - s * i, e[5] = l * n - r * i, e[6] = u * n - o * i, e[7] = c * n - a * i, this; }, fromRotationTranslation(t, e) { const i = this.val; const n = t.x; const s = t.y; const r = t.z; const o = t.w; const a = n + n; const h = s + s; const l = r + r; const u = n * a; const c = n * h; const d = n * l; const f = s * h; const p = s * l; const g = r * l; const v = o * a; const y = o * h; const m = o * l; return i[0] = 1 - (f + g), i[1] = c + m, i[2] = d - y, i[3] = 0, i[4] = c - m, i[5] = 1 - (u + g), i[6] = p + v, i[7] = 0, i[8] = d + y, i[9] = p - v, i[10] = 1 - (u + f), i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this; }, fromQuat(t) { const e = this.val; const i = t.x; const n = t.y; const s = t.z; const r = t.w; const o = i + i; const a = n + n; const h = s + s; const l = i * o; const u = i * a; const c = i * h; const d = n * a; const f = n * h; const p = s * h; const g = r * o; const v = r * a; const y = r * h; return e[0] = 1 - (d + p), e[1] = u + y, e[2] = c - v, e[3] = 0, e[4] = u - y, e[5] = 1 - (l + p), e[6] = f + g, e[7] = 0, e[8] = c + v, e[9] = f - g, e[10] = 1 - (l + d), e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this; }, frustum(t, e, i, n, s, r) { const o = this.val; const a = 1 / (e - t); const h = 1 / (n - i); const l = 1 / (s - r); return o[0] = 2 * s * a, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = 2 * s * h, o[6] = 0, o[7] = 0, o[8] = (e + t) * a, o[9] = (n + i) * h, o[10] = (r + s) * l, o[11] = -1, o[12] = 0, o[13] = 0, o[14] = r * s * 2 * l, o[15] = 0, this; }, perspective(t, e, i, n) { const s = this.val; const r = 1 / Math.tan(t / 2); const o = 1 / (i - n); return s[0] = r / e, s[1] = 0, s[2] = 0, s[3] = 0, s[4] = 0, s[5] = r, s[6] = 0, s[7] = 0, s[8] = 0, s[9] = 0, s[10] = (n + i) * o, s[11] = -1, s[12] = 0, s[13] = 0, s[14] = 2 * n * i * o, s[15] = 0, this; }, perspectiveLH(t, e, i, n) { const s = this.val; return s[0] = 2 * i / t, s[1] = 0, s[2] = 0, s[3] = 0, s[4] = 0, s[5] = 2 * i / e, s[6] = 0, s[7] = 0, s[8] = 0, s[9] = 0, s[10] = -n / (i - n), s[11] = 1, s[12] = 0, s[13] = 0, s[14] = i * n / (i - n), s[15] = 0, this; }, ortho(t, e, i, n, s, r) { const o = this.val; let a = t - e; let h = i - n; let l = s - r; return a = a === 0 ? a : 1 / a, h = h === 0 ? h : 1 / h, l = l === 0 ? l : 1 / l, o[0] = -2 * a, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = -2 * h, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = 2 * l, o[11] = 0, o[12] = (t + e) * a, o[13] = (n + i) * h, o[14] = (r + s) * l, o[15] = 1, this; }, lookAt(t, e, i) { const n = this.val; const s = t.x; const r = t.y; const o = t.z; const a = i.x; const h = i.y; const l = i.z; const u = e.x; const c = e.y; const d = e.z; if (Math.abs(s - u) < 1e-6 && Math.abs(r - c) < 1e-6 && Math.abs(o - d) < 1e-6) return this.identity(); let f = s - u; let p = r - c; let g = o - d; let v = 1 / Math.sqrt(f * f + p * p + g * g); let y = h * (g *= v) - l * (p *= v); let m = l * (f *= v) - a * g; let x = a * p - h * f; (v = Math.sqrt(y * y + m * m + x * x)) ? (y *= v = 1 / v, m *= v, x *= v) : (y = 0, m = 0, x = 0); let w = p * x - g * m; let b = g * y - f * x; let T = f * m - p * y; return (v = Math.sqrt(w * w + b * b + T * T)) ? (w *= v = 1 / v, b *= v, T *= v) : (w = 0, b = 0, T = 0), n[0] = y, n[1] = w, n[2] = f, n[3] = 0, n[4] = m, n[5] = b, n[6] = p, n[7] = 0, n[8] = x, n[9] = T, n[10] = g, n[11] = 0, n[12] = -(y * s + m * r + x * o), n[13] = -(w * s + b * r + T * o), n[14] = -(f * s + p * r + g * o), n[15] = 1, this; }, yawPitchRoll(t, e, i) { this.zero(), s.zero(), r.zero(); const n = this.val; const o = s.val; const a = r.val; let h = Math.sin(i); let l = Math.cos(i); return n[10] = 1, n[15] = 1, n[0] = l, n[1] = h, n[4] = -h, n[5] = l, h = Math.sin(e), l = Math.cos(e), o[0] = 1, o[15] = 1, o[5] = l, o[10] = l, o[9] = -h, o[6] = h, h = Math.sin(t), l = Math.cos(t), a[5] = 1, a[15] = 1, a[0] = l, a[2] = -h, a[8] = h, a[10] = l, this.multiplyLocal(s), this.multiplyLocal(r), this; }, setWorldMatrix(t, e, i, n, o) { return this.yawPitchRoll(t.y, t.x, t.z), s.scaling(i.x, i.y, i.z), r.xyz(e.x, e.y, e.z), this.multiplyLocal(s), this.multiplyLocal(r), void 0 !== n && this.multiplyLocal(n), void 0 !== o && this.multiplyLocal(o), this; },
  }); var s = new n(); var r = new n(); t.exports = n;
}, function (t, e, i) {
  const n = i(0); const s = i(278); const r = i(554); const o = i(553); const a = i(552); const h = i(70); const l = i(149); const u = i(7); const c = i(86); const d = i(277); const f = new c(); const p = new d(); const g = new c(); const v = new c(); const y = new s(); var m = new n({
    initialize(t) { this.scene = t, this.displayList = t.sys.displayList, this.updateList = t.sys.updateList, this.name = '', this.direction = new c(0, 0, -1), this.up = new c(0, 1, 0), this.position = new c(), this.pixelScale = 128, this.projection = new s(), this.view = new s(), this.combined = new s(), this.invProjectionView = new s(), this.near = 1, this.far = 100, this.ray = { origin: new c(), direction: new c() }, this.viewportWidth = 0, this.viewportHeight = 0, this.billboardMatrixDirty = !0, this.children = new h(); }, setPosition(t, e, i) { return this.position.set(t, e, i), this.update(); }, setScene(t) { return this.scene = t, this; }, setPixelScale(t) { return this.pixelScale = t, this.update(); }, add(t) { return this.children.set(t), this.updateChildren(), t; }, remove(t) { return this.displayList.remove(t.gameObject), this.updateList.remove(t.gameObject), this.children.delete(t), this; }, clear() { for (let t = this.getChildren(), e = 0; e < t.length; e++) this.remove(t[e]); return this; }, getChildren() { return this.children.entries; }, create(t, e, i, n, s, r) { void 0 === r && (r = !0); const o = new l(this.scene, t, e, i, n, s); return this.displayList.add(o.gameObject), this.updateList.add(o.gameObject), o.visible = r, this.children.set(o), this.updateChildren(), o; }, createMultiple(t, e, i, n) { void 0 === n && (n = !0); for (var s = [], r = 0; r < t; r++) { const o = new l(this.scene, 0, 0, 0, e, i); this.displayList.add(o.gameObject), this.updateList.add(o.gameObject), o.visible = n, this.children.set(o), s.push(o); } return s; }, createRect(t, e, i, n) { typeof t === 'number' && (t = { x: t, y: t, z: t }), typeof e === 'number' && (e = { x: e, y: e, z: e }); for (var s = t.x * t.y * t.z, r = this.createMultiple(s, i, n), o = 0, a = 0.5 - t.z / 2; a < t.z / 2; a++) for (let h = 0.5 - t.y / 2; h < t.y / 2; h++) for (let l = 0.5 - t.x / 2; l < t.x / 2; l++) { const u = l * e.x; const c = h * e.y; const d = a * e.z; r[o].position.set(u, c, d), o++; } return this.update(), r; }, randomSphere(t, e) { void 0 === e && (e = this.getChildren()); for (let i = 0; i < e.length; i++)r(e[i].position, t); return this.update(); }, randomCube(t, e) { void 0 === e && (e = this.getChildren()); for (let i = 0; i < e.length; i++)o(e[i].position, t); return this.update(); }, translateChildren(t, e) { void 0 === e && (e = this.getChildren()); for (let i = 0; i < e.length; i++)e[i].position.add(t); return this.update(); }, transformChildren(t, e) { void 0 === e && (e = this.getChildren()); for (let i = 0; i < e.length; i++)e[i].position.transformMat4(t); return this.update(); }, setViewport(t, e) { return this.viewportWidth = t, this.viewportHeight = e, this.update(); }, translate(t, e, i) { return typeof t === 'object' ? (this.position.x += t.x || 0, this.position.y += t.y || 0, this.position.z += t.z || 0) : (this.position.x += t || 0, this.position.y += e || 0, this.position.z += i || 0), this.update(); }, lookAt(t, e, i) { const n = this.direction; const s = this.up; return typeof t === 'object' ? n.copy(t) : n.set(t, e, i), n.subtract(this.position).normalize(), f.copy(n).cross(s).normalize(), s.copy(f).cross(n).normalize(), this.update(); }, rotate(t, e) { return a(this.direction, e, t), a(this.up, e, t), this.update(); }, rotateAround(t, e, i) { return f.copy(t).subtract(this.position), this.translate(f), this.rotate(e, i), this.translate(f.negate()), this.update(); }, project(t, e) { void 0 === e && (e = new d()); const i = this.viewportWidth; const n = this.viewportHeight; const s = m.NEAR_RANGE; const r = m.FAR_RANGE; return p.set(t.x, t.y, t.z, 1), p.transformMat4(this.combined), p.w === 0 && (p.w = 1), p.x /= p.w, p.y /= p.w, p.z /= p.w, e.x = i / 2 * p.x + (0 + i / 2), e.y = n / 2 * p.y + (0 + n / 2), e.z = (r - s) / 2 * p.z + (r + s) / 2, (e.w === 0 || e.w) && (e.w = 1 / p.w), e; }, unproject(t, e) { void 0 === e && (e = new c()); const i = p.set(0, 0, this.viewportWidth, this.viewportHeight); return e.copy(t).unproject(i, this.invProjectionView); }, getPickRay(t, e) { const i = this.ray.origin.set(t, e, 0); const n = this.ray.direction.set(t, e, 1); const s = p.set(0, 0, this.viewportWidth, this.viewportHeight); const r = this.invProjectionView; return i.unproject(s, r), n.unproject(s, r), n.subtract(i).normalize(), this.ray; }, updateChildren() { for (let t = this.children.entries, e = 0; e < t.length; e++)t[e].project(this); return this; }, update() { return this.updateChildren(); }, updateBillboardMatrix() { const t = g.set(this.direction).negate(); const e = v.set(this.up).cross(t).normalize(); const i = f.set(t).cross(e).normalize(); const n = y.val; n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = 0, n[4] = i.x, n[5] = i.y, n[6] = i.z, n[7] = 0, n[8] = t.x, n[9] = t.y, n[10] = t.z, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this.billboardMatrixDirty = !1; }, getPointSize(t, e, i) { void 0 === i && (i = new u()), this.billboardMatrixDirty && this.updateBillboardMatrix(); const n = f; const s = e.x / this.pixelScale / 2; const r = e.y / this.pixelScale / 2; n.set(-s, -r, 0).transformMat4(y).add(t), this.project(n, n); const o = n.x; const a = n.y; n.set(s, r, 0).transformMat4(y).add(t), this.project(n, n); const h = n.x - o; const l = n.y - a; return i.set(h, l); }, destroy() { this.children.clear(), this.scene = void 0, this.children = void 0; }, setX(t) { return this.position.x = t, this.update(); }, setY(t) { return this.position.y = t, this.update(); }, setZ(t) { return this.position.z = t, this.update(); }, x: { get() { return this.position.x; }, set(t) { this.position.x = t, this.update(); } }, y: { get() { return this.position.y; }, set(t) { this.position.y = t, this.update(); } }, z: { get() { return this.position.z; }, set(t) { this.position.z = t, this.update(); } },
  }); m.FAR_RANGE = 1, m.NEAR_RANGE = 0, t.exports = m;
}, function (t, e, i) {
  const n = i(30); t.exports = function (t) {
    const e = new n(); const
      i = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(t.toLowerCase()); if (i) { const s = parseInt(i[1], 10); const r = parseInt(i[2], 10); const o = parseInt(i[3], 10); const a = void 0 !== i[4] ? parseFloat(i[4]) : 1; e.setTo(s, r, o, 255 * a); } return e;
  };
}, function (t, e, i) { const n = i(30); t.exports = function (t) { return new n(t.r, t.g, t.b, t.a); }; }, function (t, e) {
  t.exports = function (t) {
    return t > 16777215 ? {
      a: t >>> 24, r: t >> 16 & 255, g: t >> 8 & 255, b: 255 & t,
    } : {
      a: 255, r: t >> 16 & 255, g: t >> 8 & 255, b: 255 & t,
    };
  };
}, function (t, e, i) { const n = i(30); const s = i(282); t.exports = function (t) { const e = s(t); return new n(e.r, e.g, e.b, e.a); }; }, function (t, e) { t.exports = function (t, e, i, n) { return n << 24 | t << 16 | e << 8 | i; }; }, function (t, e, i) { const n = i(30); t.exports = function (t) { const e = new n(); t = t.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, (t, e, i, n) => e + e + i + i + n + n); const i = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t); if (i) { const s = parseInt(i[1], 16); const r = parseInt(i[2], 16); const o = parseInt(i[3], 16); e.setTo(s, r, o); } return e; }; }, function (t, e) { t.exports = function (t, e, i) { return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t); }; }, function (t, e) { t.exports = function (t, e, i) { return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * t * (t * (6 * t - 15) + 10); }; }, function (t, e) { t.exports = function (t, e, i, n, s) { const r = n + Math.atan2(t.y - i, t.x - e); return t.x = e + s * Math.cos(r), t.y = i + s * Math.sin(r), t; }; }, function (t, e) { t.exports = function (t, e) { void 0 === e && (e = 1); for (var i = null, n = 0; n < e; n++)i = t.pop(), t.unshift(i); return i; }; }, function (t, e) { t.exports = function (t, e) { void 0 === e && (e = 1); for (var i = null, n = 0; n < e; n++)i = t.shift(), t.push(i); return i; }; }, function (t, e) {
  t.exports = {
    defaultPipeline: null, pipeline: null, initPipeline(t) { const e = this.scene.sys.game.renderer; return !!(e && e.gl && e.hasPipeline(t)) && (this.defaultPipeline = e.getPipeline(t), this.pipeline = this.defaultPipeline, !0); }, setPipeline(t) { const e = this.scene.sys.game.renderer; return !!(e && e.gl && e.hasPipeline(t)) && (this.pipeline = e.getPipeline(t), !0); }, resetPipeline() { return this.pipeline = this.defaultPipeline, this.pipeline !== null; }, getPipelineName() { return this.pipeline.name; },
  };
}, function (t, e) { t.exports = function (t, e, i, n) { const s = Math.cos(n); const r = Math.sin(n); const o = t.x - e; const a = t.y - i; return t.x = o * s - a * r + e, t.y = o * r + a * s + i, t; }; }, function (t, e, i) { const n = i(5); t.exports = function (t, e, i) { return void 0 === i && (i = new n()), i.x = t.x1 + (t.x2 - t.x1) * e, i.y = t.y1 + (t.y2 - t.y1) * e, i; }; }, function (t, e, i) { const n = i(132); const s = i(96); t.exports = function (t, e, i, r) { void 0 === r && (r = []), e || (e = s(t) / i); for (let o = 0; o < e; o++) { const a = o / e; r.push(n(t, a)); } return r; }; }, function (t, e) { t.exports = function (t) { return Math.PI * t.radius * 2; }; }, function (t, e, i) { const n = i(295); const s = i(133); const r = i(64); const o = i(16); t.exports = function (t, e, i, a) { void 0 === a && (a = []), e || (e = n(t) / i); for (let h = 0; h < e; h++) { const l = r(h / e, 0, o.PI2); a.push(s(t, l)); } return a; }; }, function (t, e, i) {
  const n = new (i(0))({
    initialize(t) { this.c = 1, this.s0 = 0, this.s1 = 0, this.s2 = 0, this.n = 0, this.signs = [-1, 1], t && this.init(t); }, rnd() { const t = 2091639 * this.s0 + 2.3283064365386963e-10 * this.c; return this.c = 0 | t, this.s0 = this.s1, this.s1 = this.s2, this.s2 = t - this.c, this.s2; }, hash(t) { let e; let i = this.n; t = t.toString(); for (let n = 0; n < t.length; n++)e = 0.02519603282416938 * (i += t.charCodeAt(n)), e -= i = e >>> 0, i = (e *= i) >>> 0, i += 4294967296 * (e -= i); return this.n = i, 2.3283064365386963e-10 * (i >>> 0); }, init(t) { typeof t === 'string' ? this.state(t) : this.sow(t); }, sow(t) { if (this.n = 4022871197, this.s0 = this.hash(' '), this.s1 = this.hash(' '), this.s2 = this.hash(' '), this.c = 1, t) for (let e = 0; e < t.length && t[e] != null; e++) { const i = t[e]; this.s0 -= this.hash(i), this.s0 += ~~(this.s0 < 0), this.s1 -= this.hash(i), this.s1 += ~~(this.s1 < 0), this.s2 -= this.hash(i), this.s2 += ~~(this.s2 < 0); } }, integer() { return 4294967296 * this.rnd(); }, frac() { return this.rnd() + 1.1102230246251565e-16 * (2097152 * this.rnd() | 0); }, real() { return this.integer() + this.frac(); }, integerInRange(t, e) { return Math.floor(this.realInRange(0, e - t + 1) + t); }, between(t, e) { return Math.floor(this.realInRange(0, e - t + 1) + t); }, realInRange(t, e) { return this.frac() * (e - t) + t; }, normal() { return 1 - 2 * this.frac(); }, uuid() { let t = ''; let e = ''; for (e = t = ''; t++ < 36; e += ~t % 5 | 3 * t & 4 ? (15 ^ t ? 8 ^ this.frac() * (20 ^ t ? 16 : 4) : 4).toString(16) : '-');return e; }, pick(t) { return t[this.integerInRange(0, t.length - 1)]; }, sign() { return this.pick(this.signs); }, weightedPick(t) { return t[~~(Math.pow(this.frac(), 2) * (t.length - 1) + 0.5)]; }, timestamp(t, e) { return this.realInRange(t || 9466848e5, e || 1577862e6); }, angle() { return this.integerInRange(-180, 180); }, rotation() { return this.realInRange(-3.1415926, 3.1415926); }, state(t) { return typeof t === 'string' && t.match(/^!rnd/) && (t = t.split(','), this.c = parseFloat(t[1]), this.s0 = parseFloat(t[2]), this.s1 = parseFloat(t[3]), this.s2 = parseFloat(t[4])), ['!rnd', this.c, this.s0, this.s1, this.s2].join(','); }, shuffle(t) { for (let e = t.length - 1, i = e; i > 0; i--) { const n = Math.floor(this.frac() * (e + 1)); const s = t[n]; t[n] = t[i], t[i] = s; } return t; },
  }); t.exports = n;
}, function (t, e, i) { const n = i(133); const s = i(64); const r = i(16); const o = i(5); t.exports = function (t, e, i) { void 0 === i && (i = new o()); const a = s(e, 0, r.PI2); return n(t, a, i); }; }, function (t, e) {
  t.exports = {
    TOP_LEFT: 0, TOP_CENTER: 1, TOP_RIGHT: 2, LEFT_TOP: 3, LEFT_CENTER: 4, LEFT_BOTTOM: 5, CENTER: 6, RIGHT_TOP: 7, RIGHT_CENTER: 8, RIGHT_BOTTOM: 9, BOTTOM_LEFT: 10, BOTTOM_CENTER: 11, BOTTOM_RIGHT: 12,
  };
}, function (t, e, i) {
  const n = {}; t.exports = n; const s = i(140); const r = i(123); const o = i(331); const a = i(139); const h = i(675); const l = i(49); n._warming = 0.4, n._torqueDampen = 1, n._minLength = 1e-6, n.create = function (t) {
    const e = t; e.bodyA && !e.pointA && (e.pointA = { x: 0, y: 0 }), e.bodyB && !e.pointB && (e.pointB = { x: 0, y: 0 }); const i = e.bodyA ? r.add(e.bodyA.position, e.pointA) : e.pointA; const n = e.bodyB ? r.add(e.bodyB.position, e.pointB) : e.pointB; const s = r.magnitude(r.sub(i, n)); e.length = void 0 !== e.length ? e.length : s, e.id = e.id || l.nextId(), e.label = e.label || 'Constraint', e.type = 'constraint', e.stiffness = e.stiffness || (e.length > 0 ? 1 : 0.7), e.damping = e.damping || 0, e.angularStiffness = e.angularStiffness || 0, e.angleA = e.bodyA ? e.bodyA.angle : e.angleA, e.angleB = e.bodyB ? e.bodyB.angle : e.angleB, e.plugin = {}; const o = {
      visible: !0, lineWidth: 2, strokeStyle: '#ffffff', type: 'line', anchors: !0,
    }; return e.length === 0 && e.stiffness > 0.1 ? (o.type = 'pin', o.anchors = !1) : e.stiffness < 0.9 && (o.type = 'spring'), e.render = l.extend(o, e.render), e;
  }, n.preSolveAll = function (t) { for (let e = 0; e < t.length; e += 1) { const i = t[e]; const n = i.constraintImpulse; i.isStatic || n.x === 0 && n.y === 0 && n.angle === 0 || (i.position.x += n.x, i.position.y += n.y, i.angle += n.angle); } }, n.solveAll = function (t, e) { for (var i = 0; i < t.length; i += 1) { var s = t[i]; var r = !s.bodyA || s.bodyA && s.bodyA.isStatic; var o = !s.bodyB || s.bodyB && s.bodyB.isStatic; (r || o) && n.solve(t[i], e); } for (i = 0; i < t.length; i += 1)r = !(s = t[i]).bodyA || s.bodyA && s.bodyA.isStatic, o = !s.bodyB || s.bodyB && s.bodyB.isStatic, r || o || n.solve(t[i], e); }, n.solve = function (t, e) { const i = t.bodyA; const s = t.bodyB; const o = t.pointA; const a = t.pointB; if (i || s) { i && !i.isStatic && (r.rotate(o, i.angle - t.angleA, o), t.angleA = i.angle), s && !s.isStatic && (r.rotate(a, s.angle - t.angleB, a), t.angleB = s.angle); let h = o; let l = a; if (i && (h = r.add(i.position, o)), s && (l = r.add(s.position, a)), h && l) { const u = r.sub(h, l); let c = r.magnitude(u); c < n._minLength && (c = n._minLength); let d; let f; let p; let g; let v; const y = (c - t.length) / c; const m = t.stiffness < 1 ? t.stiffness * e : t.stiffness; const x = r.mult(u, y * m); const w = (i ? i.inverseMass : 0) + (s ? s.inverseMass : 0); const b = w + ((i ? i.inverseInertia : 0) + (s ? s.inverseInertia : 0)); if (t.damping) { const T = r.create(); p = r.div(u, c), v = r.sub(s && r.sub(s.position, s.positionPrev) || T, i && r.sub(i.position, i.positionPrev) || T), g = r.dot(p, v); }i && !i.isStatic && (f = i.inverseMass / w, i.constraintImpulse.x -= x.x * f, i.constraintImpulse.y -= x.y * f, i.position.x -= x.x * f, i.position.y -= x.y * f, t.damping && (i.positionPrev.x -= t.damping * p.x * g * f, i.positionPrev.y -= t.damping * p.y * g * f), d = r.cross(o, x) / b * n._torqueDampen * i.inverseInertia * (1 - t.angularStiffness), i.constraintImpulse.angle -= d, i.angle -= d), s && !s.isStatic && (f = s.inverseMass / w, s.constraintImpulse.x += x.x * f, s.constraintImpulse.y += x.y * f, s.position.x += x.x * f, s.position.y += x.y * f, t.damping && (s.positionPrev.x += t.damping * p.x * g * f, s.positionPrev.y += t.damping * p.y * g * f), d = r.cross(a, x) / b * n._torqueDampen * s.inverseInertia * (1 - t.angularStiffness), s.constraintImpulse.angle += d, s.angle += d); } } }, n.postSolveAll = function (t) { for (let e = 0; e < t.length; e++) { const i = t[e]; const l = i.constraintImpulse; if (!(i.isStatic || l.x === 0 && l.y === 0 && l.angle === 0)) { o.set(i, !1); for (let u = 0; u < i.parts.length; u++) { const c = i.parts[u]; s.translate(c.vertices, l), u > 0 && (c.position.x += l.x, c.position.y += l.y), l.angle !== 0 && (s.rotate(c.vertices, l.angle, i.position), h.rotate(c.axes, l.angle), u > 0 && r.rotateAbout(c.position, l.angle, i.position, c.position)), a.update(c.bounds, c.vertices, i.velocity); }l.angle *= n._warming, l.x *= n._warming, l.y *= n._warming; } } };
}, function (t, e, i) { const n = {}; t.exports = n; const s = i(49); n.on = function (t, e, i) { for (var n, s = e.split(' '), r = 0; r < s.length; r++)n = s[r], t.events = t.events || {}, t.events[n] = t.events[n] || [], t.events[n].push(i); return i; }, n.off = function (t, e, i) { if (e) { typeof e === 'function' && (i = e, e = s.keys(t.events).join(' ')); for (let n = e.split(' '), r = 0; r < n.length; r++) { const o = t.events[n[r]]; const a = []; if (i && o) for (let h = 0; h < o.length; h++)o[h] !== i && a.push(o[h]); t.events[n[r]] = a; } } else t.events = {}; }, n.trigger = function (t, e, i) { let n; let r; let o; let a; if (t.events) { i || (i = {}), n = e.split(' '); for (let h = 0; h < n.length; h++) if (r = n[h], o = t.events[r]) { (a = s.clone(i, !1)).name = r, a.source = t; for (let l = 0; l < o.length; l++)o[l].apply(t, [a]); } } }; }, function (t, e, i) {
  const n = new (i(0))({
    initialize(t) { this.parent = t, this.animationManager = t.scene.sys.anims, this.animationManager.once('remove', this.remove, this), this.isPlaying = !1, this.currentAnim = null, this.currentFrame = null, this._timeScale = 1, this.frameRate = 0, this.duration = 0, this.msPerFrame = 0, this.skipMissedFrames = !0, this._delay = 0, this._repeat = 0, this._repeatDelay = 0, this._yoyo = !1, this.forward = !0, this.accumulator = 0, this.nextTick = 0, this.repeatCounter = 0, this.pendingRepeat = !1, this._paused = !1, this._wasPlaying = !1, this._pendingStop = 0, this._pendingStopValue; }, setDelay(t) { return void 0 === t && (t = 0), this._delay = t, this.parent; }, getDelay() { return this._delay; }, delayedPlay(t, e, i) { return this.play(e, !0, i), this.nextTick += t, this.parent; }, getCurrentKey() { if (this.currentAnim) return this.currentAnim.key; }, load(t, e) { return void 0 === e && (e = 0), this.isPlaying && this.stop(), this.animationManager.load(this, t, e), this.parent; }, pause(t) { return this._paused || (this._paused = !0, this._wasPlaying = this.isPlaying, this.isPlaying = !1), void 0 !== t && this.updateFrame(t), this.parent; }, resume(t) { return this._paused && (this._paused = !1, this.isPlaying = this._wasPlaying), void 0 !== t && this.updateFrame(t), this.parent; }, isPaused: { get() { return this._paused; } }, play(t, e, i) { if (void 0 === e && (e = !1), void 0 === i && (i = 0), e && this.isPlaying && this.currentAnim.key === t) return this.parent; this.load(t, i); const n = this.currentAnim; const s = this.parent; return this.repeatCounter = this._repeat === -1 ? Number.MAX_VALUE : this._repeat, n.getFirstTick(this), this.forward = !0, this.isPlaying = !0, this.pendingRepeat = !1, n.showOnStart && (s.visible = !0), s.emit('animationstart', this.currentAnim, this.currentFrame), s; }, getProgress() { let t = this.currentFrame.progress; return this.forward || (t = 1 - t), t; }, setProgress(t) { return this.forward || (t = 1 - t), this.setCurrentFrame(this.currentAnim.getFrameByProgress(t)), this.parent; }, remove(t) { void 0 === t && (t = this.currentAnim), this.isPlaying && t.key === this.currentAnim.key && (this.stop(), this.setCurrentFrame(this.currentAnim.frames[0])); }, getRepeat() { return this._repeat; }, setRepeat(t) { return this._repeat = t, this.repeatCounter = 0, this.parent; }, getRepeatDelay() { return this._repeatDelay; }, setRepeatDelay(t) { return this._repeatDelay = t, this.parent; }, restart(t) { return void 0 === t && (t = !1), this.currentAnim.getFirstTick(this, t), this.forward = !0, this.isPlaying = !0, this.pendingRepeat = !1, this._paused = !1, this.updateFrame(this.currentAnim.frames[0]), this.parent; }, stop() { this._pendingStop = 0, this.isPlaying = !1; const t = this.parent; return t.emit('animationcomplete', this.currentAnim, this.currentFrame), t; }, stopAfterDelay(t) { return this._pendingStop = 1, this._pendingStopValue = t, this.parent; }, stopOnRepeat() { return this._pendingStop = 2, this.parent; }, stopOnFrame(t) { return this._pendingStop = 3, this._pendingStopValue = t, this.parent; }, setTimeScale(t) { return void 0 === t && (t = 1), this._timeScale = t, this.parent; }, getTimeScale() { return this._timeScale; }, getTotalFrames() { return this.currentAnim.frames.length; }, update(t, e) { if (this.currentAnim && this.isPlaying && !this.currentAnim.paused) { if (this.accumulator += e * this._timeScale, this._pendingStop === 1 && (this._pendingStopValue -= e, this._pendingStopValue <= 0)) return this.currentAnim.completeAnimation(this); this.accumulator >= this.nextTick && this.currentAnim.setFrame(this); } }, setCurrentFrame(t) { const e = this.parent; return this.currentFrame = t, e.texture = t.frame.texture, e.frame = t.frame, e.setSizeToFrame(), t.frame.customPivot ? e.setOrigin(t.frame.pivotX, t.frame.pivotY) : e.updateDisplayOrigin(), e; }, updateFrame(t) { const e = this.setCurrentFrame(t); if (this.isPlaying) { t.setAlpha && (e.alpha = t.alpha); const i = this.currentAnim; e.emit('animationupdate', i, t), this._pendingStop === 3 && this._pendingStopValue === t && this.currentAnim.completeAnimation(this); } }, setYoyo(t) { return void 0 === t && (t = !1), this._yoyo = t, this.parent; }, getYoyo() { return this._yoyo; }, destroy() { this.animationManager.off('remove', this.remove, this), this.animationManager = null, this.parent = null, this.currentAnim = null, this.currentFrame = null; },
  }); t.exports = n;
}, function (t, e, i) {
  const n = i(0); const s = i(159); const r = i(12); const o = i(158); const a = i(60); const h = i(72); const l = new n({
    initialize(t) { this.scene = t, this.systems = t.sys, this.timeScale = 1, this._add = [], this._pending = [], this._active = [], this._destroy = [], this._toProcess = 0, t.sys.events.once('boot', this.boot, this), t.sys.events.on('start', this.start, this); }, boot() { this.systems.events.once('destroy', this.destroy, this); }, start() { const t = this.systems.events; t.on('preupdate', this.preUpdate, this), t.on('update', this.update, this), t.once('shutdown', this.shutdown, this), this.timeScale = 1; }, createTimeline(t) { return o(this, t); }, timeline(t) { const e = o(this, t); return e.paused || (this._add.push(e), this._toProcess++), e; }, create(t) { return h(this, t); }, add(t) { const e = h(this, t); return this._add.push(e), this._toProcess++, e; }, existing(t) { return this._add.push(t), this._toProcess++, this; }, addCounter(t) { const e = s(this, t); return this._add.push(e), this._toProcess++, e; }, preUpdate() { if (this._toProcess !== 0) { let t; let e; let i = this._destroy; const n = this._active; for (t = 0; t < i.length; t++) { e = i[t]; const s = n.indexOf(e); s !== -1 && (e.state = a.REMOVED, n.splice(s, 1)); } for (i.length = 0, i = this._add, t = 0; t < i.length; t++)(e = i[t]).state === a.PENDING_ADD && (e.init() ? (e.play(), this._active.push(e)) : this._pending.push(e)); i.length = 0, this._toProcess = 0; } }, update(t, e) { let i; const n = this._active; e *= this.timeScale; for (let s = 0; s < n.length; s++)(i = n[s]).update(t, e) && (this._destroy.push(i), this._toProcess++); }, makeActive(t) { if (this._add.indexOf(t) === -1 && this._active.indexOf(t) === -1) { const e = this._pending.indexOf(t); return e !== -1 && this._pending.splice(e, 1), this._add.push(t), t.state = a.PENDING_ADD, this._toProcess++, this; } }, each(t, e) { for (var i = [null], n = 1; n < arguments.length; n++)i.push(arguments[n]); for (const s in this.list)i[0] = this.list[s], t.apply(e, i); }, getAllTweens() { for (var t = this._active, e = [], i = 0; i < t.length; i++)e.push(t[i]); return e; }, getGlobalTimeScale() { return this.timeScale; }, getTweensOf(t) { let e; let i; const n = this._active; const s = []; if (Array.isArray(t)) for (i = 0; i < n.length; i++) { e = n[i]; for (;t.length > 0; i++)e.hasTarget(t[0]) && s.push(e); } else for (i = 0; i < n.length; i++)(e = n[i]).hasTarget(t) && s.push(e); return s; }, isTweening(t) { for (var e, i = this._active, n = 0; n < i.length; n++) if ((e = i[n]).hasTarget(t) && e.isPlaying()) return !0; return !1; }, killAll() { for (let t = this.getAllTweens(), e = 0; e < t.length; e++)t[e].stop(); return this; }, killTweensOf(t) { for (let e = this.getTweensOf(t), i = 0; i < e.length; i++)e[i].stop(); return this; }, pauseAll() { for (let t = this._active, e = 0; e < t.length; e++)t[e].pause(); return this; }, resumeAll() { for (let t = this._active, e = 0; e < t.length; e++)t[e].resume(); return this; }, setGlobalTimeScale(t) { return this.timeScale = t, this; }, shutdown() { this.killAll(), this._add = [], this._pending = [], this._active = [], this._destroy = [], this._toProcess = 0; const t = this.systems.events; t.off('preupdate', this.preUpdate, this), t.off('update', this.update, this), t.off('shutdown', this.shutdown, this); }, destroy() { this.shutdown(), this.scene.sys.events.off('start', this.start, this), this.scene = null, this.systems = null; },
  }); r.register('TweenManager', l, 'tweens'), t.exports = l;
}, function (t, e) { t.exports = ['callbackScope', 'completeDelay', 'delay', 'duration', 'ease', 'easeParams', 'flipX', 'flipY', 'hold', 'loop', 'loopDelay', 'offset', 'onComplete', 'onCompleteParams', 'onCompleteScope', 'onLoop', 'onLoopParams', 'onLoopScope', 'onRepeat', 'onRepeatParams', 'onRepeatScope', 'onStart', 'onStartParams', 'onStartScope', 'onUpdate', 'onUpdateParams', 'onUpdateScope', 'onYoyo', 'onYoyoParams', 'onYoyoScope', 'paused', 'props', 'repeat', 'repeatDelay', 'targets', 'useFrames', 'yoyo']; }, function (t, e, i) {
  t.exports = {
    GetBoolean: i(61), GetEaseFunction: i(62), GetNewValue: i(73), GetProps: i(161), GetTargets: i(101), GetTweens: i(160), GetValueOp: i(100), NumberTweenBuilder: i(159), TimelineBuilder: i(158), TweenBuilder: i(72),
  };
}, function (t, e, i) {
  const n = i(60); const s = i(18); let r = {
    Builders: i(305), TweenManager: i(303), Tween: i(98), TweenData: i(97), Timeline: i(157),
  }; r = s(!1, r, n), t.exports = r;
}, function (t, e, i) {
  const n = i(0); const s = i(12); const r = i(162); const o = new n({
    initialize(t) { this.scene = t, this.systems = t.sys, this.now = Date.now(), this.timeScale = 1, this.paused = !1, this._active = [], this._pendingInsertion = [], this._pendingRemoval = [], t.sys.events.once('boot', this.boot, this), t.sys.events.on('start', this.start, this); },
    boot() { this.systems.events.once('destroy', this.destroy, this); },
    start() { const t = this.systems.events; t.on('preupdate', this.preUpdate, this), t.on('update', this.update, this), t.once('shutdown', this.shutdown, this); },
    addEvent(t) { const e = new r(t); return this._pendingInsertion.push(e), e; },
    delayedCall(t, e, i, n) {
      return this.addEvent({
        delay: t, callback: e, args: i, callbackScope: n,
      });
    },
    clearPendingEvents() { return this._pendingInsertion = [], this; },
    removeAllEvents() { return this._pendingRemoval = this._pendingRemoval.concat(this._active), this; },
    preUpdate() { const t = this._pendingRemoval.length; const e = this._pendingInsertion.length; if (t !== 0 || e !== 0) { let i; let n; for (i = 0; i < t; i++) { n = this._pendingRemoval[i]; const s = this._active.indexOf(n); s > -1 && this._active.splice(s, 1), n.destroy(); } for (i = 0; i < e; i++)n = this._pendingInsertion[i], this._active.push(n); this._pendingRemoval.length = 0, this._pendingInsertion.length = 0; } },
    update(t, e) { if (this.now = t, !this.paused) { e *= this.timeScale; for (let i = 0; i < this._active.length; i++) { const n = this._active[i]; if (!n.paused && (n.elapsed += e * n.timeScale, n.elapsed >= n.delay)) { const s = n.elapsed - n.delay; n.elapsed = n.delay, !n.hasDispatched && n.callback && (n.hasDispatched = !0, n.callback.apply(n.callbackScope, n.args)), n.repeatCount > 0 ? (n.repeatCount--, n.elapsed = s, n.hasDispatched = !1) : this._pendingRemoval.push(n); } } } },
    shutdown() { let t; for (t = 0; t < this._pendingInsertion.length; t++) this._pendingInsertion[t].destroy(); for (t = 0; t < this._active.length; t++) this._active[t].destroy(); for (t = 0; t < this._pendingRemoval.length; t++) this._pendingRemoval[t].destroy(); this._active.length = 0, this._pendingRemoval.length = 0, this._pendingInsertion.length = 0; const e = this.systems.events; e.off('preupdate', this.preUpdate, this), e.off('update', this.update, this), e.off('shutdown', this.shutdown, this); },
    destroy() { this.shutdown(), this.scene.sys.events.off('start', this.start, this), this.scene = null, this.systems = null; },
  }); s.register('Clock', o, 'time'), t.exports = o;
}, function (t, e, i) { t.exports = { Clock: i(307), TimerEvent: i(162) }; }, function (t, e, i) {
  const n = i(0); const s = i(15); const r = i(20); const o = i(2); const a = i(619); const h = i(138); const l = i(27); const u = new n({
    Extends: o, Mixins: [s.Alpha, s.BlendMode, s.ComputedSize, s.Depth, s.Flip, s.GetBounds, s.Origin, s.Pipeline, s.ScaleMode, s.Transform, s.Visible, s.ScrollFactor, a], initialize(t, e, i, n, s, a) { o.call(this, t, 'StaticTilemapLayer'), this.isTilemap = !0, this.tilemap = e, this.layerIndex = i, this.layer = e.layers[i], this.layer.tilemapLayer = this, this.tileset = n, this.culledTiles = [], this.vertexBuffer = null, this.renderer = t.sys.game.renderer, this.bufferData = null, this.vertexViewF32 = null, this.vertexViewU32 = null, this.dirty = !0, this.vertexCount = 0, this.setAlpha(this.layer.alpha), this.setPosition(s, a), this.setOrigin(), this.setSize(this.layer.tileWidth * this.layer.width, this.layer.tileHeight * this.layer.height), this.initPipeline('TextureTintPipeline'), t.sys.game.config.renderType === r.WEBGL && t.sys.game.renderer.onContextRestored(function () { this.dirty = !0, this.vertexBuffer = null; }, this); }, upload(t) { let e; let i; let n; let s; const r = this.tileset; const o = this.layer.width; const a = this.layer.height; const h = r.image.source[0].width; const u = r.image.source[0].height; const c = this.layer.data; const d = this.renderer; if (d.gl) { const f = d.pipelines.TextureTintPipeline; if (this.dirty) { const p = d.gl; let g = this.vertexBuffer; let v = this.bufferData; let y = 0; let m = 0; const x = o * a * f.vertexSize * 6; v === null && (v = new ArrayBuffer(x), this.bufferData = v, this.vertexViewF32 = new Float32Array(v), this.vertexViewU32 = new Uint32Array(v)); const w = this.vertexViewF32; const b = this.vertexViewU32; for (i = 0; i < a; ++i) for (n = 0; n < o; ++n) if ((e = c[i][n]) !== null && e.index !== -1) { const T = e.pixelX; const S = e.pixelY; const A = T + e.width; const C = S + e.height; if ((s = r.getTileTextureCoordinates(e.index)) !== null) { const M = s.x / h; const _ = s.y / u; const E = (s.x + e.width) / h; const P = (s.y + e.height) / u; const L = T; const F = S; const k = T; const R = C; const O = A; const B = C; const D = A; const I = S; const z = l.getTintAppendFloatAlpha(16777215, this.alpha * e.alpha); w[y + 0] = L, w[y + 1] = F, w[y + 2] = M, w[y + 3] = _, b[y + 4] = z, w[y + 5] = k, w[y + 6] = R, w[y + 7] = M, w[y + 8] = P, b[y + 9] = z, w[y + 10] = O, w[y + 11] = B, w[y + 12] = E, w[y + 13] = P, b[y + 14] = z, w[y + 15] = L, w[y + 16] = F, w[y + 17] = M, w[y + 18] = _, b[y + 19] = z, w[y + 20] = O, w[y + 21] = B, w[y + 22] = E, w[y + 23] = P, b[y + 24] = z, w[y + 25] = D, w[y + 26] = I, w[y + 27] = E, w[y + 28] = _, b[y + 29] = z, y += 30, m += 6; } } this.vertexCount = m, this.dirty = !1, g === null ? (g = d.createVertexBuffer(v, p.STATIC_DRAW), this.vertexBuffer = g) : (d.setVertexBuffer(g), p.bufferSubData(p.ARRAY_BUFFER, 0, v)); }f.modelIdentity(), f.modelTranslate(this.x - t.scrollX * this.scrollFactorX, this.y - t.scrollY * this.scrollFactorY, 0), f.modelScale(this.scaleX, this.scaleY, 1), f.viewLoad2D(t.matrix.matrix); } return this; }, calculateFacesAt(t, e) { return h.CalculateFacesAt(t, e, this.layer), this; }, calculateFacesWithin(t, e, i, n) { return h.CalculateFacesWithin(t, e, i, n, this.layer), this; }, createFromTiles(t, e, i, n, s) { return h.CreateFromTiles(t, e, i, n, s, this.layer); }, cull(t) { return h.CullTiles(this.layer, t, this.culledTiles); }, destroy() { this.layer.tilemapLayer === this && (this.layer.tilemapLayer = void 0), this.tilemap = void 0, this.layer = void 0, this.tileset = void 0, o.prototype.destroy.call(this); }, findByIndex(t, e, i) { return h.FindByIndex(t, e, i, this.layer); }, findTile(t, e, i, n, s, r, o) { return h.FindTile(t, e, i, n, s, r, o, this.layer); }, filterTiles(t, e, i, n, s, r, o) { return h.FilterTiles(t, e, i, n, s, r, o, this.layer); }, forEachTile(t, e, i, n, s, r, o) { return h.ForEachTile(t, e, i, n, s, r, o, this.layer), this; }, getTileAt(t, e, i) { return h.GetTileAt(t, e, i, this.layer); }, getTileAtWorldXY(t, e, i, n) { return h.GetTileAtWorldXY(t, e, i, n, this.layer); }, getTilesWithin(t, e, i, n, s) { return h.GetTilesWithin(t, e, i, n, s, this.layer); }, getTilesWithinWorldXY(t, e, i, n, s, r) { return h.GetTilesWithinWorldXY(t, e, i, n, s, r, this.layer); }, getTilesWithinShape(t, e, i) { return h.GetTilesWithinShape(t, e, i, this.layer); }, hasTileAt(t, e) { return h.HasTileAt(t, e, this.layer); }, hasTileAtWorldXY(t, e, i) { return h.HasTileAtWorldXY(t, e, i, this.layer); }, renderDebug(t, e) { return h.RenderDebug(t, e, this.layer), this; }, setCollision(t, e, i) { return h.SetCollision(t, e, i, this.layer), this; }, setCollisionBetween(t, e, i, n) { return h.SetCollisionBetween(t, e, i, n, this.layer), this; }, setCollisionByProperty(t, e, i) { return h.SetCollisionByProperty(t, e, i, this.layer), this; }, setCollisionByExclusion(t, e, i) { return h.SetCollisionByExclusion(t, e, i, this.layer), this; }, setTileIndexCallback(t, e, i) { return h.SetTileIndexCallback(t, e, i, this.layer), this; }, setCollisionFromCollisionGroup(t, e) { return h.SetCollisionFromCollisionGroup(t, e, this.layer), this; }, setTileLocationCallback(t, e, i, n, s, r) { return h.SetTileLocationCallback(t, e, i, n, s, r, this.layer), this; }, tileToWorldX(t, e) { return h.TileToWorldX(t, e, this.layer); }, tileToWorldY(t, e) { return h.TileToWorldY(t, e, this.layer); }, tileToWorldXY(t, e, i, n) { return h.TileToWorldXY(t, e, i, n, this.layer); }, worldToTileX(t, e, i) { return h.WorldToTileX(t, e, i, this.layer); }, worldToTileY(t, e, i) { return h.WorldToTileY(t, e, i, this.layer); }, worldToTileXY(t, e, i, n, s) { return h.WorldToTileXY(t, e, i, n, s, this.layer); },
  }); t.exports = u;
}, function (t, e, i) {
  const n = i(0); const s = i(15); const r = i(622); const o = i(2); const a = i(138); const h = new n({
    Extends: o, Mixins: [s.Alpha, s.BlendMode, s.ComputedSize, s.Depth, s.Flip, s.GetBounds, s.Origin, s.Pipeline, s.ScaleMode, s.Transform, s.Visible, s.ScrollFactor, r], initialize(t, e, i, n, s, r) { o.call(this, t, 'DynamicTilemapLayer'), this.isTilemap = !0, this.tilemap = e, this.layerIndex = i, this.layer = e.layers[i], this.layer.tilemapLayer = this, this.tileset = n, this.culledTiles = [], this.setAlpha(this.layer.alpha), this.setPosition(s, r), this.setOrigin(), this.setSize(this.layer.tileWidth * this.layer.width, this.layer.tileHeight * this.layer.height), this.initPipeline('TextureTintPipeline'); }, calculateFacesAt(t, e) { return a.CalculateFacesAt(t, e, this.layer), this; }, calculateFacesWithin(t, e, i, n) { return a.CalculateFacesWithin(t, e, i, n, this.layer), this; }, createFromTiles(t, e, i, n, s) { return a.CreateFromTiles(t, e, i, n, s, this.layer); }, cull(t) { return a.CullTiles(this.layer, t, this.culledTiles); }, copy(t, e, i, n, s, r, o) { return a.Copy(t, e, i, n, s, r, o, this.layer), this; }, destroy() { this.layer.tilemapLayer === this && (this.layer.tilemapLayer = void 0), this.tilemap = void 0, this.layer = void 0, this.tileset = void 0, this.culledTiles.length = 0, o.prototype.destroy.call(this); }, fill(t, e, i, n, s, r) { return a.Fill(t, e, i, n, s, r, this.layer), this; }, filterTiles(t, e, i, n, s, r, o) { return a.FilterTiles(t, e, i, n, s, r, o, this.layer); }, findByIndex(t, e, i) { return a.FindByIndex(t, e, i, this.layer); }, findTile(t, e, i, n, s, r, o) { return a.FindTile(t, e, i, n, s, r, o, this.layer); }, forEachTile(t, e, i, n, s, r, o) { return a.ForEachTile(t, e, i, n, s, r, o, this.layer), this; }, getTileAt(t, e, i) { return a.GetTileAt(t, e, i, this.layer); }, getTileAtWorldXY(t, e, i, n) { return a.GetTileAtWorldXY(t, e, i, n, this.layer); }, getTilesWithin(t, e, i, n, s) { return a.GetTilesWithin(t, e, i, n, s, this.layer); }, getTilesWithinShape(t, e, i) { return a.GetTilesWithinShape(t, e, i, this.layer); }, getTilesWithinWorldXY(t, e, i, n, s, r) { return a.GetTilesWithinWorldXY(t, e, i, n, s, r, this.layer); }, hasTileAt(t, e) { return a.HasTileAt(t, e, this.layer); }, hasTileAtWorldXY(t, e, i) { return a.HasTileAtWorldXY(t, e, i, this.layer); }, putTileAt(t, e, i, n) { return a.PutTileAt(t, e, i, n, this.layer); }, putTileAtWorldXY(t, e, i, n, s) { return a.PutTileAtWorldXY(t, e, i, n, s, this.layer); }, putTilesAt(t, e, i, n) { return a.PutTilesAt(t, e, i, n, this.layer), this; }, randomize(t, e, i, n, s) { return a.Randomize(t, e, i, n, s, this.layer), this; }, removeTileAt(t, e, i, n) { return a.RemoveTileAt(t, e, i, n, this.layer); }, removeTileAtWorldXY(t, e, i, n, s) { return a.RemoveTileAtWorldXY(t, e, i, n, s, this.layer); }, renderDebug(t, e) { return a.RenderDebug(t, e, this.layer), this; }, replaceByIndex(t, e, i, n, s, r) { return a.ReplaceByIndex(t, e, i, n, s, r, this.layer), this; }, setCollision(t, e, i) { return a.SetCollision(t, e, i, this.layer), this; }, setCollisionBetween(t, e, i, n) { return a.SetCollisionBetween(t, e, i, n, this.layer), this; }, setCollisionByProperty(t, e, i) { return a.SetCollisionByProperty(t, e, i, this.layer), this; }, setCollisionByExclusion(t, e, i) { return a.SetCollisionByExclusion(t, e, i, this.layer), this; }, setCollisionFromCollisionGroup(t, e) { return a.SetCollisionFromCollisionGroup(t, e, this.layer), this; }, setTileIndexCallback(t, e, i) { return a.SetTileIndexCallback(t, e, i, this.layer), this; }, setTileLocationCallback(t, e, i, n, s, r) { return a.SetTileLocationCallback(t, e, i, n, s, r, this.layer), this; }, shuffle(t, e, i, n) { return a.Shuffle(t, e, i, n, this.layer), this; }, swapByIndex(t, e, i, n, s, r) { return a.SwapByIndex(t, e, i, n, s, r, this.layer), this; }, tileToWorldX(t, e) { return a.TileToWorldX(t, e, this.layer); }, tileToWorldY(t, e) { return a.TileToWorldY(t, e, this.layer); }, tileToWorldXY(t, e, i, n) { return a.TileToWorldXY(t, e, i, n, this.layer); }, weightedRandomize(t, e, i, n, s) { return a.WeightedRandomize(t, e, i, n, s, this.layer), this; }, worldToTileX(t, e, i) { return a.WorldToTileX(t, e, i, this.layer); }, worldToTileY(t, e, i) { return a.WorldToTileY(t, e, i, this.layer); }, worldToTileXY(t, e, i, n, s) { return a.WorldToTileXY(t, e, i, n, s, this.layer); },
  }); t.exports = h;
}, function (t, e, i) {
  const n = i(0); const s = i(38); const r = i(310); const o = i(18); const a = i(26); const h = i(103); const l = i(346); const u = i(309); const c = i(65); const d = i(138); const f = i(134); const p = new n({
    initialize(t, e) { this.scene = t, this.tileWidth = e.tileWidth, this.tileHeight = e.tileHeight, this.width = e.width, this.height = e.height, this.orientation = e.orientation, this.format = e.format, this.version = e.version, this.properties = e.properties, this.widthInPixels = e.widthInPixels, this.heightInPixels = e.heightInPixels, this.imageCollections = e.imageCollections, this.images = e.images, this.layers = e.layers, this.tilesets = e.tilesets, this.objects = e.objects, this.currentLayerIndex = 0; },
    addTilesetImage(t, e, i, n, s, r, o) { if (void 0 === t) return null; if (void 0 !== e && e !== null || (e = t), !this.scene.sys.textures.exists(e)) return console.warn(`Invalid image key given for tileset: "${e}"`), null; const h = this.scene.sys.textures.get(e); const l = this.getTilesetIndex(t); if (l === null && this.format === a.TILED_JSON) return console.warn(`No data found in the JSON tilemap from Tiled matching the tileset name: "${t}"`), null; if (this.tilesets[l]) return this.tilesets[l].setTileSize(i, n), this.tilesets[l].setSpacing(s, r), this.tilesets[l].setImage(h), this.tilesets[l]; void 0 === i && (i = this.tileWidth), void 0 === n && (n = this.tileHeight), void 0 === s && (s = 0), void 0 === r && (r = 0), void 0 === o && (o = 0); const u = new f(t, o, i, n, s, r); return u.setImage(h), this.tilesets.push(u), u; },
    convertLayerToStatic(t) { if ((t = this.getLayer(t)) === null) return null; const e = t.tilemapLayer; if (!(e && e instanceof r)) return null; const i = new u(e.scene, e.tilemap, e.layerIndex, e.tileset, e.x, e.y); return this.scene.sys.displayList.add(i), e.destroy(), i; },
    copy(t, e, i, n, s, r, o, a) { return a = this.getLayer(a), this._isStaticCall(a, 'copy') ? this : (a !== null && d.Copy(t, e, i, n, s, r, o, a), this); },
    createBlankDynamicLayer(t, e, i, n, s, o, a, l) {
      if (void 0 === a && (a = e.tileWidth), void 0 === l && (l = e.tileHeight), void 0 === s && (s = this.width), void 0 === o && (o = this.height), void 0 === i && (i = 0), void 0 === n && (n = 0), this.getLayerIndex(t) !== null) return console.warn(`Cannot create blank layer: layer with matching name already exists ${t}`), null; for (var u, d = new h({
          name: t, tileWidth: a, tileHeight: l, width: s, height: o,
        }), f = 0; f < o; f++) { u = []; for (let p = 0; p < s; p++)u.push(new c(d, -1, p, f, a, l, this.tileWidth, this.tileHeight)); d.data.push(u); } this.layers.push(d), this.currentLayerIndex = this.layers.length - 1; const g = new r(this.scene, this, this.currentLayerIndex, e, i, n); return this.scene.sys.displayList.add(g), g;
    },
    createDynamicLayer(t, e, i, n) { const s = this.getLayerIndex(t); if (s === null) return console.warn(`Cannot create tilemap layer, invalid layer ID given: ${t}`), null; const o = this.layers[s]; if (o.tilemapLayer) return console.warn(`Cannot create dynamic tilemap layer since a static or dynamic tilemap layer exists for layer ID:${t}`), null; this.currentLayerIndex = s, o.tileWidth === e.tileWidth && o.tileHeight === e.tileHeight || this.setLayerTileSize(e.tileWidth, e.tileHeight, s), void 0 === i && this.layers[s].x && (i = this.layers[s].x), void 0 === n && this.layers[s].y && (n = this.layers[s].y); const a = new r(this.scene, this, s, e, i, n); return this.scene.sys.displayList.add(a), a; },
    createFromObjects(t, e, i, n) { void 0 === i && (i = {}), void 0 === n && (n = this.scene); const r = this.getObjectLayer(t); if (r) { for (var a = r.objects, h = [], u = 0; u < a.length; u++) { let c = !1; const d = a[u]; if ((void 0 !== d.gid && typeof e === 'number' && d.gid === e || void 0 !== d.id && typeof e === 'number' && d.id === e || void 0 !== d.name && typeof e === 'string' && d.name === e) && (c = !0), c) { const f = o({}, i, d.properties); f.x = d.x, f.y = d.y; const p = this.scene.make.sprite(f); p.name = d.name, d.width && (p.displayWidth = d.width), d.height && (p.displayHeight = d.height); const g = { x: p.originX * p.displayWidth, y: (p.originY - 1) * p.displayHeight }; if (d.rotation) { const v = s(d.rotation); l(g, v), p.rotation = v; }p.x += g.x, p.y += g.y, void 0 === d.flippedHorizontal && void 0 === d.flippedVertical || p.setFlip(d.flippedHorizontal, d.flippedVertical), d.visible || (p.visible = !1), h.push(p); } } return h; }console.warn(`Cannot create from object. Invalid objectgroup name given: ${t}`); },
    createFromTiles(t, e, i, n, s, r) { return (r = this.getLayer(r)) === null ? null : d.CreateFromTiles(t, e, i, n, s, r); },
    createStaticLayer(t, e, i, n) { const s = this.getLayerIndex(t); if (s === null) return console.warn(`Cannot create tilemap layer, invalid layer ID given: ${t}`), null; const r = this.layers[s]; if (r.tilemapLayer) return console.warn(`Cannot create static tilemap layer since a static or dynamic tilemap layer exists for layer ID:${t}`), null; this.currentLayerIndex = s, r.tileWidth === e.tileWidth && r.tileHeight === e.tileHeight || this.setLayerTileSize(e.tileWidth, e.tileHeight, s), void 0 === i && this.layers[s].x && (i = this.layers[s].x), void 0 === n && this.layers[s].y && (n = this.layers[s].y); const o = new u(this.scene, this, s, e, i, n); return this.scene.sys.displayList.add(o), o; },
    destroy() { this.removeAllLayers(), this.tilesets.length = 0, this.objects.length = 0, this.scene = void 0; },
    fill(t, e, i, n, s, r, o) { return o = this.getLayer(o), this._isStaticCall(o, 'fill') ? this : (o !== null && d.Fill(t, e, i, n, s, r, o), this); },
    filterObjects(t, e, i) { if (typeof t === 'string') { const n = t; if (!(t = this.getObjectLayer(t))) return console.warn(`No object layer found with the name: ${n}`), null; } return t.objects.filter(e, i); },
    filterTiles(t, e, i, n, s, r, o, a) { return (a = this.getLayer(a)) === null ? null : d.FilterTiles(t, e, i, n, s, r, o, a); },
    findByIndex(t, e, i, n) { return (n = this.getLayer(n)) === null ? null : d.FindByIndex(t, e, i, n); },
    findObject(t, e, i) { if (typeof t === 'string') { const n = t; if (!(t = this.getObjectLayer(t))) return console.warn(`No object layer found with the name: ${n}`), null; } return t.objects.find(e, i) || null; },
    findTile(t, e, i, n, s, r, o, a) { return (a = this.getLayer(a)) === null ? null : d.FindTile(t, e, i, n, s, r, o, a); },
    forEachTile(t, e, i, n, s, r, o, a) { return (a = this.getLayer(a)) !== null && d.ForEachTile(t, e, i, n, s, r, o, a), this; },
    getImageIndex(t) { return this.getIndex(this.images, t); },
    getIndex(t, e) { for (let i = 0; i < t.length; i++) if (t[i].name === e) return i; return null; },
    getLayer(t) { const e = this.getLayerIndex(t); return e !== null ? this.layers[e] : null; },
    getObjectLayer(t) { const e = this.getIndex(this.objects, t); return e !== null ? this.objects[e] : null; },
    getLayerIndex(t) { return void 0 === t ? this.currentLayerIndex : typeof t === 'string' ? this.getLayerIndexByName(t) : typeof t === 'number' && t < this.layers.length ? t : t instanceof u || t instanceof r ? t.layerIndex : null; },
    getLayerIndexByName(t) { return this.getIndex(this.layers, t); },
    getTileAt(t, e, i, n) { return (n = this.getLayer(n)) === null ? null : d.GetTileAt(t, e, i, n); },
    getTileAtWorldXY(t, e, i, n, s) { return (s = this.getLayer(s)) === null ? null : d.GetTileAtWorldXY(t, e, i, n, s); },
    getTilesWithin(t, e, i, n, s, r) { return (r = this.getLayer(r)) === null ? null : d.GetTilesWithin(t, e, i, n, s, r); },
    getTilesWithinShape(t, e, i, n) { return (n = this.getLayer(n)) === null ? null : d.GetTilesWithinShape(t, e, i, n); },
    getTilesWithinWorldXY(t, e, i, n, s, r, o) { return (o = this.getLayer(o)) === null ? null : d.GetTilesWithinWorldXY(t, e, i, n, s, r, o); },
    getTilesetIndex(t) { return this.getIndex(this.tilesets, t); },
    hasTileAt(t, e, i) { return (i = this.getLayer(i)) === null ? null : d.HasTileAt(t, e, i); },
    hasTileAtWorldXY(t, e, i, n) { return (n = this.getLayer(n)) === null ? null : d.HasTileAtWorldXY(t, e, i, n); },
    layer: { get() { return this.layers[this.currentLayerIndex]; }, set(t) { this.setLayer(t); } },
    putTileAt(t, e, i, n, s) { return s = this.getLayer(s), this._isStaticCall(s, 'putTileAt') ? null : s === null ? null : d.PutTileAt(t, e, i, n, s); },
    putTileAtWorldXY(t, e, i, n, s, r) { return r = this.getLayer(r), this._isStaticCall(r, 'putTileAtWorldXY') ? null : r === null ? null : d.PutTileAtWorldXY(t, e, i, n, s, r); },
    putTilesAt(t, e, i, n, s) { return s = this.getLayer(s), this._isStaticCall(s, 'putTilesAt') ? this : (s !== null && d.PutTilesAt(t, e, i, n, s), this); },
    randomize(t, e, i, n, s, r) { return r = this.getLayer(r), this._isStaticCall(r, 'randomize') ? this : (r !== null && d.Randomize(t, e, i, n, s, r), this); },
    calculateFacesAt(t, e, i) { return (i = this.getLayer(i)) === null ? this : (d.CalculateFacesAt(t, e, i), this); },
    calculateFacesWithin(t, e, i, n, s) { return (s = this.getLayer(s)) === null ? this : (d.CalculateFacesWithin(t, e, i, n, s), this); },
    removeAllLayers() { for (let t = 0; t < this.layers.length; t++) this.layers[t].tilemapLayer && this.layers[t].tilemapLayer.destroy(); return this.layers.length = 0, this.currentLayerIndex = 0, this; },
    removeTileAt(t, e, i, n, s) { return s = this.getLayer(s), this._isStaticCall(s, 'removeTileAt') ? null : s === null ? null : d.RemoveTileAt(t, e, i, n, s); },
    removeTileAtWorldXY(t, e, i, n, s, r) { return r = this.getLayer(r), this._isStaticCall(r, 'removeTileAtWorldXY') ? null : r === null ? null : d.RemoveTileAtWorldXY(t, e, i, n, s, r); },
    renderDebug(t, e, i) { return (i = this.getLayer(i)) === null ? this : (d.RenderDebug(t, e, i), this); },
    replaceByIndex(t, e, i, n, s, r, o) { return o = this.getLayer(o), this._isStaticCall(o, 'replaceByIndex') ? this : (o !== null && d.ReplaceByIndex(t, e, i, n, s, r, o), this); },
    setCollision(t, e, i, n) { return (n = this.getLayer(n)) === null ? this : (d.SetCollision(t, e, i, n), this); },
    setCollisionBetween(t, e, i, n, s) { return (s = this.getLayer(s)) === null ? this : (d.SetCollisionBetween(t, e, i, n, s), this); },
    setCollisionByProperty(t, e, i, n) { return (n = this.getLayer(n)) === null ? this : (d.SetCollisionByProperty(t, e, i, n), this); },
    setCollisionByExclusion(t, e, i, n) { return (n = this.getLayer(n)) === null ? this : (d.SetCollisionByExclusion(t, e, i, n), this); },
    setCollisionFromCollisionGroup(t, e, i) { return (i = this.getLayer(i)) === null ? this : (d.SetCollisionFromCollisionGroup(t, e, i), this); },
    setTileIndexCallback(t, e, i, n) { return (n = this.getLayer(n)) === null ? this : (d.SetTileIndexCallback(t, e, i, n), this); },
    setTileLocationCallback(t, e, i, n, s, r, o) { return (o = this.getLayer(o)) === null ? this : (d.SetTileLocationCallback(t, e, i, n, s, r, o), this); },
    setLayer(t) { const e = this.getLayerIndex(t); return e !== null && (this.currentLayerIndex = e), this; },
    setBaseTileSize(t, e) { this.tileWidth = t, this.tileHeight = e, this.widthInPixels = this.width * t, this.heightInPixels = this.height * e; for (let i = 0; i < this.layers.length; i++) { this.layers[i].baseWidth = t, this.layers[i].baseHeight = e; for (let n = this.layers[i].data, s = this.layers[i].width, r = this.layers[i].height, o = 0; o < r; ++o) for (let a = 0; a < s; ++a) { const h = n[o][a]; h !== null && h.setSize(void 0, void 0, t, e); } } return this; },
    setLayerTileSize(t, e, i) { if ((i = this.getLayer(i)) === null) return this; i.tileWidth = t, i.tileHeight = e; for (let n = i.data, s = i.width, r = i.height, o = 0; o < r; ++o) for (let a = 0; a < s; ++a) { const h = n[o][a]; h !== null && h.setSize(t, e); } return this; },
    shuffle(t, e, i, n, s) { return s = this.getLayer(s), this._isStaticCall(s, 'shuffle') ? this : (s !== null && d.Shuffle(t, e, i, n, s), this); },
    swapByIndex(t, e, i, n, s, r, o) { return o = this.getLayer(o), this._isStaticCall(o, 'swapByIndex') ? this : (o !== null && d.SwapByIndex(t, e, i, n, s, r, o), this); },
    tileToWorldX(t, e, i) { return (i = this.getLayer(i)) === null ? null : d.TileToWorldX(t, e, i); },
    tileToWorldY(t, e, i) { return (i = this.getLayer(i)) === null ? null : d.TileToWorldY(t, e, i); },
    tileToWorldXY(t, e, i, n, s) { return (s = this.getLayer(s)) === null ? null : d.TileToWorldXY(t, e, i, n, s); },
    weightedRandomize(t, e, i, n, s, r) { return r = this.getLayer(r), this._isStaticCall(r, 'weightedRandomize') ? this : (r !== null && d.WeightedRandomize(t, e, i, n, s, r), this); },
    worldToTileX(t, e, i, n) { return (n = this.getLayer(n)) === null ? null : d.WorldToTileX(t, e, i, n); },
    worldToTileY(t, e, i, n) { return (n = this.getLayer(n)) === null ? null : d.WorldToTileY(t, e, i, n); },
    worldToTileXY(t, e, i, n, s, r) { return (r = this.getLayer(r)) === null ? null : d.WorldToTileXY(t, e, i, n, s, r); },
    _isStaticCall(t, e) { return t.tilemapLayer instanceof u && (console.warn(`${e}: You cannot change the tiles in a static tilemap layer`), !0); },
  }); t.exports = p;
}, function (t, e, i) {
  const n = i(26); const s = i(102); const r = i(624); const o = i(623); t.exports = function (t, e, i) {
    if (e.layer.length === 0) return console.warn(`No layers found in the Weltmeister map: ${t}`), null; for (var a = 0, h = 0, l = 0; l < e.layer.length; l++)e.layer[l].width > a && (a = e.layer[l].width), e.layer[l].height > h && (h = e.layer[l].height); const u = new s({
      width: a, height: h, name: t, tileWidth: e.layer[0].tilesize, tileHeight: e.layer[0].tilesize, format: n.WELTMEISTER,
    }); return u.layers = r(e, i), u.tilesets = o(e), u;
  };
}, function (t, e, i) { const n = i(0); const s = i(1); const r = new n({ initialize(t) { void 0 === t && (t = {}), this.name = s(t, 'name', 'object layer'), this.opacity = s(t, 'opacity', 1), this.properties = s(t, 'properties', {}), this.propertyTypes = s(t, 'propertytypes', {}), this.type = s(t, 'type', 'objectgroup'), this.visible = s(t, 'visible', !0), this.objects = s(t, 'objects', []); } }); t.exports = r; }, function (t, e, i) { const n = i(628); const s = i(316); const r = function (t) { return { x: t.x, y: t.y }; }; const o = ['id', 'name', 'type', 'rotation', 'properties', 'visible', 'x', 'y', 'width', 'height']; t.exports = function (t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = 0); const a = n(t, o); if (a.x += e, a.y += i, t.gid) { const h = s(t.gid); a.gid = h.gid, a.flippedHorizontal = h.flippedHorizontal, a.flippedVertical = h.flippedVertical, a.flippedAntiDiagonal = h.flippedAntiDiagonal; } else t.polyline ? a.polyline = t.polyline.map(r) : t.polygon ? a.polygon = t.polygon.map(r) : t.ellipse ? (a.ellipse = t.ellipse, a.width = t.width, a.height = t.height) : t.text ? (a.width = t.width, a.height = t.height, a.text = t.text) : (a.rectangle = !0, a.width = t.width, a.height = t.height); return a; }; }, function (t, e, i) { const n = new (i(0))({ initialize(t, e, i, n, s, r, o) { (void 0 === i || i <= 0) && (i = 32), (void 0 === n || n <= 0) && (n = 32), void 0 === s && (s = 0), void 0 === r && (r = 0), this.name = t, this.firstgid = 0 | e, this.imageWidth = 0 | i, this.imageHeight = 0 | n, this.imageMargin = 0 | s, this.imageSpacing = 0 | r, this.properties = o || {}, this.images = [], this.total = 0; }, containsImageIndex(t) { return t >= this.firstgid && t < this.firstgid + this.total; }, addImage(t, e) { return this.images.push({ gid: t, image: e }), this.total++, this; } }); t.exports = n; }, function (t, e) {
  t.exports = function (t) {
    const e = Boolean(2147483648 & t); const i = Boolean(1073741824 & t); const n = Boolean(536870912 & t); t &= 536870911; let s = 0; let r = !1; return e && i && n ? (s = Math.PI / 2, r = !0) : e && i && !n ? (s = Math.PI, r = !1) : e && !i && n ? (s = Math.PI / 2, r = !1) : !e || i || n ? !e && i && n ? (s = 3 * Math.PI / 2, r = !1) : e || !i || n ? e || i || !n ? e || i || n || (s = 0, r = !1) : (s = 3 * Math.PI / 2, r = !0) : (s = Math.PI, r = !0) : (s = 0, r = !0), {
      gid: t, flippedHorizontal: e, flippedVertical: i, flippedAntiDiagonal: n, rotation: s, flipped: r,
    };
  };
}, function (t, e, i) {
  const n = i(26); const s = i(102); const r = i(632); const o = i(630); const a = i(629); const h = i(627); const l = i(626); const u = i(625); t.exports = function (t, e, i) {
    if (e.orientation !== 'orthogonal') return console.warn('Only orthogonal map types are supported in this version of Phaser'), null; const c = new s({
      width: e.width, height: e.height, name: t, tileWidth: e.tilewidth, tileHeight: e.tileheight, orientation: e.orientation, format: n.TILED_JSON, version: e.version, properties: e.properties,
    }); c.layers = r(e, i), c.images = o(e); const d = a(e); return c.tilesets = d.tilesets, c.imageCollections = d.imageCollections, c.objects = h(e), c.tiles = l(c), u(c), c;
  };
}, function (t, e, i) { const n = i(26); const s = i(215); t.exports = function (t, e, i, r, o) { const a = e.trim().split('\n').map((t) => t.split(',')); const h = s(t, a, i, r, o); return h.format = n.CSV, h; }; }, function (t, e, i) { const n = i(26); const s = i(215); const r = i(318); const o = i(317); const a = i(312); t.exports = function (t, e, i, h, l, u) { let c; switch (e) { case n.ARRAY_2D: c = s(t, i, h, l, u); break; case n.CSV: c = r(t, i, h, l, u); break; case n.TILED_JSON: c = o(t, i, u); break; case n.WELTMEISTER: c = a(t, i, u); break; default: console.warn(`Unrecognized tilemap data format: ${e}`), c = null; } return c; }; }, function (t, e, i) { const n = i(65); const s = i(104); const r = i(218); t.exports = function (t, e, i, o, a) { if (void 0 === i && (i = !1), void 0 === o && (o = !0), !s(t, e, a)) return null; const h = a.data[e][t]; return h === null ? null : (a.data[e][t] = i ? null : new n(a, -1, t, e, h.width, h.height), o && h && h.collides && r(t, e, a), h); }; }, function (t, e, i) { const n = i(104); t.exports = function (t, e, i) { if (n(t, e, i)) { const s = i.data[e][t]; return s !== null && s.index > -1; } return !1; }; }, function (t, e, i) { const n = i(21); t.exports = function (t, e, i, s, r, o, a) { for (let h = n(i, s, r, o, null, a), l = 0; l < h.length; l++)h[l] && h[l].index === t && (h[l].index = e); }; }, function (t, e) { t.exports = { LINEAR: 0, NEAREST: 1 }; }, function (t, e, i) {
  const n = i(18); const s = i(323); let r = {
    FilterMode: s, Frame: i(125), Parsers: i(174), Texture: i(114), TextureManager: i(176), TextureSource: i(175),
  }; r = n(!1, r, s), t.exports = r;
}, function (t, e, i) {
  t.exports = {
    List: i(92), Map: i(122), ProcessQueue: i(222), RTree: i(221), Set: i(70),
  };
}, function (t, e, i) {
  t.exports = {
    SoundManagerCreator: i(183), BaseSound: i(76), BaseSoundManager: i(77), WebAudioSound: i(177), WebAudioSoundManager: i(178), HTML5AudioSound: i(181), HTML5AudioSoundManager: i(182), NoAudioSound: i(179), NoAudioSoundManager: i(180),
  };
}, function (t, e, i) {
  const n = i(23); const s = i(0); const r = i(54); const o = i(1); const a = i(12); const h = new s({
    initialize(t) { this.scene = t, this.systems = t.sys, this.settings = t.sys.settings, this.key = t.sys.settings.key, this.manager = t.sys.game.scene, this.transitionProgress = 0, this._elapsed = 0, this._target = null, this._duration = 0, this._onUpdate, this._onUpdateScope, this._willSleep = !1, this._willRemove = !1, t.sys.events.once('boot', this.boot, this), t.sys.events.on('start', this.pluginStart, this); }, boot() { this.systems.events.once('destroy', this.destroy, this); }, pluginStart() { this._target = null, this.systems.events.once('shutdown', this.shutdown, this); }, start(t, e) { return void 0 === t && (t = this.key), this.settings.status !== r.RUNNING ? (this.manager.queueOp('stop', this.key), this.manager.queueOp('start', t, e)) : (this.manager.stop(this.key), this.manager.start(t, e)), this; }, restart(t) { const e = this.key; return this.settings.status !== r.RUNNING ? (this.manager.queueOp('stop', e), this.manager.queueOp('start', e, t)) : (this.manager.stop(e), this.manager.start(e, t)), this; }, transition(t) { void 0 === t && (t = {}); const e = o(t, 'target', !1); const i = this.manager.getScene(e); if (!e || !this.checkValidTransition(i)) return !1; const n = o(t, 'duration', 1e3); this._elapsed = 0, this._target = i, this._duration = n, this._willSleep = o(t, 'sleep', !1), this._willRemove = o(t, 'remove', !1); const s = o(t, 'onUpdate', null); s && (this._onUpdate = s, this._onUpdateScope = o(t, 'onUpdateScope', this.scene)); const r = o(t, 'allowInput', !1); this.settings.transitionAllowInput = r; const a = i.sys.settings; return a.isTransition = !0, a.transitionFrom = this.scene, a.transitionDuration = n, a.transitionAllowInput = r, o(t, 'moveAbove', !1) ? this.manager.moveAbove(this.key, e) : o(t, 'moveBelow', !1) && this.manager.moveBelow(this.key, e), i.sys.isSleeping() ? i.sys.wake() : this.manager.start(e, o(t, 'data')), this.systems.events.emit('transitionout', i, n), this.systems.events.on('update', this.step, this), !0; }, checkValidTransition(t) { return !(!t || t.sys.isActive() || t.sys.isTransitioning() || t === this.scene || this.systems.isTransitioning()); }, step(t, e) { this._elapsed += e, this.transitionProgress = n(this._elapsed / this._duration, 0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.transitionProgress), this._elapsed >= this._duration && this.transitionComplete(); }, transitionComplete() { const t = this._target.sys; const e = this._target.sys.settings; this.systems.events.off('update', this.step, this), t.events.emit('transitioncomplete', this.scene), e.isTransition = !1, e.transitionFrom = null, this._duration = 0, this._target = null, this._onUpdate = null, this._onUpdateScope = null, this._willRemove ? this.manager.remove(this.key) : this._willSleep ? this.systems.sleep() : this.manager.stop(this.key); }, add(t, e, i) { return this.manager.add(t, e, i), this; }, launch(t, e) { return t && t !== this.key && (this.settings.status !== r.RUNNING ? this.manager.queueOp('start', t, e) : this.manager.start(t, e)), this; }, pause(t) { return void 0 === t && (t = this.key), this.manager.pause(t), this; }, resume(t) { return void 0 === t && (t = this.key), this.manager.resume(t), this; }, sleep(t) { return void 0 === t && (t = this.key), this.manager.sleep(t), this; }, wake(t) { return void 0 === t && (t = this.key), this.manager.wake(t), this; }, switch(t) { return t !== this.key && (this.settings.status !== r.RUNNING ? this.manager.queueOp('switch', this.key, t) : this.manager.switch(this.key, t)), this; }, stop(t) { return void 0 === t && (t = this.key), this.manager.stop(t), this; }, setActive(t, e) { void 0 === e && (e = this.key); const i = this.manager.getScene(e); return i && i.sys.setActive(t), this; }, setVisible(t, e) { void 0 === e && (e = this.key); const i = this.manager.getScene(e); return i && i.sys.setVisible(t), this; }, isSleeping(t) { return void 0 === t && (t = this.key), this.manager.isSleeping(t); }, isActive(t) { return void 0 === t && (t = this.key), this.manager.isActive(t); }, isVisible(t) { return void 0 === t && (t = this.key), this.manager.isVisible(t); }, swapPosition(t, e) { return void 0 === e && (e = this.key), t !== e && this.manager.swapPosition(t, e), this; }, moveAbove(t, e) { return void 0 === e && (e = this.key), t !== e && this.manager.moveAbove(t, e), this; }, moveBelow(t, e) { return void 0 === e && (e = this.key), t !== e && this.manager.moveBelow(t, e), this; }, remove(t) { return void 0 === t && (t = this.key), this.manager.remove(t), this; }, moveUp(t) { return void 0 === t && (t = this.key), this.manager.moveUp(t), this; }, moveDown(t) { return void 0 === t && (t = this.key), this.manager.moveDown(t), this; }, bringToTop(t) { return void 0 === t && (t = this.key), this.manager.bringToTop(t), this; }, sendToBack(t) { return void 0 === t && (t = this.key), this.manager.sendToBack(t), this; }, get(t) { return this.manager.getScene(t); }, getIndex(t) { return void 0 === t && (t = this.key), this.manager.getIndex(t); }, shutdown() { const t = this.systems.events; t.off('shutdown', this.shutdown, this), t.off('postupdate', this.step, this), t.off('transitionout'); }, destroy() { this.shutdown(), this.scene.sys.events.off('start', this.start, this), this.scene = null, this.systems = null, this.settings = null, this.manager = null; },
  }); a.register('ScenePlugin', h, 'scenePlugin'), t.exports = h;
}, function (t, e, i) {
  const n = i(54); const s = i(18); let r = {
    SceneManager: i(186), ScenePlugin: i(327), Settings: i(184), Systems: i(115),
  }; r = s(!1, r, n), t.exports = r;
}, function (t, e, i) { const n = i(163); const s = new (i(0))({ Extends: n, initialize(t, e) { n.call(this, e), this.scene = t, this.systems = t.sys, t.sys.events.once('boot', this.boot, this); }, boot() {} }); t.exports = s; }, function (t, e, i) {
  t.exports = {
    BasePlugin: i(163), DefaultPlugins: i(119), PluginCache: i(12), PluginManager: i(188), ScenePlugin: i(329),
  };
}, function (t, e, i) { const n = {}; t.exports = n; const s = i(301); n._motionWakeThreshold = 0.18, n._motionSleepThreshold = 0.08, n._minBias = 0.9, n.update = function (t, e) { for (let i = e * e * e, s = 0; s < t.length; s++) { const r = t[s]; const o = r.speed * r.speed + r.angularSpeed * r.angularSpeed; if (r.force.x === 0 && r.force.y === 0) { const a = Math.min(r.motion, o); const h = Math.max(r.motion, o); r.motion = n._minBias * a + (1 - n._minBias) * h, r.sleepThreshold > 0 && r.motion < n._motionSleepThreshold * i ? (r.sleepCounter += 1, r.sleepCounter >= r.sleepThreshold && n.set(r, !0)) : r.sleepCounter > 0 && (r.sleepCounter -= 1); } else n.set(r, !1); } }, n.afterCollisions = function (t, e) { for (let i = e * e * e, s = 0; s < t.length; s++) { const r = t[s]; if (r.isActive) { const o = r.collision; const a = o.bodyA.parent; const h = o.bodyB.parent; if (!(a.isSleeping && h.isSleeping || a.isStatic || h.isStatic) && (a.isSleeping || h.isSleeping)) { const l = a.isSleeping && !a.isStatic ? a : h; const u = l === a ? h : a; !l.isStatic && u.motion > n._motionWakeThreshold * i && n.set(l, !1); } } } }, n.set = function (t, e) { const i = t.isSleeping; e ? (t.isSleeping = !0, t.sleepCounter = t.sleepThreshold, t.positionImpulse.x = 0, t.positionImpulse.y = 0, t.positionPrev.x = t.position.x, t.positionPrev.y = t.position.y, t.anglePrev = t.angle, t.speed = 0, t.angularSpeed = 0, t.motion = 0, i || s.trigger(t, 'sleepStart')) : (t.isSleeping = !1, t.sleepCounter = 0, i && s.trigger(t, 'sleepEnd')); }; }, function (t, e) {
  t.exports = {
    NONE: 0, A: 1, B: 2, BOTH: 3,
  };
}, function (t, e) {
  t.exports = {
    NEVER: 0, LITE: 1, PASSIVE: 2, ACTIVE: 4, FIXED: 8,
  };
}, function (t, e, i) {
  const n = i(32); const s = i(0); const r = i(67); const o = i(31); const a = i(7); const h = new s({
    initialize(t, e) {
      const i = e.width ? e.width : 64; const n = e.height ? e.height : 64; this.world = t, this.gameObject = e, this.debugShowBody = t.defaults.debugShowStaticBody, this.debugBodyColor = t.defaults.staticBodyDebugColor, this.enable = !0, this.isCircle = !1, this.radius = 0, this.offset = new a(), this.position = new a(e.x - e.displayOriginX, e.y - e.displayOriginY), this.width = i, this.height = n, this.halfWidth = Math.abs(this.width / 2), this.halfHeight = Math.abs(this.height / 2), this.center = new a(e.x + this.halfWidth, e.y + this.halfHeight), this.velocity = a.ZERO, this.allowGravity = !1, this.gravity = a.ZERO, this.bounce = a.ZERO, this.onWorldBounds = !1, this.onCollide = !1, this.onOverlap = !1, this.mass = 1, this.immovable = !0, this.customSeparateX = !1, this.customSeparateY = !1, this.overlapX = 0, this.overlapY = 0, this.overlapR = 0, this.embedded = !1, this.collideWorldBounds = !1, this.checkCollision = {
        none: !1, up: !0, down: !0, left: !0, right: !0,
      }, this.touching = {
        none: !0, up: !1, down: !1, left: !1, right: !1,
      }, this.wasTouching = {
        none: !0, up: !1, down: !1, left: !1, right: !1,
      }, this.blocked = {
        none: !0, up: !1, down: !1, left: !1, right: !1,
      }, this.physicsType = r.STATIC_BODY;
    },
    setGameObject(t, e) { return t && t !== this.gameObject && (this.gameObject.body = null, t.body = this, this.gameObject = t), e && this.updateFromGameObject(), this; },
    updateFromGameObject() { this.world.staticTree.remove(this); const t = this.gameObject; return t.getTopLeft(this.position), this.width = t.displayWidth, this.height = t.displayHeight, this.halfWidth = Math.abs(this.width / 2), this.halfHeight = Math.abs(this.height / 2), this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.world.staticTree.insert(this), this; },
    setOffset(t, e) { return void 0 === e && (e = t), this.world.staticTree.remove(this), this.position.x -= this.offset.x, this.position.y -= this.offset.y, this.offset.set(t, e), this.position.x += this.offset.x, this.position.y += this.offset.y, this.updateCenter(), this.world.staticTree.insert(this), this; },
    setSize(t, e, i, n) { return void 0 === i && (i = this.offset.x), void 0 === n && (n = this.offset.y), this.world.staticTree.remove(this), this.width = t, this.height = e, this.halfWidth = Math.floor(t / 2), this.halfHeight = Math.floor(e / 2), this.offset.set(i, n), this.updateCenter(), this.isCircle = !1, this.radius = 0, this.world.staticTree.insert(this), this; },
    setCircle(t, e, i) { return void 0 === e && (e = this.offset.x), void 0 === i && (i = this.offset.y), t > 0 ? (this.world.staticTree.remove(this), this.isCircle = !0, this.radius = t, this.width = 2 * t, this.height = 2 * t, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.set(e, i), this.updateCenter(), this.world.staticTree.insert(this)) : this.isCircle = !1, this; },
    updateCenter() { this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight); },
    reset(t, e) { const i = this.gameObject; void 0 === t && (t = i.x), void 0 === e && (e = i.y), this.world.staticTree.remove(this), i.getTopLeft(this.position), this.updateCenter(), this.world.staticTree.insert(this); },
    stop() { return this; },
    getBounds(t) { return t.x = this.x, t.y = this.y, t.right = this.right, t.bottom = this.bottom, t; },
    hitTest(t, e) { return this.isCircle ? n(this, t, e) : o(this, t, e); },
    deltaAbsX() { return 0; },
    deltaAbsY() { return 0; },
    deltaX() { return 0; },
    deltaY() { return 0; },
    deltaZ() { return 0; },
    destroy() { this.enable = !1, this.world.pendingDestroy.set(this); },
    drawDebug(t) { const e = this.position; this.debugShowBody && (t.lineStyle(1, this.debugBodyColor, 1), t.strokeRect(e.x, e.y, this.width, this.height)); },
    willDrawDebug() { return this.debugShowBody; },
    setMass(t) { return t <= 0 && (t = 0.1), this.mass = t, this; },
    x: { get() { return this.position.x; }, set(t) { this.world.staticTree.remove(this), this.position.x = t, this.world.staticTree.insert(this); } },
    y: { get() { return this.position.y; }, set(t) { this.world.staticTree.remove(this), this.position.y = t, this.world.staticTree.insert(this); } },
    left: { get() { return this.position.x; } },
    right: { get() { return this.position.x + this.width; } },
    top: { get() { return this.position.y; } },
    bottom: { get() { return this.position.y + this.height; } },
  }); t.exports = h;
}, function (t, e) { t.exports = function (t, e) { return !(e.right <= t.left || e.bottom <= t.top || e.position.x >= t.right || e.position.y >= t.bottom); }; }, function (t, e) { t.exports = function (t, e, i, n) { let s = 0; const r = t.deltaAbsY() + e.deltaAbsY() + n; return t.deltaY() === 0 && e.deltaY() === 0 ? (t.embedded = !0, e.embedded = !0) : t.deltaY() > e.deltaY() ? (s = t.bottom - e.y) > r && !i || !1 === t.checkCollision.down || !1 === e.checkCollision.up ? s = 0 : (t.touching.none = !1, t.touching.down = !0, e.touching.none = !1, e.touching.up = !0) : t.deltaY() < e.deltaY() && (-(s = t.y - e.bottom) > r && !i || !1 === t.checkCollision.up || !1 === e.checkCollision.down ? s = 0 : (t.touching.none = !1, t.touching.up = !0, e.touching.none = !1, e.touching.down = !0)), t.overlapY = s, e.overlapY = s, s; }; }, function (t, e) { t.exports = function (t, e, i, n) { let s = 0; const r = t.deltaAbsX() + e.deltaAbsX() + n; return t.deltaX() === 0 && e.deltaX() === 0 ? (t.embedded = !0, e.embedded = !0) : t.deltaX() > e.deltaX() ? (s = t.right - e.x) > r && !i || !1 === t.checkCollision.right || !1 === e.checkCollision.left ? s = 0 : (t.touching.none = !1, t.touching.right = !0, e.touching.none = !1, e.touching.left = !0) : t.deltaX() < e.deltaX() && (-(s = t.x - e.width - e.x) > r && !i || !1 === t.checkCollision.left || !1 === e.checkCollision.right ? s = 0 : (t.touching.none = !1, t.touching.left = !0, e.touching.none = !1, e.touching.right = !0)), t.overlapX = s, e.overlapX = s, s; }; }, function (t, e, i) {
  const n = new (i(0))({
    initialize(t, e, i, n, s, r, o) { this.world = t, this.name = '', this.active = !0, this.overlapOnly = e, this.object1 = i, this.object2 = n, this.collideCallback = s, this.processCallback = r, this.callbackContext = o; }, setName(t) { return this.name = t, this; }, update() { this.world.collideObjects(this.object1, this.object2, this.collideCallback, this.processCallback, this.callbackContext, this.overlapOnly); }, destroy() { this.world.removeCollider(this), this.active = !1, this.world = null, this.object1 = null, this.object2 = null, this.collideCallback = null, this.processCallback = null, this.callbackContext = null; },
  }); t.exports = n;
}, function (t, e, i) {
  const n = i(32); const s = i(0); const r = i(67); const o = i(148); const a = i(14); const h = i(31); const l = i(63); const u = i(7); const c = new s({
    initialize(t, e) {
      const i = e.width ? e.width : 64; const n = e.height ? e.height : 64; this.world = t, this.gameObject = e, this.transform = {
        x: e.x, y: e.y, rotation: e.angle, scaleX: e.scaleX, scaleY: e.scaleY, displayOriginX: e.displayOriginX, displayOriginY: e.displayOriginY,
      }, this.debugShowBody = t.defaults.debugShowBody, this.debugShowVelocity = t.defaults.debugShowVelocity, this.debugBodyColor = t.defaults.bodyDebugColor, this.enable = !0, this.isCircle = !1, this.radius = 0, this.offset = new u(), this.position = new u(e.x, e.y), this.prev = new u(e.x, e.y), this.allowRotation = !0, this.rotation = e.angle, this.preRotation = e.angle, this.width = i, this.height = n, this.sourceWidth = i, this.sourceHeight = n, e.frame && (this.sourceWidth = e.frame.realWidth, this.sourceHeight = e.frame.realHeight), this.halfWidth = Math.abs(i / 2), this.halfHeight = Math.abs(n / 2), this.center = new u(e.x + this.halfWidth, e.y + this.halfHeight), this.velocity = new u(), this.newVelocity = new u(), this.deltaMax = new u(), this.acceleration = new u(), this.allowDrag = !0, this.drag = new u(), this.allowGravity = !0, this.gravity = new u(), this.bounce = new u(), this.worldBounce = null, this.onWorldBounds = !1, this.onCollide = !1, this.onOverlap = !1, this.maxVelocity = new u(1e4, 1e4), this.friction = new u(1, 0), this.angularVelocity = 0, this.angularAcceleration = 0, this.angularDrag = 0, this.maxAngular = 1e3, this.mass = 1, this.angle = 0, this.speed = 0, this.facing = r.FACING_NONE, this.immovable = !1, this.moves = !0, this.customSeparateX = !1, this.customSeparateY = !1, this.overlapX = 0, this.overlapY = 0, this.overlapR = 0, this.embedded = !1, this.collideWorldBounds = !1, this.checkCollision = {
        none: !1, up: !0, down: !0, left: !0, right: !0,
      }, this.touching = {
        none: !0, up: !1, down: !1, left: !1, right: !1,
      }, this.wasTouching = {
        none: !0, up: !1, down: !1, left: !1, right: !1,
      }, this.blocked = {
        none: !0, up: !1, down: !1, left: !1, right: !1,
      }, this.dirty = !1, this.syncBounds = !1, this.isMoving = !1, this.stopVelocityOnCollide = !0, this.physicsType = r.DYNAMIC_BODY, this._reset = !0, this._sx = e.scaleX, this._sy = e.scaleY, this._dx = 0, this._dy = 0, this._bounds = new a(), this._tempMatrix = new l();
    },
    updateBounds() { const t = this.gameObject; const e = this.transform; if (t.parentContainer) { const i = t.getWorldTransformMatrix(this._tempMatrix); e.x = i.tx, e.y = i.ty, e.rotation = o(i.rotation), e.scaleX = i.scaleX, e.scaleY = i.scaleY; } else e.x = t.x, e.y = t.y, e.rotation = t.angle, e.scaleX = t.scaleX, e.scaleY = t.scaleY; if (this.syncBounds) { const n = t.getBounds(this._bounds); n.width === this.width && n.height === this.height || (this.width = n.width, this.height = n.height, this._reset = !0); } else { const s = Math.abs(e.scaleX); const r = Math.abs(e.scaleY); s === this._sx && r === this._sy || (this.width = this.sourceWidth * s, this.height = this.sourceHeight * r, this._sx = s, this._sy = r, this._reset = !0); } this._reset && (this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.updateCenter()); },
    updateCenter() { this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight); },
    update(t) { this.dirty = !0, this.wasTouching.none = this.touching.none, this.wasTouching.up = this.touching.up, this.wasTouching.down = this.touching.down, this.wasTouching.left = this.touching.left, this.wasTouching.right = this.touching.right, this.touching.none = !0, this.touching.up = !1, this.touching.down = !1, this.touching.left = !1, this.touching.right = !1, this.blocked.none = !0, this.blocked.up = !1, this.blocked.down = !1, this.blocked.left = !1, this.blocked.right = !1, this.overlapR = 0, this.overlapX = 0, this.overlapY = 0, this.embedded = !1, this.updateBounds(); const e = this.transform; this.position.x = e.x + e.scaleX * (this.offset.x - e.displayOriginX), this.position.y = e.y + e.scaleY * (this.offset.y - e.displayOriginY), this.updateCenter(), this.rotation = e.rotation, this.preRotation = this.rotation, this._reset && (this.prev.x = this.position.x, this.prev.y = this.position.y), this.moves && (this.world.updateMotion(this), this.newVelocity.set(this.velocity.x * t, this.velocity.y * t), this.position.x += this.newVelocity.x, this.position.y += this.newVelocity.y, this.updateCenter(), this.position.x === this.prev.x && this.position.y === this.prev.y || (this.angle = Math.atan2(this.velocity.y, this.velocity.x)), this.speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y), this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds && this.world.emit('worldbounds', this, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right)), this._dx = this.deltaX(), this._dy = this.deltaY(), this._reset = !1; },
    postUpdate() { this.enable && this.dirty && (this.dirty = !1, this._dx = this.deltaX(), this._dy = this.deltaY(), this._dx < 0 ? this.facing = r.FACING_LEFT : this._dx > 0 && (this.facing = r.FACING_RIGHT), this._dy < 0 ? this.facing = r.FACING_UP : this._dy > 0 && (this.facing = r.FACING_DOWN), this.moves && (this.deltaMax.x !== 0 && this._dx !== 0 && (this._dx < 0 && this._dx < -this.deltaMax.x ? this._dx = -this.deltaMax.x : this._dx > 0 && this._dx > this.deltaMax.x && (this._dx = this.deltaMax.x)), this.deltaMax.y !== 0 && this._dy !== 0 && (this._dy < 0 && this._dy < -this.deltaMax.y ? this._dy = -this.deltaMax.y : this._dy > 0 && this._dy > this.deltaMax.y && (this._dy = this.deltaMax.y)), this.gameObject.x += this._dx, this.gameObject.y += this._dy, this._reset = !0), this.updateCenter(), this.allowRotation && (this.gameObject.angle += this.deltaZ()), this.prev.x = this.position.x, this.prev.y = this.position.y); },
    checkWorldBounds() { const t = this.position; const e = this.world.bounds; const i = this.world.checkCollision; const n = this.worldBounce ? -this.worldBounce.x : -this.bounce.x; const s = this.worldBounce ? -this.worldBounce.y : -this.bounce.y; return t.x < e.x && i.left ? (t.x = e.x, this.velocity.x *= n, this.blocked.left = !0, this.blocked.none = !1) : this.right > e.right && i.right && (t.x = e.right - this.width, this.velocity.x *= n, this.blocked.right = !0, this.blocked.none = !1), t.y < e.y && i.up ? (t.y = e.y, this.velocity.y *= s, this.blocked.up = !0, this.blocked.none = !1) : this.bottom > e.bottom && i.down && (t.y = e.bottom - this.height, this.velocity.y *= s, this.blocked.down = !0, this.blocked.none = !1), !this.blocked.none; },
    setOffset(t, e) { return void 0 === e && (e = t), this.offset.set(t, e), this; },
    setSize(t, e, i) { void 0 === i && (i = !0); const n = this.gameObject; if (this.sourceWidth = t, this.sourceHeight = e, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.updateCenter(), i && n.getCenter) { const s = n.displayWidth / 2; const r = n.displayHeight / 2; this.offset.set(s - this.halfWidth, r - this.halfHeight); } return this.isCircle = !1, this.radius = 0, this; },
    setCircle(t, e, i) { return void 0 === e && (e = this.offset.x), void 0 === i && (i = this.offset.y), t > 0 ? (this.isCircle = !0, this.radius = t, this.sourceWidth = 2 * t, this.sourceHeight = 2 * t, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.set(e, i), this.updateCenter()) : this.isCircle = !1, this; },
    reset(t, e) { this.stop(); const i = this.gameObject; i.setPosition(t, e), i.getTopLeft(this.position), this.prev.copy(this.position), this.rotation = i.angle, this.preRotation = i.angle, this.updateBounds(), this.updateCenter(); },
    stop() { return this.velocity.set(0), this.acceleration.set(0), this.speed = 0, this.angularVelocity = 0, this.angularAcceleration = 0, this; },
    getBounds(t) { return t.x = this.x, t.y = this.y, t.right = this.right, t.bottom = this.bottom, t; },
    hitTest(t, e) { return this.isCircle ? n(this, t, e) : h(this, t, e); },
    onFloor() { return this.blocked.down; },
    onCeiling() { return this.blocked.up; },
    onWall() { return this.blocked.left || this.blocked.right; },
    deltaAbsX() { return this.deltaX() > 0 ? this.deltaX() : -this.deltaX(); },
    deltaAbsY() { return this.deltaY() > 0 ? this.deltaY() : -this.deltaY(); },
    deltaX() { return this.position.x - this.prev.x; },
    deltaY() { return this.position.y - this.prev.y; },
    deltaZ() { return this.rotation - this.preRotation; },
    destroy() { this.enable = !1, this.world.pendingDestroy.set(this); },
    drawDebug(t) { const e = this.position; const i = e.x + this.halfWidth; const n = e.y + this.halfHeight; this.debugShowBody && (t.lineStyle(1, this.debugBodyColor), this.isCircle ? t.strokeCircle(i, n, this.width / 2) : t.strokeRect(e.x, e.y, this.width, this.height)), this.debugShowVelocity && (t.lineStyle(1, this.world.defaults.velocityDebugColor, 1), t.lineBetween(i, n, i + this.velocity.x / 2, n + this.velocity.y / 2)); },
    willDrawDebug() { return this.debugShowBody || this.debugShowVelocity; },
    setCollideWorldBounds(t) { return void 0 === t && (t = !0), this.collideWorldBounds = t, this; },
    setVelocity(t, e) { return this.velocity.set(t, e), this; },
    setVelocityX(t) { return this.velocity.x = t, this; },
    setVelocityY(t) { return this.velocity.y = t, this; },
    setBounce(t, e) { return this.bounce.set(t, e), this; },
    setBounceX(t) { return this.bounce.x = t, this; },
    setBounceY(t) { return this.bounce.y = t, this; },
    setAcceleration(t, e) { return this.acceleration.set(t, e), this; },
    setAccelerationX(t) { return this.acceleration.x = t, this; },
    setAccelerationY(t) { return this.acceleration.y = t, this; },
    setAllowDrag(t) { return void 0 === t && (t = !0), this.allowDrag = t, this; },
    setAllowGravity(t) { return void 0 === t && (t = !0), this.allowGravity = t, this; },
    setAllowRotation(t) { return void 0 === t && (t = !0), this.allowRotation = t, this; },
    setDrag(t, e) { return this.drag.set(t, e), this; },
    setDragX(t) { return this.drag.x = t, this; },
    setDragY(t) { return this.drag.y = t, this; },
    setGravity(t, e) { return this.gravity.set(t, e), this; },
    setGravityX(t) { return this.gravity.x = t, this; },
    setGravityY(t) { return this.gravity.y = t, this; },
    setFriction(t, e) { return this.friction.set(t, e), this; },
    setFrictionX(t) { return this.friction.x = t, this; },
    setFrictionY(t) { return this.friction.y = t, this; },
    setAngularVelocity(t) { return this.angularVelocity = t, this; },
    setAngularAcceleration(t) { return this.angularAcceleration = t, this; },
    setAngularDrag(t) { return this.angularDrag = t, this; },
    setMass(t) { return this.mass = t, this; },
    setImmovable(t) { return void 0 === t && (t = !0), this.immovable = t, this; },
    x: { get() { return this.position.x; }, set(t) { this.position.x = t; } },
    y: { get() { return this.position.y; }, set(t) { this.position.y = t; } },
    left: { get() { return this.position.x; } },
    right: { get() { return this.position.x + this.width; } },
    top: { get() { return this.position.y; } },
    bottom: { get() { return this.position.y + this.height; } },
  }); t.exports = c;
}, function (t, e, i) {
  const n = i(339); const s = i(23); const r = i(0); const o = i(338); const a = i(67); const h = i(57); const l = i(9); const u = i(337); const c = i(336); const d = i(4); const f = i(222); const p = i(684); const g = i(14); const v = i(221); const y = i(683); const m = i(678); const x = i(677); const w = i(70); const b = i(334); const T = i(335); const S = i(7); const A = i(39); const C = new r({
    Extends: l,
    initialize(t, e) {
      l.call(this), this.scene = t, this.bodies = new w(), this.staticBodies = new w(), this.pendingDestroy = new w(), this.colliders = new f(), this.gravity = new S(d(e, 'gravity.x', 0), d(e, 'gravity.y', 0)), this.bounds = new g(d(e, 'x', 0), d(e, 'y', 0), d(e, 'width', t.sys.game.config.width), d(e, 'height', t.sys.game.config.height)), this.checkCollision = {
        up: d(e, 'checkCollision.up', !0), down: d(e, 'checkCollision.down', !0), left: d(e, 'checkCollision.left', !0), right: d(e, 'checkCollision.right', !0),
      }, this.OVERLAP_BIAS = d(e, 'overlapBias', 4), this.TILE_BIAS = d(e, 'tileBias', 16), this.forceX = d(e, 'forceX', !1), this.isPaused = d(e, 'isPaused', !1), this._total = 0, this.drawDebug = d(e, 'debug', !1), this.debugGraphic, this.defaults = {
        debugShowBody: d(e, 'debugShowBody', !0), debugShowStaticBody: d(e, 'debugShowStaticBody', !0), debugShowVelocity: d(e, 'debugShowVelocity', !0), bodyDebugColor: d(e, 'debugBodyColor', 16711935), staticBodyDebugColor: d(e, 'debugStaticBodyColor', 255), velocityDebugColor: d(e, 'debugVelocityColor', 65280),
      }, this.maxEntries = d(e, 'maxEntries', 16), this.tree = new v(this.maxEntries), this.staticTree = new v(this.maxEntries), this.treeMinMax = {
        minX: 0, minY: 0, maxX: 0, maxY: 0,
      }, this.drawDebug && this.createDebugGraphic();
    },
    enable(t, e) { void 0 === e && (e = a.DYNAMIC_BODY); let i = 1; if (Array.isArray(t)) for (i = t.length; i--;)t[i].hasOwnProperty('children') ? this.enable(t[i].children.entries, e) : this.enableBody(t[i], e); else t.hasOwnProperty('children') ? this.enable(t.children.entries, e) : this.enableBody(t, e); },
    enableBody(t, e) { return t.body === null && (e === a.DYNAMIC_BODY ? (t.body = new n(this, t), this.bodies.set(t.body)) : e === a.STATIC_BODY && (t.body = new b(this, t), this.staticBodies.set(t.body), this.staticTree.insert(t.body))), t; },
    remove(t) { this.disableBody(t); },
    disable(t) { let e = 1; if (Array.isArray(t)) for (e = t.length; e--;)t[e].hasOwnProperty('children') ? this.disable(t[e].children.entries) : this.disableGameObjectBody(t[e]); else t.hasOwnProperty('children') ? this.disable(t.children.entries) : this.disableGameObjectBody(t); },
    disableGameObjectBody(t) { return t.body && (t.body.physicsType === a.DYNAMIC_BODY ? this.bodies.delete(t.body) : t.body.physicsType === a.STATIC_BODY && (this.staticBodies.delete(t.body), this.staticTree.remove(t.body)), t.body.enable = !1), t; },
    disableBody(t) { t.physicsType === a.DYNAMIC_BODY ? (this.tree.remove(t), this.bodies.delete(t)) : t.physicsType === a.STATIC_BODY && (this.staticBodies.delete(t), this.staticTree.remove(t)), t.enable = !1; },
    createDebugGraphic() { const t = this.scene.sys.add.graphics({ x: 0, y: 0 }); return t.setDepth(Number.MAX_VALUE), this.debugGraphic = t, this.drawDebug = !0, t; },
    setBounds(t, e, i, n, s, r, o, a) { return this.bounds.setTo(t, e, i, n), void 0 !== s && this.setBoundsCollision(s, r, o, a), this; },
    setBoundsCollision(t, e, i, n) { return void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i && (i = !0), void 0 === n && (n = !0), this.checkCollision.left = t, this.checkCollision.right = e, this.checkCollision.up = i, this.checkCollision.down = n, this; },
    pause() { return this.isPaused = !0, this.emit('pause'), this; },
    resume() { return this.isPaused = !1, this.emit('resume'), this; },
    addCollider(t, e, i, n, s) { void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = i); const r = new o(this, !1, t, e, i, n, s); return this.colliders.add(r), r; },
    addOverlap(t, e, i, n, s) { void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = i); const r = new o(this, !0, t, e, i, n, s); return this.colliders.add(r), r; },
    removeCollider(t) { return this.colliders.remove(t), this; },
    update(t, e) { if (!this.isPaused && this.bodies.size !== 0) { let i; let n; e /= 1e3, this.delta = e; const s = this.bodies.entries; const r = s.length; for (i = 0; i < r; i++)(n = s[i]).enable && n.update(e); this.tree.clear(), this.tree.load(s); const o = this.colliders.update(); for (i = 0; i < o.length; i++) { const a = o[i]; a.active && a.update(); } } },
    postUpdate() { let t; let e; const i = this.bodies; const n = this.staticBodies; const s = this.pendingDestroy; let r = i.entries; let o = r.length; for (t = 0; t < o; t++)(e = r[t]).enable && e.postUpdate(); if (this.drawDebug) { const h = this.debugGraphic; for (h.clear(), t = 0; t < o; t++)(e = r[t]).willDrawDebug() && e.drawDebug(h); for (o = (r = n.entries).length, t = 0; t < o; t++)(e = r[t]).willDrawDebug() && e.drawDebug(h); } if (s.size > 0) { const l = this.tree; const u = this.staticTree; for (o = (r = s.entries).length, t = 0; t < o; t++)(e = r[t]).physicsType === a.DYNAMIC_BODY ? (l.remove(e), i.delete(e)) : e.physicsType === a.STATIC_BODY && (u.remove(e), n.delete(e)), e.world = void 0, e.gameObject = void 0; s.clear(); } },
    updateMotion(t) { if (t.allowRotation) { const e = this.computeVelocity(0, t, t.angularVelocity, t.angularAcceleration, t.angularDrag, t.maxAngular) - t.angularVelocity; t.angularVelocity += e, t.rotation += t.angularVelocity * this.delta; }t.velocity.x = this.computeVelocity(1, t, t.velocity.x, t.acceleration.x, t.drag.x, t.maxVelocity.x), t.velocity.y = this.computeVelocity(2, t, t.velocity.y, t.acceleration.y, t.drag.y, t.maxVelocity.y); },
    computeVelocity(t, e, i, n, s, r) { return void 0 === r && (r = 1e4), t === 1 && e.allowGravity ? i += (this.gravity.x + e.gravity.x) * this.delta : t === 2 && e.allowGravity && (i += (this.gravity.y + e.gravity.y) * this.delta), n ? i += n * this.delta : s && e.allowDrag && (i - (s *= this.delta) > 0 ? i -= s : i + s < 0 ? i += s : i = 0), i > r ? i = r : i < -r && (i = -r), i; },
    separate(t, e, i, n, s) {
      if (!t.enable || !e.enable || t.checkCollision.none || e.checkCollision.none || !this.intersects(t, e)) return !1; if (i && !1 === i.call(n, t.gameObject, e.gameObject)) return !1; if (t.isCircle && e.isCircle) return this.separateCircle(t, e, s); if (t.isCircle !== e.isCircle) {
        const r = t.isCircle ? e : t; const o = t.isCircle ? t : e; const a = {
          x: r.x, y: r.y, right: r.right, bottom: r.bottom,
        }; const h = o.center; if ((h.y < a.y || h.y > a.bottom) && (h.x < a.x || h.x > a.right)) return this.separateCircle(t, e, s);
      } let l = !1; let u = !1; this.forceX || Math.abs(this.gravity.y + t.gravity.y) < Math.abs(this.gravity.x + t.gravity.x) ? (l = m(t, e, s, this.OVERLAP_BIAS), this.intersects(t, e) && (u = x(t, e, s, this.OVERLAP_BIAS))) : (u = x(t, e, s, this.OVERLAP_BIAS), this.intersects(t, e) && (l = m(t, e, s, this.OVERLAP_BIAS))); const c = l || u; return c && (s && (t.onOverlap || e.onOverlap) ? this.emit('overlap', t.gameObject, e.gameObject, t, e) : (t.onCollide || e.onCollide) && this.emit('collide', t.gameObject, e.gameObject, t, e)), c;
    },
    separateCircle(t, e, i, n) {
      u(t, e, !1, n), c(t, e, !1, n); const s = e.center.x - t.center.x; const r = e.center.y - t.center.y; const o = Math.atan2(r, s); let a = 0; if (t.isCircle !== e.isCircle) {
        const l = {
          x: e.isCircle ? t.position.x : e.position.x, y: e.isCircle ? t.position.y : e.position.y, right: e.isCircle ? t.right : e.right, bottom: e.isCircle ? t.bottom : e.bottom,
        }; const d = { x: t.isCircle ? t.center.x : e.center.x, y: t.isCircle ? t.center.y : e.center.y, radius: t.isCircle ? t.halfWidth : e.halfWidth }; d.y < l.y ? d.x < l.x ? a = h(d.x, d.y, l.x, l.y) - d.radius : d.x > l.right && (a = h(d.x, d.y, l.right, l.y) - d.radius) : d.y > l.bottom && (d.x < l.x ? a = h(d.x, d.y, l.x, l.bottom) - d.radius : d.x > l.right && (a = h(d.x, d.y, l.right, l.bottom) - d.radius)), a *= -1;
      } else a = t.halfWidth + e.halfWidth - h(t.center.x, t.center.y, e.center.x, e.center.y); if (i || a === 0 || t.immovable && e.immovable || t.customSeparateX || e.customSeparateX) return a !== 0 && (t.onOverlap || e.onOverlap) && this.emit('overlap', t.gameObject, e.gameObject, t, e), a !== 0; let f = t.velocity.x; let p = t.velocity.y; const g = t.mass; let v = e.velocity.x; let { y } = e.velocity; const m = e.mass; const x = f * Math.cos(o) + p * Math.sin(o); const w = f * Math.sin(o) - p * Math.cos(o); const b = v * Math.cos(o) + y * Math.sin(o); const T = v * Math.sin(o) - y * Math.cos(o); const S = ((g - m) * x + 2 * m * b) / (g + m); const A = (2 * g * x + (m - g) * b) / (g + m); return t.immovable || (t.velocity.x = (S * Math.cos(o) - w * Math.sin(o)) * t.bounce.x, t.velocity.y = (w * Math.cos(o) + S * Math.sin(o)) * t.bounce.y, f = t.velocity.x, p = t.velocity.y), e.immovable || (e.velocity.x = (A * Math.cos(o) - T * Math.sin(o)) * e.bounce.x, e.velocity.y = (T * Math.cos(o) + A * Math.sin(o)) * e.bounce.y, v = e.velocity.x, y = e.velocity.y), Math.abs(o) < Math.PI / 2 ? f > 0 && !t.immovable && v > f ? t.velocity.x *= -1 : v < 0 && !e.immovable && f < v ? e.velocity.x *= -1 : p > 0 && !t.immovable && y > p ? t.velocity.y *= -1 : y < 0 && !e.immovable && p < y && (e.velocity.y *= -1) : Math.abs(o) > Math.PI / 2 && (f < 0 && !t.immovable && v < f ? t.velocity.x *= -1 : v > 0 && !e.immovable && f > v ? e.velocity.x *= -1 : p < 0 && !t.immovable && y < p ? t.velocity.y *= -1 : y > 0 && !e.immovable && f > y && (e.velocity.y *= -1)), t.immovable || (t.x += t.velocity.x * this.delta - a * Math.cos(o), t.y += t.velocity.y * this.delta - a * Math.sin(o)), e.immovable || (e.x += e.velocity.x * this.delta + a * Math.cos(o), e.y += e.velocity.y * this.delta + a * Math.sin(o)), (t.onCollide || e.onCollide) && this.emit('collide', t.gameObject, e.gameObject, t, e), !0;
    },
    intersects(t, e) { return t !== e && (t.isCircle ? e.isCircle ? h(t.center.x, t.center.y, e.center.x, e.center.y) <= t.halfWidth + e.halfWidth : this.circleBodyIntersects(t, e) : e.isCircle ? this.circleBodyIntersects(e, t) : !(t.right <= e.position.x) && (!(t.bottom <= e.position.y) && (!(t.position.x >= e.right) && !(t.position.y >= e.bottom)))); },
    circleBodyIntersects(t, e) { const i = s(t.center.x, e.left, e.right); const n = s(t.center.y, e.top, e.bottom); return (t.center.x - i) * (t.center.x - i) + (t.center.y - n) * (t.center.y - n) <= t.halfWidth * t.halfWidth; },
    overlap(t, e, i, n, s) { return void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = i), this.collideObjects(t, e, i, n, s, !0); },
    collide(t, e, i, n, s) { return void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = i), this.collideObjects(t, e, i, n, s, !1); },
    collideObjects(t, e, i, n, s, r) { let o; t.isParent && void 0 === t.physicsType && (t = t.children.entries), e && e.isParent && void 0 === e.physicsType && (e = e.children.entries); const a = Array.isArray(t); const h = Array.isArray(e); if (this._total = 0, a || h) if (!a && h) for (o = 0; o < e.length; o++) this.collideHandler(t, e[o], i, n, s, r); else if (a && !h) for (o = 0; o < t.length; o++) this.collideHandler(t[o], e, i, n, s, r); else for (o = 0; o < t.length; o++) for (let l = 0; l < e.length; l++) this.collideHandler(t[o], e[l], i, n, s, r); else this.collideHandler(t, e, i, n, s, r); return this._total > 0; },
    collideHandler(t, e, i, n, s, r) { if (void 0 === e && t.isParent) return this.collideGroupVsGroup(t, t, i, n, s, r); if (!t || !e) return !1; if (t.body) { if (e.body) return this.collideSpriteVsSprite(t, e, i, n, s, r); if (e.isParent) return this.collideSpriteVsGroup(t, e, i, n, s, r); if (e.isTilemap) return this.collideSpriteVsTilemapLayer(t, e, i, n, s, r); } else if (t.isParent) { if (e.body) return this.collideSpriteVsGroup(e, t, i, n, s, r); if (e.isParent) return this.collideGroupVsGroup(t, e, i, n, s, r); if (e.isTilemap) return this.collideGroupVsTilemapLayer(t, e, i, n, s, r); } else if (t.isTilemap) { if (e.body) return this.collideSpriteVsTilemapLayer(e, t, i, n, s, r); if (e.isParent) return this.collideGroupVsTilemapLayer(e, t, i, n, s, r); } },
    collideSpriteVsSprite(t, e, i, n, s, r) { return !(!t.body || !e.body) && (this.separate(t.body, e.body, n, s, r) && (i && i.call(s, t, e), this._total++), !0); },
    collideSpriteVsGroup(t, e, i, n, s, r) { const o = t.body; if (e.length !== 0 && o) { const h = this.treeMinMax; h.minX = o.left, h.minY = o.top, h.maxX = o.right, h.maxY = o.bottom; const l = e.physicsType === a.DYNAMIC_BODY ? this.tree.search(h) : this.staticTree.search(h); if (l.length !== 0) for (let u = e.getChildren(), c = 0; c < u.length; c++) { const d = u[c].body; d && o !== d && l.indexOf(d) !== -1 && (this.separate(o, d, n, s, r) && (i && i.call(s, o.gameObject, d.gameObject), this._total++)); } } },
    collideGroupVsTilemapLayer(t, e, i, n, s, r) { const o = t.getChildren(); if (o.length === 0) return !1; for (var a = !1, h = 0; h < o.length; h++)o[h].body && this.collideSpriteVsTilemapLayer(o[h], e, i, n, s, r) && (a = !0); return a; },
    collideSpriteVsTilemapLayer(t, e, i, n, s, r) {
      const o = t.body; if (!o.enable) return !1; let a = o.position.x; const h = o.position.y; let l = o.width; let u = o.height; const c = e.layer; if (c.tileWidth > c.baseTileWidth) { const d = (c.tileWidth - c.baseTileWidth) * e.scaleX; a -= d, l += d; }c.tileHeight > c.baseTileHeight && (u += (c.tileHeight - c.baseTileHeight) * e.scaleY); let f; const g = e.getTilesWithinWorldXY(a, h, l, u); if (g.length === 0) return !1; for (let v = {
          left: 0, right: 0, top: 0, bottom: 0,
        }, m = 0; m < g.length; m++)f = g[m], v.left = e.tileToWorldX(f.x), v.top = e.tileToWorldY(f.y), f.baseHeight !== f.height && (v.top -= (f.height - f.baseHeight) * e.scaleY), v.right = v.left + f.width * e.scaleX, v.bottom = v.top + f.height * e.scaleY, T(v, o) && (!n || n.call(s, t, f)) && p(f, t) && (r || y(m, o, f, v, e, this.TILE_BIAS)) && (this._total++, i && i.call(s, t, f), r && o.onOverlap ? t.emit('overlap', o.gameObject, f, o, null) : o.onCollide && t.emit('collide', o.gameObject, f, o, null));
    },
    collideGroupVsGroup(t, e, i, n, s, r) { if (t.length !== 0 && e.length !== 0) for (let o = t.getChildren(), a = 0; a < o.length; a++) this.collideSpriteVsGroup(o[a], e, i, n, s, r); },
    wrap(t, e) { t.body ? this.wrapObject(t, e) : t.getChildren ? this.wrapArray(t.getChildren(), e) : Array.isArray(t) ? this.wrapArray(t, e) : this.wrapObject(t, e); },
    wrapArray(t, e) { if (t.length !== 0) for (let i = 0, n = t.length; i < n; i++) this.wrapObject(t[i], e); },
    wrapObject(t, e) { void 0 === e && (e = 0), t.x = A(t.x, this.bounds.left - e, this.bounds.right + e), t.y = A(t.y, this.bounds.top - e, this.bounds.bottom + e); },
    shutdown() { this.tree.clear(), this.staticTree.clear(), this.bodies.clear(), this.staticBodies.clear(), this.colliders.destroy(), this.removeAllListeners(); },
    destroy() { this.shutdown(), this.scene = null; },
  }); t.exports = C;
}, function (t, e, i) {
  const n = i(141); const s = i(0); const r = i(67); const o = i(109); const a = new s({
    Extends: o, initialize(t, e, i, s) { void 0 !== s || Array.isArray(i) || typeof i !== 'object' ? void 0 === s && (s = {}) : (s = i, i = null), this.world = t, s.createCallback = this.createCallbackHandler, s.removeCallback = this.removeCallbackHandler, s.createMultipleCallback = this.createMultipleCallbackHandler, s.classType = n, this.physicsType = r.STATIC_BODY, o.call(this, e, i, s); }, createCallbackHandler(t) { t.body || this.world.enableBody(t, r.STATIC_BODY); }, removeCallbackHandler(t) { t.body && this.world.disableBody(t); }, createMultipleCallbackHandler() { this.refresh(); }, refresh() { for (let t = this.children.entries, e = 0; e < t.length; e++)t[e].body.reset(); return this; },
  }); t.exports = a;
}, function (t, e, i) {
  const n = i(141); const s = i(0); const r = i(67); const o = i(1); const a = i(109); const h = new s({
    Extends: a,
    initialize(t, e, i, s) {
      void 0 !== s || Array.isArray(i) || typeof i !== 'object' ? void 0 === s && (s = {}) : (s = i, i = null), this.world = t, s.createCallback = this.createCallbackHandler, s.removeCallback = this.removeCallbackHandler, s.classType = o(s, 'classType', n), this.physicsType = r.DYNAMIC_BODY, this.defaults = {
        setCollideWorldBounds: o(s, 'collideWorldBounds', !1), setAccelerationX: o(s, 'accelerationX', 0), setAccelerationY: o(s, 'accelerationY', 0), setAllowDrag: o(s, 'allowDrag', !0), setAllowGravity: o(s, 'allowGravity', !0), setAllowRotation: o(s, 'allowRotation', !0), setBounceX: o(s, 'bounceX', 0), setBounceY: o(s, 'bounceY', 0), setDragX: o(s, 'dragX', 0), setDragY: o(s, 'dragY', 0), setGravityX: o(s, 'gravityX', 0), setGravityY: o(s, 'gravityY', 0), setFrictionX: o(s, 'frictionX', 0), setFrictionY: o(s, 'frictionY', 0), setVelocityX: o(s, 'velocityX', 0), setVelocityY: o(s, 'velocityY', 0), setAngularVelocity: o(s, 'angularVelocity', 0), setAngularAcceleration: o(s, 'angularAcceleration', 0), setAngularDrag: o(s, 'angularDrag', 0), setMass: o(s, 'mass', 1), setImmovable: o(s, 'immovable', !1),
      }, a.call(this, e, i, s);
    },
    createCallbackHandler(t) { t.body || this.world.enableBody(t, r.DYNAMIC_BODY); const e = t.body; for (const i in this.defaults)e[i](this.defaults[i]); },
    removeCallbackHandler(t) { t.body && this.world.disableBody(t); },
    setVelocity(t, e, i) { void 0 === i && (i = 0); for (let n = this.getChildren(), s = 0; s < n.length; s++)n[s].body.velocity.set(t + s * i, e + s * i); return this; },
    setVelocityX(t, e) { void 0 === e && (e = 0); for (let i = this.getChildren(), n = 0; n < i.length; n++)i[n].body.velocity.x = t + n * e; return this; },
    setVelocityY(t, e) { void 0 === e && (e = 0); for (let i = this.getChildren(), n = 0; n < i.length; n++)i[n].body.velocity.y = t + n * e; return this; },
  }); t.exports = h;
}, function (t, e, i) {
  t.exports = {
    Acceleration: i(696), Angular: i(695), Bounce: i(694), Debug: i(693), Drag: i(692), Enable: i(691), Friction: i(690), Gravity: i(689), Immovable: i(688), Mass: i(687), Size: i(686), Velocity: i(685),
  };
}, function (t, e, i) { const n = i(0); const s = i(343); const r = i(69); const o = new n({ Extends: r, Mixins: [s.Acceleration, s.Angular, s.Bounce, s.Debug, s.Drag, s.Enable, s.Friction, s.Gravity, s.Immovable, s.Mass, s.Size, s.Velocity], initialize(t, e, i, n, s) { r.call(this, t, e, i, n, s); } }); t.exports = o; }, function (t, e, i) {
  const n = i(344); const s = i(141); const r = i(0); const o = i(67); const a = i(342); const h = i(341); const l = new r({
    initialize(t) { this.world = t, this.scene = t.scene, this.sys = t.scene.sys; }, collider(t, e, i, n, s) { return this.world.addCollider(t, e, i, n, s); }, overlap(t, e, i, n, s) { return this.world.addOverlap(t, e, i, n, s); }, existing(t, e) { const i = e ? o.STATIC_BODY : o.DYNAMIC_BODY; return this.world.enableBody(t, i), t; }, staticImage(t, e, i, s) { const r = new n(this.scene, t, e, i, s); return this.sys.displayList.add(r), this.world.enableBody(r, o.STATIC_BODY), r; }, image(t, e, i, s) { const r = new n(this.scene, t, e, i, s); return this.sys.displayList.add(r), this.world.enableBody(r, o.DYNAMIC_BODY), r; }, staticSprite(t, e, i, n) { const r = new s(this.scene, t, e, i, n); return this.sys.displayList.add(r), this.sys.updateList.add(r), this.world.enableBody(r, o.STATIC_BODY), r; }, sprite(t, e, i, n) { const r = new s(this.scene, t, e, i, n); return this.sys.displayList.add(r), this.sys.updateList.add(r), this.world.enableBody(r, o.DYNAMIC_BODY), r; }, staticGroup(t, e) { return this.sys.updateList.add(new h(this.world, this.world.scene, t, e)); }, group(t, e) { return this.sys.updateList.add(new a(this.world, this.world.scene, t, e)); }, destroy() { this.world = null, this.scene = null, this.sys = null; },
  }); t.exports = l;
}, function (t, e) { t.exports = function (t, e) { const i = t.x; const n = t.y; return t.x = i * Math.cos(e) - n * Math.sin(e), t.y = i * Math.sin(e) + n * Math.cos(e), t; }; }, function (t, e) { t.exports = function (t) { if (t === 0) return 1; for (var e = t; --t;)e *= t; return e; }; }, function (t, e, i) { const n = i(347); t.exports = function (t, e) { return n(t) / n(e) / n(t - e); }; }, function (t, e) { t.exports = function (t) { return (t %= 2 * Math.PI) >= 0 ? t : t + 2 * Math.PI; }; }, function (t, e, i) {
  const n = i(0); const s = i(17); const r = i(70); const o = i(9); const a = i(6); const h = i(1); const l = i(12); const u = i(74); const c = new n({
    Extends: o, initialize(t) { o.call(this); const e = t.sys.game.config; const i = t.sys.settings.loader; this.scene = t, this.systems = t.sys, this.cacheManager = t.sys.cache, this.textureManager = t.sys.textures, a.install(this), this.prefix = '', this.path = '', this.baseURL = '', this.setBaseURL(h(i, 'baseURL', e.loaderBaseURL)), this.setPath(h(i, 'path', e.loaderPath)), this.setPrefix(h(i, 'prefix', e.loaderPrefix)), this.maxParallelDownloads = h(i, 'maxParallelDownloads', e.loaderMaxParallelDownloads), this.xhr = u(h(i, 'responseType', e.loaderResponseType), h(i, 'async', e.loaderAsync), h(i, 'user', e.loaderUser), h(i, 'password', e.loaderPassword), h(i, 'timeout', e.loaderTimeout)), this.crossOrigin = h(i, 'crossOrigin', e.loaderCrossOrigin), this.totalToLoad = 0, this.progress = 0, this.list = new r(), this.inflight = new r(), this.queue = new r(), this._deleteQueue = new r(), this.totalFailed = 0, this.totalComplete = 0, this.state = s.LOADER_IDLE, t.sys.events.once('boot', this.boot, this), t.sys.events.on('start', this.pluginStart, this); }, boot() { this.systems.events.once('destroy', this.destroy, this); }, pluginStart() { this.systems.events.once('shutdown', this.shutdown, this); }, setBaseURL(t) { return void 0 === t && (t = ''), t !== '' && t.substr(-1) !== '/' && (t = t.concat('/')), this.baseURL = t, this; }, setPath(t) { return void 0 === t && (t = ''), t !== '' && t.substr(-1) !== '/' && (t = t.concat('/')), this.path = t, this; }, setPrefix(t) { return void 0 === t && (t = ''), this.prefix = t, this; }, setCORS(t) { return this.crossOrigin = t, this; }, addFile(t) { Array.isArray(t) || (t = [t]); for (let e = 0; e < t.length; e++) { const i = t[e]; this.keyExists(i) || (this.list.set(i), this.emit('addfile', i.key, i.type, this, i), this.isLoading() && (this.totalToLoad++, this.updateProgress())); } }, keyExists(t) { let e = t.hasCacheConflict(); return e || this.list.iterate((i) => { if (i.type === t.type && i.key === t.key) return e = !0, !1; }), !e && this.isLoading() && (this.inflight.iterate((i) => { if (i.type === t.type && i.key === t.key) return e = !0, !1; }), this.queue.iterate((i) => { if (i.type === t.type && i.key === t.key) return e = !0, !1; })), e; }, addPack(t, e) { e && t.hasOwnProperty(e) && (t = { packKey: t[e] }); let i = 0; const n = this.baseURL; const s = this.path; const r = this.prefix; for (const o in t) { const a = t[o]; const l = h(a, 'baseURL', n); const u = h(a, 'path', s); const c = h(a, 'prefix', r); const d = h(a, 'files', null); const f = h(a, 'defaultType', 'void'); if (Array.isArray(d)) { this.setBaseURL(l), this.setPath(u), this.setPrefix(c); for (let p = 0; p < d.length; p++) { const g = d[p]; const v = g.hasOwnProperty('type') ? g.type : f; this[v] && (this[v](g), i++); } } } return this.setBaseURL(n), this.setPath(s), this.setPrefix(r), i > 0; }, isLoading() { return this.state === s.LOADER_LOADING || this.state === s.LOADER_PROCESSING; }, isReady() { return this.state === s.LOADER_IDLE || this.state === s.LOADER_COMPLETE; }, start() { this.isReady() && (this.progress = 0, this.totalFailed = 0, this.totalComplete = 0, this.totalToLoad = this.list.size, this.emit('start', this), this.list.size === 0 ? this.loadComplete() : (this.state = s.LOADER_LOADING, this.inflight.clear(), this.queue.clear(), this.updateProgress(), this.checkLoadQueue())); }, updateProgress() { this.progress = 1 - (this.list.size + this.inflight.size) / this.totalToLoad, this.emit('progress', this.progress); }, checkLoadQueue() { this.list.each(function (t) { if ((t.state === s.FILE_POPULATED || t.state === s.FILE_PENDING && this.inflight.size < this.maxParallelDownloads) && (this.inflight.set(t), this.list.delete(t), t.crossOrigin || (t.crossOrigin = this.crossOrigin), t.load()), this.inflight.size === this.maxParallelDownloads) return !1; }, this); }, nextFile(t, e) { this.inflight.delete(t), this.updateProgress(), e ? (this.totalComplete++, this.queue.set(t), this.emit('load', t), t.onProcess()) : (this.totalFailed++, this._deleteQueue.set(t), this.emit('loaderror', t)), this.list.size > 0 && this.checkLoadQueue(); }, fileProcessComplete(t) { t.state === s.FILE_ERRORED ? t.multiFile && t.multiFile.onFileFailed(t) : t.state === s.FILE_COMPLETE && (t.multiFile ? t.multiFile.isReadyToProcess() && t.multiFile.addToCache() : t.addToCache()), this.queue.delete(t), this.list.size === 0 && this.inflight.size === 0 && this.queue.size === 0 ? this.loadComplete() : this.checkLoadQueue(); }, loadComplete() { this.emit('loadcomplete', this), this.list.clear(), this.inflight.clear(), this.queue.clear(), this.progress = 1, this.state = s.LOADER_COMPLETE, this._deleteQueue.iterateLocal('destroy'), this._deleteQueue.clear(), this.emit('complete', this, this.totalComplete, this.totalFailed); }, flagForRemoval(t) { this._deleteQueue.set(t); }, saveJSON(t, e) { return this.save(JSON.stringify(t), e); }, save(t, e, i) { void 0 === e && (e = 'file.json'), void 0 === i && (i = 'application/json'); const n = new Blob([t], { type: i }); const s = URL.createObjectURL(n); const r = document.createElement('a'); return r.download = e, r.textContent = `Download ${e}`, r.href = s, r.click(), this; }, reset() { this.list.clear(), this.inflight.clear(), this.queue.clear(); const t = this.systems.game.config; const e = this.systems.settings.loader; this.setBaseURL(h(e, 'baseURL', t.loaderBaseURL)), this.setPath(h(e, 'path', t.loaderPath)), this.setPrefix(h(e, 'prefix', t.loaderPrefix)), this.state = s.LOADER_IDLE; }, shutdown() { this.reset(), this.state = s.LOADER_SHUTDOWN, this.systems.events.off('shutdown', this.shutdown, this); }, destroy() { this.shutdown(), this.state = s.LOADER_DESTROYED, this.systems.events.off('start', this.pluginStart, this), this.list = null, this.inflight = null, this.queue = null, this.scene = null, this.systems = null, this.textureManager = null, this.cacheManager = null; },
  }); l.register('Loader', c, 'load'), t.exports = c;
}, function (t, e, i) { const n = i(0); const s = i(6); const r = i(37); const o = new n({ Extends: r, initialize(t, e, i, n, s) { r.call(this, t, e, i, s, n), this.type = 'spritesheet'; }, addToCache() { const t = this.cache.addSpriteSheet(this.key, this.data, this.config); this.pendingDestroy(t); } }); s.register('spritesheet', function (t, e, i, n) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new o(this, t[s])); else this.addFile(new o(this, t, e, i, n)); return this; }), t.exports = o; }, function (t, e, i) {
  const n = i(0); const s = i(17); const r = i(19); const o = i(6); const a = i(1); const h = i(8); const l = new n({
    Extends: r,
    initialize(t, e, i, n) {
      let s = 'js'; if (h(e)) { const o = e; e = a(o, 'key'), i = a(o, 'url'), n = a(o, 'xhrSettings'), s = a(o, 'extension', s); } const l = {
        type: 'script', cache: !1, extension: s, responseType: 'text', key: e, url: i, xhrSettings: n,
      }; r.call(this, t, l);
    },
    onProcess() { this.state = s.FILE_PROCESSING, this.data = document.createElement('script'), this.data.language = 'javascript', this.data.type = 'text/javascript', this.data.defer = !1, this.data.text = this.xhrLoader.responseText, document.head.appendChild(this.data), this.onProcessComplete(); },
  }); o.register('script', function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new l(this, t[n])); else this.addFile(new l(this, t, e, i)); return this; }), t.exports = l;
}, function (t, e, i) {
  const n = i(0); const s = i(17); const r = i(19); const o = i(6); const a = i(1); const h = i(8); const l = new n({
    Extends: r,
    initialize(t, e, i, n, o, l) {
      let u = 'js'; if (h(e)) { const c = e; e = a(c, 'key'), i = a(c, 'url'), l = a(c, 'xhrSettings'), u = a(c, 'extension', u), n = a(c, 'start'), o = a(c, 'mapping'); } const d = {
        type: 'plugin', cache: !1, extension: u, responseType: 'text', key: e, url: i, xhrSettings: l, config: { start: n, mapping: o },
      }; r.call(this, t, d), typeof i === 'function' && (this.data = i, this.state = s.FILE_POPULATED);
    },
    onProcess() { const t = this.loader.systems.plugins; const e = this.config; const i = a(e, 'start', !1); const n = a(e, 'mapping', null); this.state === s.FILE_POPULATED ? t.install(this.key, this.data, i, n) : (this.state = s.FILE_PROCESSING, this.data = document.createElement('script'), this.data.language = 'javascript', this.data.type = 'text/javascript', this.data.defer = !1, this.data.text = this.xhrLoader.responseText, document.head.appendChild(this.data), t.install(this.key, window[this.key], i, n)), this.onProcessComplete(); },
  }); o.register('plugin', function (t, e, i, n, s) { if (Array.isArray(t)) for (let r = 0; r < t.length; r++) this.addFile(new l(this, t[r])); else this.addFile(new l(this, t, e, i, n, s)); return this; }), t.exports = l;
}, function (t, e, i) {
  const n = i(0); const s = i(6); const r = i(1); const o = i(37); const a = i(8); const h = i(28); const l = i(36); const u = new n({
    Extends: l, initialize(t, e, i, n, s, o, u) { if (a(e)) { const c = e; e = r(c, 'key'), i = r(c, 'url'), o = r(c, 'xhrSettings'), n = r(c, 'path'), s = r(c, 'baseURL'), u = r(c, 'textureXhrSettings'); } const d = new h(t, e, i, o); l.call(this, t, 'multiatlas', e, [d]), this.config.path = n, this.config.baseURL = s, this.config.textureXhrSettings = u; }, onFileComplete(t) { if (this.files.indexOf(t) !== -1 && (this.pending--, t.type === 'json' && t.data.hasOwnProperty('textures'))) { const e = t.data.textures; const i = this.config; const n = this.loader; const s = n.baseURL; const a = n.path; const h = n.prefix; const l = r(i, 'baseURL', s); const u = r(i, 'path', a); const c = r(i, 'prefix', h); const d = r(i, 'textureXhrSettings'); n.setBaseURL(l), n.setPath(u), n.setPrefix(c); for (let f = 0; f < e.length; f++) { const p = e[f].image; const g = `_MA_${p}`; const v = new o(n, g, p, d); if (this.addToMultiFile(v), n.addFile(v), e[f].normalMap) { const y = new o(n, g, e[f].normalMap, d); y.type = 'normalMap', v.setLink(y), this.addToMultiFile(y), n.addFile(y); } }n.setBaseURL(s), n.setPath(a), n.setPrefix(h); } }, addToCache() { if (this.isReadyToProcess()) { const t = this.files[0]; t.addToCache(); for (var e = [], i = [], n = [], s = 1; s < this.files.length; s++) { const r = this.files[s]; if (r.type !== 'normalMap') for (let o = r.key.substr(4), a = r.data, h = 0; h < t.data.textures.length; h++) { const l = t.data.textures[h]; if (l.image === o) { i.push(a), e.push(l), r.linkFile && n.push(r.linkFile.data); break; } } } for (n.length === 0 && (n = void 0), this.loader.textureManager.addAtlasJSONArray(this.key, i, e, n), this.complete = !0, s = 0; s < this.files.length; s++) this.files[s].pendingDestroy(); } },
  }); s.register('multiatlas', function (t, e, i, n, s) { let r; if (Array.isArray(t)) for (let o = 0; o < t.length; o++)r = new u(this, t[o]), this.addFile(r.files); else r = new u(this, t, e, i, n, s), this.addFile(r.files); return this; }), t.exports = u;
}, function (t, e, i) {
  const n = i(165); const s = i(0); const r = i(6); const o = i(1); const a = i(8); const h = i(28); const l = i(36); const u = new s({
    Extends: l, initialize(t, e, i, s, r, u, c) { if (a(e)) { const d = e; e = o(d, 'key'), i = o(d, 'jsonURL'), s = o(d, 'audioURL'), r = o(d, 'audioConfig'), u = o(d, 'audioXhrSettings'), c = o(d, 'jsonXhrSettings'); } let f; if (s) { const p = n.create(t, e, s, r, u); p && (f = new h(t, e, i, c), l.call(this, t, 'audiosprite', e, [p, f]), this.config.resourceLoad = !1); } else f = new h(t, e, i, c), l.call(this, t, 'audiosprite', e, [f]), this.config.resourceLoad = !0, this.config.audioConfig = r, this.config.audioXhrSettings = u; }, onFileComplete(t) { if (this.files.indexOf(t) !== -1 && (this.pending--, this.config.resourceLoad && t.type === 'json' && t.data.hasOwnProperty('resources'))) { const e = t.data.resources; const i = o(this.config, 'audioConfig'); const s = o(this.config, 'audioXhrSettings'); const r = n.create(this.loader, t.key, e, i, s); r && (this.addToMultiFile(r), this.loader.addFile(r)); } }, addToCache() { if (this.isReadyToProcess()) { const t = this.files[0]; const e = this.files[1]; t.addToCache(), e.addToCache(), this.complete = !0; } },
  }); r.register('audioSprite', function (t, e, i, n, s, r) { let o; const a = this.systems.game; const h = a.config.audio; const l = a.device.audio; if (h && h.noAudio || !l.webAudio && !l.audioData) return this; if (Array.isArray(t)) for (let c = 0; c < t.length; c++)(o = new u(this, t[c])).files && this.addFile(o.files); else (o = new u(this, t, e, i, n, s, r)).files && this.addFile(o.files); return this; });
}, function (t, e, i) {
  const n = i(0); const s = i(6); const r = i(1); const o = i(37); const a = i(8); const h = i(28); const l = i(36); const u = new n({
    Extends: l,
    initialize(t, e, i, n, s, u) {
      let c; let d; if (a(e)) {
        const f = e; e = r(f, 'key'), c = new o(t, {
          key: e, url: r(f, 'textureURL'), extension: r(f, 'textureExtension', 'png'), normalMap: r(f, 'normalMap'), xhrSettings: r(f, 'textureXhrSettings'),
        }), d = new h(t, {
          key: e, url: r(f, 'atlasURL'), extension: r(f, 'atlasExtension', 'json'), xhrSettings: r(f, 'atlasXhrSettings'),
        });
      } else c = new o(t, e, i, s), d = new h(t, e, n, u); c.linkFile ? l.call(this, t, 'atlasjson', e, [c, d, c.linkFile]) : l.call(this, t, 'atlasjson', e, [c, d]);
    },
    addToCache() { if (this.isReadyToProcess()) { const t = this.files[0]; const e = this.files[1]; const i = this.files[2] ? this.files[2].data : null; this.loader.textureManager.addAtlas(t.key, t.data, e.data, i), e.addToCache(), this.complete = !0; } },
  }); s.register('atlas', function (t, e, i, n, s) { let r; if (Array.isArray(t)) for (let o = 0; o < t.length; o++)r = new u(this, t[o]), this.addFile(r.files); else r = new u(this, t, e, i, n, s), this.addFile(r.files); return this; }), t.exports = u;
}, function (t, e, i) {
  const n = i(0); const s = i(6); const r = i(28); const o = new n({
    Extends: r, initialize(t, e, i, n, s) { r.call(this, t, e, i, n, s), this.type = 'animationJSON'; }, onProcess() { this.loader.once('loadcomplete', this.onLoadComplete, this), r.prototype.onProcess.call(this); }, onLoadComplete() { this.loader.systems.anims.fromJSON(this.data), this.pendingDestroy(); },
  }); s.register('animation', function (t, e, i, n) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new o(this, t[s])); else this.addFile(new o(this, t, e, n, i)); return this; }), t.exports = o;
}, function (t, e, i) { t.exports = { TouchManager: i(189) }; }, function (t, e, i) { t.exports = { MouseManager: i(191) }; }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = 50), t.isUp && t.duration < e; }; }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = 50), t.isDown && t.duration < e; }; }, function (t, e) { t.exports = function (t) { return !!t._justUp && (t._justUp = !1, !0); }; }, function (t, e) { t.exports = function (t) { return !!t._justDown && (t._justDown = !1, !0); }; }, function (t, e, i) {
  t.exports = {
    KeyboardManager: i(194), Key: i(193), KeyCodes: i(116), KeyCombo: i(192), JustDown: i(363), JustUp: i(362), DownDuration: i(361), UpDuration: i(360),
  };
}, function (t, e, i) {
  const n = i(87); const s = i(32); const r = i(0); const o = i(57); const a = i(111); const h = i(53); const l = i(9); const u = i(167); const c = i(12); const d = i(14); const f = i(31); const p = i(68); const g = i(59); const v = new r({
    Extends: l,
    initialize(t) {
      l.call(this), this.scene = t, this.systems = t.sys, this.settings = t.sys.settings, this.manager = t.sys.game.input, this.enabled = !0, this.displayList, this.cameras, this.keyboard = this.manager.keyboard, this.mouse = this.manager.mouse, this.gamepad = this.manager.gamepad, this.topOnly = !0, this.pollRate = -1, this._pollTimer = 0, this.dragDistanceThreshold = 0, this.dragTimeThreshold = 0, this._temp = [], this._tempZones = [], this._list = [], this._pendingInsertion = [], this._pendingRemoval = [], this._draggable = [], this._drag = {
        0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [],
      }, this._over = {
        0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [],
      }, this._validTypes = ['onDown', 'onUp', 'onOver', 'onOut', 'onMove', 'onDragStart', 'onDrag', 'onDragEnd', 'onDragEnter', 'onDragLeave', 'onDragOver', 'onDrop'], t.sys.events.once('boot', this.boot, this), t.sys.events.on('start', this.start, this);
    },
    boot() { this.cameras = this.systems.cameras, this.displayList = this.systems.displayList, this.systems.events.once('destroy', this.destroy, this); },
    start() { const t = this.systems.events; t.on('transitionstart', this.transitionIn, this), t.on('transitionout', this.transitionOut, this), t.on('transitioncomplete', this.transitionComplete, this), t.on('preupdate', this.preUpdate, this), t.on('update', this.update, this), t.once('shutdown', this.shutdown, this), this.enabled = !0; },
    preUpdate() { const t = this._pendingRemoval; const e = this._pendingInsertion; const i = t.length; const n = e.length; if (i !== 0 || n !== 0) { for (var s = this._list, r = 0; r < i; r++) { const o = t[r]; const a = s.indexOf(o); a > -1 && (s.splice(a, 1), this.clear(o)); }t.length = 0, this._pendingRemoval.length = 0, this._list = s.concat(e.splice(0)); } },
    clear(t) { const e = t.input; if (e) { this.queueForRemoval(t), e.gameObject = void 0, e.target = void 0, e.hitArea = void 0, e.hitAreaCallback = void 0, e.callbackContext = void 0, t.input = null; let i = this._draggable.indexOf(t); return i > -1 && this._draggable.splice(i, 1), (i = this._drag[0].indexOf(t)) > -1 && this._drag[0].splice(i, 1), (i = this._over[0].indexOf(t)) > -1 && this._over[0].splice(i, 1), t; } },
    disable(t) { t.input.enabled = !1; },
    enable(t, e, i, n) { return void 0 === n && (n = !1), t.input ? t.input.enabled = !0 : this.setHitArea(t, e, i), t.input && (t.input.dropZone = n), this; },
    hitTestPointer(t) { const e = this.cameras.getCameraBelowPointer(t); if (e) { t.camera = e; for (var i = this.manager.hitTest(t.x, t.y, this._list, e), n = 0; n < i.length; n++) { const s = i[n]; s.input.dropZone && this._tempZones.push(s); } return i; } return []; },
    processDownEvents(t) { const e = this._temp; this.emit('pointerdown', t, e); for (var i = 0, n = 0; n < e.length; n++) { const s = e[n]; s.input && (i++, s.emit('pointerdown', t, s.input.localX, s.input.localY, t.camera), this.emit('gameobjectdown', t, s)); } return i; },
    processDragEvents(t, e) { if (this._draggable.length === 0) return 0; let i; let n; let s; let r; const a = this._temp; if (t.dragState === 0 && t.primaryDown && t.justDown && a.length > 0 ? t.dragState = 1 : t.dragState > 0 && !t.primaryDown && t.justUp && (t.dragState = 5), t.dragState === 1) { const h = []; for (i = 0; i < a.length; i++)(n = a[i]).input.draggable && h.push(n); if (h.length === 0) return t.dragState = 0, 0; h.length > 1 && (this.sortGameObjects(h), this.topOnly && h.splice(1)), this._drag[t.id] = h, this.dragDistanceThreshold === 0 && this.dragTimeThreshold === 0 ? t.dragState = 3 : t.dragState = 2; } if (t.dragState === 2 && (this.dragDistanceThreshold > 0 && o(t.x, t.y, t.downX, t.downY) >= this.dragDistanceThreshold && (t.dragState = 3), this.dragTimeThreshold > 0 && e >= t.downTime + this.dragTimeThreshold && (t.dragState = 3)), t.dragState === 3) { for (s = this._drag[t.id], i = 0; i < s.length; i++)(r = (n = s[i]).input).dragState = 2, r.dragX = t.x - n.x, r.dragY = t.y - n.y, r.dragStartX = n.x, r.dragStartY = n.y, n.emit('dragstart', t, r.dragX, r.dragY), this.emit('dragstart', t, n); return t.dragState = 4, s.length; } if (t.dragState === 4 && t.justMoved && !t.justUp) { const l = this._tempZones; for (s = this._drag[t.id], i = 0; i < s.length; i++) { if ((r = (n = s[i]).input).target) { const u = l.indexOf(r.target); u === 0 ? (n.emit('dragover', t, r.target), this.emit('dragover', t, n, r.target)) : u > 0 ? (n.emit('dragleave', t, r.target), this.emit('dragleave', t, n, r.target), r.target = l[0], n.emit('dragenter', t, r.target), this.emit('dragenter', t, n, r.target)) : (n.emit('dragleave', t, r.target), this.emit('dragleave', t, n, r.target), l[0] ? (r.target = l[0], n.emit('dragenter', t, r.target), this.emit('dragenter', t, n, r.target)) : r.target = null); } else !r.target && l[0] && (r.target = l[0], n.emit('dragenter', t, r.target), this.emit('dragenter', t, n, r.target)); const c = t.x - n.input.dragX; const d = t.y - n.input.dragY; n.emit('drag', t, c, d), this.emit('drag', t, n, c, d); } return s.length; } if (t.dragState === 5) { for (s = this._drag[t.id], i = 0; i < s.length; i++) if ((r = (n = s[i]).input).dragState === 2) { r.dragState = 0, r.dragX = r.localX - n.displayOriginX, r.dragY = r.localY - n.displayOriginY; let f = !1; r.target && (n.emit('drop', t, r.target), this.emit('drop', t, n, r.target), r.target = null, f = !0), n.emit('dragend', t, r.dragX, r.dragY, f), this.emit('dragend', t, n, f); }t.dragState = 0, s.splice(0); } return 0; },
    processMoveEvents(t) { const e = this._temp; this.emit('pointermove', t, e); for (var i = 0, n = 0; n < e.length; n++) { const s = e[n]; if (s.input && (i++, s.emit('pointermove', t, s.input.localX, s.input.localY), this.emit('gameobjectmove', t, s), this.topOnly)) break; } return i; },
    processOverOutEvents(t) { let e; let i; const n = this._temp; const s = []; const r = []; const o = []; let a = this._over[t.id]; const h = this._drag[t.id]; for (e = 0; e < a.length; e++)i = a[e], n.indexOf(i) === -1 && h.indexOf(i) === -1 ? s.push(i) : o.push(i); for (e = 0; e < n.length; e++)i = n[e], a.indexOf(i) === -1 && r.push(i); let l = s.length; let u = 0; if (l > 0) for (this.sortGameObjects(s), this.emit('pointerout', t, s), e = 0; e < l; e++)(i = s[e]).input && (this.emit('gameobjectout', t, i), i.emit('pointerout', t), u++); if ((l = r.length) > 0) for (this.sortGameObjects(r), this.emit('pointerover', t, r), e = 0; e < l; e++)(i = r[e]).input && (this.emit('gameobjectover', t, i), i.emit('pointerover', t, i.input.localX, i.input.localY), u++); return a = o.concat(r), this._over[t.id] = this.sortGameObjects(a), u; },
    processUpEvents(t) { const e = this._temp; this.emit('pointerup', t, e); for (let i = 0; i < e.length; i++) { const n = e[i]; n.input && (n.emit('pointerup', t, n.input.localX, n.input.localY), this.emit('gameobjectup', t, n)); } return e.length; },
    queueForInsertion(t) { return this._pendingInsertion.indexOf(t) === -1 && this._list.indexOf(t) === -1 && this._pendingInsertion.push(t), this; },
    queueForRemoval(t) { return this._pendingRemoval.push(t), this; },
    setDraggable(t, e) { void 0 === e && (e = !0), Array.isArray(t) || (t = [t]); for (let i = 0; i < t.length; i++) { const n = t[i]; n.input.draggable = e; const s = this._draggable.indexOf(n); e && s === -1 ? this._draggable.push(n) : !e && s > -1 && this._draggable.splice(s, 1); } return this; },
    setHitArea(t, e, i) { if (void 0 === e) return this.setHitAreaFromTexture(t); Array.isArray(t) || (t = [t]); for (let n = 0; n < t.length; n++) { const s = t[n]; s.input = u(s, e, i), this.queueForInsertion(s); } return this; },
    setHitAreaCircle(t, e, i, r, o) { void 0 === o && (o = s); const a = new n(e, i, r); return this.setHitArea(t, a, o); },
    setHitAreaEllipse(t, e, i, n, s, r) { void 0 === r && (r = h); const o = new a(e, i, n, s); return this.setHitArea(t, o, r); },
    setHitAreaFromTexture(t, e) { void 0 === e && (e = f), Array.isArray(t) || (t = [t]); for (let i = 0; i < t.length; i++) { const n = t[i]; const s = n.frame; let r = 0; let o = 0; s ? (r = s.realWidth, o = s.realHeight) : n.width && (r = n.width, o = n.height), n.type !== 'Container' || r !== 0 && o !== 0 ? r !== 0 && o !== 0 && (n.input = u(n, new d(0, 0, r, o), e), this.queueForInsertion(n)) : console.warn('Container.setInteractive() must specify a Shape or call setSize() first'); } return this; },
    setHitAreaRectangle(t, e, i, n, s, r) { void 0 === r && (r = f); const o = new d(e, i, n, s); return this.setHitArea(t, o, r); },
    setHitAreaTriangle(t, e, i, n, s, r, o, a) { void 0 === a && (a = g); const h = new p(e, i, n, s, r, o); return this.setHitArea(t, h, a); },
    setPollAlways() { return this.pollRate = 0, this._pollTimer = 0, this; },
    setPollOnMove() { return this.pollRate = -1, this._pollTimer = 0, this; },
    setPollRate(t) { return this.pollRate = t, this._pollTimer = 0, this; },
    setGlobalTopOnly(t) { return this.manager.globalTopOnly = t, this; },
    setTopOnly(t) { return this.topOnly = t, this; },
    sortGameObjects(t) { return t.length < 2 ? t : (this.scene.sys.depthSort(), t.sort(this.sortHandlerGO.bind(this))); },
    sortHandlerGO(t, e) { if (!t.parentContainer && !e.parentContainer) return this.displayList.getIndex(e) - this.displayList.getIndex(t); if (t.parentContainer === e.parentContainer) return e.parentContainer.getIndex(e) - t.parentContainer.getIndex(t); if (t.parentContainer === e) return -1; if (e.parentContainer === t) return 1; for (let i = t.getIndexList(), n = e.getIndexList(), s = Math.min(i.length, n.length), r = 0; r < s; r++) { const o = i[r]; const a = n[r]; if (o !== a) return a - o; } return 0; },
    stopPropagation() { return this.manager.globalTopOnly && (this.manager.ignoreEvents = !0), this; },
    update(t, e) { const i = this.manager; if (!(!this.enabled || i.globalTopOnly && i.ignoreEvents)) { const n = i.activePointer; let s = n.dirty || this.pollRate === 0; if (this.pollRate > -1 && (this._pollTimer -= e, this._pollTimer < 0 && (s = !0, this._pollTimer = this.pollRate)), s) { this._tempZones = [], this._temp = this.hitTestPointer(n), this.sortGameObjects(this._temp), this.sortGameObjects(this._tempZones), this.topOnly && (this._temp.length && this._temp.splice(1), this._tempZones.length && this._tempZones.splice(1)); let r = this.processDragEvents(n, t); n.wasTouch || (r += this.processOverOutEvents(n)), n.justDown && (r += this.processDownEvents(n)), n.justUp && (r += this.processUpEvents(n)), n.justMoved && (r += this.processMoveEvents(n)), r > 0 && i.globalTopOnly && (i.ignoreEvents = !0); } } },
    transitionIn() { this.enabled = this.settings.transitionAllowInput; },
    transitionComplete() { this.settings.transitionAllowInput || (this.enabled = !0); },
    transitionOut() { this.enabled = this.settings.transitionAllowInput; },
    shutdown() { this._temp.length = 0, this._list.length = 0, this._draggable.length = 0, this._pendingRemoval.length = 0, this._pendingInsertion.length = 0; for (let t = 0; t < 10; t++) this._drag[t] = [], this._over[t] = []; this.removeAllListeners(); const e = this.systems.events; e.off('transitionstart', this.transitionIn, this), e.off('transitionout', this.transitionOut, this), e.off('transitioncomplete', this.transitionComplete, this), e.off('preupdate', this.preUpdate, this), e.off('update', this.update, this), e.off('shutdown', this.shutdown, this); },
    destroy() { this.shutdown(), this.scene.sys.events.off('start', this.start, this), this.scene = null, this.cameras = null, this.manager = null, this.events = null, this.keyboard = null, this.mouse = null, this.gamepad = null; },
    activePointer: { get() { return this.manager.activePointer; } },
    x: { get() { return this.manager.activePointer.x; } },
    y: { get() { return this.manager.activePointer.y; } },
  }); c.register('InputPlugin', v, 'input'), t.exports = v;
}, function (t, e) {
  t.exports = {
    UP: 12, DOWN: 13, LEFT: 14, RIGHT: 15, MENU: 16, A: 0, B: 1, X: 2, Y: 3, LB: 4, RB: 5, LT: 6, RT: 7, BACK: 8, START: 9, LS: 10, RS: 11, LEFT_STICK_H: 0, LEFT_STICK_V: 1, RIGHT_STICK_H: 2, RIGHT_STICK_V: 3,
  };
}, function (t, e) {
  t.exports = {
    UP: 12, DOWN: 13, LEFT: 14, RIGHT: 15, SELECT: 8, START: 9, B: 0, A: 1, Y: 2, X: 3, LEFT_SHOULDER: 4, RIGHT_SHOULDER: 5,
  };
}, function (t, e) {
  t.exports = {
    UP: 12, DOWN: 13, LEFT: 14, RIGHT: 15, SHARE: 8, OPTIONS: 9, PS: 16, TOUCHBAR: 17, X: 0, CIRCLE: 1, SQUARE: 2, TRIANGLE: 3, L1: 4, R1: 5, L2: 6, R2: 7, L3: 10, R3: 11, LEFT_STICK_H: 0, LEFT_STICK_V: 1, RIGHT_STICK_H: 2, RIGHT_STICK_V: 3,
  };
}, function (t, e, i) { t.exports = { DUALSHOCK_4: i(368), SNES_USB: i(367), XBOX_360: i(366) }; }, function (t, e, i) {
  t.exports = {
    Axis: i(196), Button: i(195), Gamepad: i(197), GamepadManager: i(198), Configs: i(369),
  };
}, function (t, e, i) {
  t.exports = {
    CreateInteractiveObject: i(167), Gamepad: i(370), InputManager: i(199), InputPlugin: i(365), Keyboard: i(364), Mouse: i(359), Pointer: i(190), Touch: i(358),
  };
}, function (t, e, i) { const n = i(5); function s(t, e, i, n) { const s = t - i; const r = e - n; const o = s * s + r * r; return Math.sqrt(o); }t.exports = function (t, e) { void 0 === e && (e = new n()); const i = t.x1; const r = t.y1; const o = t.x2; const a = t.y2; const h = t.x3; const l = t.y3; const u = s(h, l, o, a); const c = s(i, r, h, l); const d = s(o, a, i, r); const f = u + c + d; return e.x = (i * u + o * c + h * d) / f, e.y = (r * u + a * c + l * d) / f, e; }; }, function (t, e) { t.exports = function (t, e, i) { return t.x1 += e, t.y1 += i, t.x2 += e, t.y2 += i, t.x3 += e, t.y3 += i, t; }; }, function (t, e, i) { const n = i(5); t.exports = function (t, e) { return void 0 === e && (e = new n()), e.x = (t.x1 + t.x2 + t.x3) / 3, e.y = (t.y1 + t.y2 + t.y3) / 3, e; }; }, function (t, e) { t.exports = function (t, e, i) { return t.x = e - t.width / 2, t.y = i - t.height / 2, t; }; }, function (t, e, i) { const n = i(14); n.Area = i(795), n.Ceil = i(794), n.CeilAll = i(793), n.CenterOn = i(375), n.Clone = i(792), n.Contains = i(31), n.ContainsPoint = i(791), n.ContainsRect = i(790), n.CopyFrom = i(789), n.Decompose = i(382), n.Equals = i(788), n.FitInside = i(787), n.FitOutside = i(786), n.Floor = i(785), n.FloorAll = i(784), n.FromPoints = i(274), n.GetAspectRatio = i(227), n.GetCenter = i(783), n.GetPoint = i(132), n.GetPoints = i(294), n.GetSize = i(782), n.Inflate = i(781), n.MarchingAnts = i(565), n.MergePoints = i(780), n.MergeRect = i(779), n.MergeXY = i(778), n.Offset = i(777), n.OffsetPoint = i(776), n.Overlaps = i(775), n.Perimeter = i(96), n.PerimeterPoint = i(774), n.Random = i(152), n.Scale = i(773), n.Union = i(460), t.exports = n; }, function (t, e, i) {
  const n = i(0); const s = i(228); const r = new n({
    initialize(t) { this.area = 0, this.points = [], t && this.setTo(t); }, contains(t, e) { return s(this, t, e); }, setTo(t) { if (this.area = 0, this.points = [], !Array.isArray(t)) return this; for (var e, i = Number.MAX_VALUE, n = 0; n < t.length; n++)e = { x: 0, y: 0 }, typeof t[n] === 'number' ? (e.x = t[n], e.y = t[n + 1], n++) : Array.isArray(t[n]) ? (e.x = t[n][0], e.y = t[n][1]) : (e.x = t[n].x, e.y = t[n].y), this.points.push(e), e.y < i && (i = e.y); return this.calculateArea(i), this; }, calculateArea() { if (this.points.length < 3) return this.area = 0, this.area; for (var t, e, i = 0, n = 0; n < this.points.length - 1; n++)t = this.points[n], i += ((e = this.points[n + 1]).x - t.x) * (t.y + e.y); return t = this.points[0], e = this.points[this.points.length - 1], i += (t.x - e.x) * (e.y + t.y), this.area = 0.5 * -i, this.area; },
  }); t.exports = r;
}, function (t, e) { t.exports = function (t) { return t.x * t.x + t.y * t.y; }; }, function (t, e) { t.exports = function (t) { return Math.sqrt(t.x * t.x + t.y * t.y); }; }, function (t, e, i) { const n = i(16); const s = i(39); const r = i(81); t.exports = function (t) { const e = r(t) - n.TAU; return s(e, -Math.PI, Math.PI); }; }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = []), e.push({ x: t.x1, y: t.y1 }), e.push({ x: t.x2, y: t.y2 }), e.push({ x: t.x3, y: t.y3 }), e; }; }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = []), e.push({ x: t.x, y: t.y }), e.push({ x: t.right, y: t.y }), e.push({ x: t.right, y: t.bottom }), e.push({ x: t.x, y: t.bottom }), e; }; }, function (t, e) { t.exports = function (t, e) { return (t.x - e.x1) * (e.y2 - e.y1) == (e.x2 - e.x1) * (t.y - e.y1); }; }, function (t, e, i) { const n = i(32); const s = new (i(5))(); t.exports = function (t, e, i) { if (void 0 === i && (i = s), n(e, t.x1, t.y1)) return i.x = t.x1, i.y = t.y1, !0; if (n(e, t.x2, t.y2)) return i.x = t.x2, i.y = t.y2, !0; const r = t.x2 - t.x1; const o = t.y2 - t.y1; const a = e.x - t.x1; const h = e.y - t.y1; const l = r * r + o * o; let u = r; let c = o; if (l > 0) { const d = (a * r + h * o) / l; u *= d, c *= d; } return i.x = t.x1 + u, i.y = t.y1 + c, u * u + c * c <= l && u * r + c * o >= 0 && n(e, i.x, i.y); }; }, function (t, e) { t.exports = function (t, e) { return !(t.width <= 0 || t.height <= 0 || e.width <= 0 || e.height <= 0 || t.right < e.x || t.bottom < e.y || t.x > e.right || t.y > e.bottom); }; }, function (t, e, i) {
  t.exports = {
    CircleToCircle: i(842), CircleToRectangle: i(841), GetRectangleIntersection: i(840), LineToCircle: i(384), LineToLine: i(143), LineToRectangle: i(839), PointToLine: i(383), PointToLineSegment: i(838), RectangleToRectangle: i(385), RectangleToTriangle: i(837), RectangleToValues: i(836), TriangleToCircle: i(835), TriangleToLine: i(834), TriangleToTriangle: i(833),
  };
}, function (t, e, i) {
  t.exports = {
    Circle: i(852), Ellipse: i(248), Intersects: i(386), Line: i(832), Point: i(814), Polygon: i(800), Rectangle: i(376), Triangle: i(772),
  };
}, function (t, e, i) {
  const n = i(0); const s = i(389); const r = i(147); const o = i(27); const a = new n({
    initialize() { this.lightPool = [], this.lights = [], this.culledLights = [], this.ambientColor = { r: 0.1, g: 0.1, b: 0.1 }, this.active = !1; }, enable() { return this.active = !0, this; }, disable() { return this.active = !1, this; }, cull(t) { const e = this.lights; const i = this.culledLights; const n = e.length; const s = t.x + t.width / 2; const o = t.y + t.height / 2; const a = (t.width + t.height) / 2; const h = { x: 0, y: 0 }; const l = t.matrix; const u = this.systems.game.config.height; i.length = 0; for (let c = 0; c < n && i.length < r.LIGHT_COUNT; ++c) { const d = e[c]; l.transformPoint(d.x, d.y, h); const f = s - (h.x - t.scrollX * d.scrollFactorX * t.zoom); const p = o - (u - (h.y - t.scrollY * d.scrollFactorY * t.zoom)); Math.sqrt(f * f + p * p) < d.radius + a && i.push(e[c]); } return i; }, forEachLight(t) { if (t) { for (let e = this.lights, i = e.length, n = 0; n < i; ++n)t(e[n]); return this; } }, setAmbientColor(t) { const e = o.getFloatsFromUintRGB(t); return this.ambientColor.r = e[0], this.ambientColor.g = e[1], this.ambientColor.b = e[2], this; }, getMaxVisibleLights() { return 10; }, getLightCount() { return this.lights.length; }, addLight(t, e, i, n, r) { let a; let h = null; return t = void 0 === t ? 0 : t, e = void 0 === e ? 0 : e, n = void 0 === n ? 16777215 : n, i = void 0 === i ? 100 : i, r = void 0 === r ? 1 : r, a = o.getFloatsFromUintRGB(n), h = null, this.lightPool.length > 0 ? (h = this.lightPool.pop()).set(t, e, i, a[0], a[1], a[2], r) : h = new s(t, e, i, a[0], a[1], a[2], r), this.lights.push(h), h; }, removeLight(t) { const e = this.lights.indexOf(t); return e >= 0 && (this.lightPool.push(t), this.lights.splice(e, 1)), this; }, shutdown() { for (;this.lights.length > 0;) this.lightPool.push(this.lights.pop()); this.ambientColor = { r: 0.1, g: 0.1, b: 0.1 }, this.culledLights.length = 0, this.lights.length = 0; }, destroy() { this.shutdown(); },
  }); t.exports = a;
}, function (t, e, i) {
  const n = i(0); const s = i(27); const r = new n({
    initialize(t, e, i, n, s, r, o) { this.x = t, this.y = e, this.radius = i, this.r = n, this.g = s, this.b = r, this.intensity = o, this.scrollFactorX = 1, this.scrollFactorY = 1; }, set(t, e, i, n, s, r, o) { return this.x = t, this.y = e, this.radius = i, this.r = n, this.g = s, this.b = r, this.intensity = o, this.scrollFactorX = 1, this.scrollFactorY = 1, this; }, setScrollFactor(t, e) { return void 0 === t && (t = 1), void 0 === e && (e = t), this.scrollFactorX = t, this.scrollFactorY = e, this; }, setColor(t) { const e = s.getFloatsFromUintRGB(t); return this.r = e[0], this.g = e[1], this.b = e[2], this; }, setIntensity(t) { return this.intensity = t, this; }, setPosition(t, e) { return this.x = t, this.y = e, this; }, setRadius(t) { return this.radius = t, this; },
  }); t.exports = r;
}, function (t, e, i) { const n = i(24); const s = i(13); const r = i(10); const o = i(107); s.register('text', function (t, e) { void 0 === t && (t = {}); const i = r(t, 'text', ''); const s = r(t, 'style', null); const a = r(t, 'padding', null); a !== null && (s.padding = a); const h = new o(this.scene, 0, 0, i, s); return void 0 !== e && (t.add = e), n(this.scene, h, t), h.autoRound = r(t, 'autoRound', !0), h.resolution = r(t, 'resolution', 1), h; }); }, function (t, e, i) { const n = i(24); const s = i(124); const r = i(13); const o = i(10); const a = i(34); r.register('sprite', function (t, e) { void 0 === t && (t = {}); const i = o(t, 'key', null); const r = o(t, 'frame', null); const h = new a(this.scene, 0, 0, i, r); return void 0 !== e && (t.add = e), n(this.scene, h, t), s(h, t), h; }); }, function (t, e, i) { const n = i(24); const s = i(13); const r = i(10); const o = i(69); s.register('image', function (t, e) { void 0 === t && (t = {}); const i = r(t, 'key', null); const s = r(t, 'frame', null); const a = new o(this.scene, 0, 0, i, s); return void 0 !== e && (t.add = e), n(this.scene, a, t), a; }); }, function (t, e, i) { const n = i(13); const s = i(112); n.register('graphics', function (t, e) { void 0 === t && (t = {}), void 0 !== e && (t.add = e); const i = new s(this.scene, t); return t.add && this.scene.sys.displayList.add(i), i; }); }, function (t, e, i) { const n = i(107); i(11).register('text', function (t, e, i, s) { return this.displayList.add(new n(this.scene, t, e, i, s)); }); }, function (t, e, i) { const n = i(11); const s = i(34); n.register('sprite', function (t, e, i, n) { const r = new s(this.scene, t, e, i, n); return this.displayList.add(r), this.updateList.add(r), r; }); }, function (t, e, i) { const n = i(69); i(11).register('image', function (t, e, i, s) { return this.displayList.add(new n(this.scene, t, e, i, s)); }); }, function (t, e, i) { const n = i(112); i(11).register('graphics', function (t) { return this.displayList.add(new n(this.scene, t)); }); }, function (t, e) { t.exports = function (t) { const e = Math.log(t) / 0.6931471805599453; return 1 << Math.ceil(e); }; }, function (t, e, i) { const n = i(22); t.exports = function (t) { const e = n.create(this); const i = e.getContext('2d'); t.syncFont(e, i); const s = Math.ceil(i.measureText(t.testString).width * t.baselineX); let r = s; const o = 2 * r; r = r * t.baselineY | 0, e.width = s, e.height = o, i.fillStyle = '#f00', i.fillRect(0, 0, s, o), i.font = t._font, i.textBaseline = 'alphabetic', i.fillStyle = '#000', i.fillText(t.testString, 0, r); const a = { ascent: 0, descent: 0, fontSize: 0 }; if (!i.getImageData(0, 0, s, o)) return a.ascent = r, a.descent = r + 6, a.fontSize = a.ascent + a.descent, n.remove(e), a; let h; let l; const u = i.getImageData(0, 0, s, o).data; const c = u.length; const d = 4 * s; let f = 0; let p = !1; for (h = 0; h < r; h++) { for (l = 0; l < d; l += 4) if (u[f + l] !== 255) { p = !0; break; } if (p) break; f += d; } for (a.ascent = r - h, f = c - d, p = !1, h = o; h > r; h--) { for (l = 0; l < d; l += 4) if (u[f + l] !== 255) { p = !0; break; } if (p) break; f -= d; } return a.descent = h - r, a.fontSize = a.ascent + a.descent, n.remove(e), a; }; }, function (t, e, i) {
  const n = i(0); const s = i(10); const r = i(4); const o = i(399); const a = {
    fontFamily: ['fontFamily', 'Courier'], fontSize: ['fontSize', '16px'], fontStyle: ['fontStyle', ''], backgroundColor: ['backgroundColor', null], color: ['color', '#fff'], stroke: ['stroke', '#fff'], strokeThickness: ['strokeThickness', 0], shadowOffsetX: ['shadow.offsetX', 0], shadowOffsetY: ['shadow.offsetY', 0], shadowColor: ['shadow.color', '#000'], shadowBlur: ['shadow.blur', 0], shadowStroke: ['shadow.stroke', !1], shadowFill: ['shadow.fill', !1], align: ['align', 'left'], maxLines: ['maxLines', 0], fixedWidth: ['fixedWidth', 0], fixedHeight: ['fixedHeight', 0], rtl: ['rtl', !1], testString: ['testString', '|Mqgy'], baselineX: ['baselineX', 1.2], baselineY: ['baselineY', 1.4], wordWrapWidth: ['wordWrap.width', null], wordWrapCallback: ['wordWrap.callback', null], wordWrapCallbackScope: ['wordWrap.callbackScope', null], wordWrapUseAdvanced: ['wordWrap.useAdvancedWrap', !1],
  }; const h = new n({
    initialize(t, e) { this.parent = t, this.fontFamily, this.fontSize, this.fontStyle, this.backgroundColor, this.color, this.stroke, this.strokeThickness, this.shadowOffsetX, this.shadowOffsetY, this.shadowColor, this.shadowBlur, this.shadowStroke, this.shadowFill, this.align, this.maxLines, this.fixedWidth, this.fixedHeight, this.rtl, this.testString, this.baselineX, this.baselineY, this._font, this.setStyle(e, !1); const i = r(e, 'metrics', !1); this.metrics = i ? { ascent: r(i, 'ascent', 0), descent: r(i, 'descent', 0), fontSize: r(i, 'fontSize', 0) } : o(this); }, setStyle(t, e) { for (const i in void 0 === e && (e = !0), t && t.hasOwnProperty('fontSize') && typeof t.fontSize === 'number' && (t.fontSize = `${t.fontSize.toString()}px`), a) this[i] = i === 'wordWrapCallback' || i === 'wordWrapCallbackScope' ? r(t, a[i][0], a[i][1]) : s(t, a[i][0], a[i][1]); const n = r(t, 'font', null); this._font = n === null ? [this.fontStyle, this.fontSize, this.fontFamily].join(' ') : n; const o = r(t, 'fill', null); return o !== null && (this.color = o), e ? this.update(!0) : this.parent; }, syncFont(t, e) { e.font = this._font; }, syncStyle(t, e) { e.textBaseline = 'alphabetic', e.fillStyle = this.color, e.strokeStyle = this.stroke, e.lineWidth = this.strokeThickness, e.lineCap = 'round', e.lineJoin = 'round'; }, syncShadow(t, e) { e ? (t.shadowOffsetX = this.shadowOffsetX, t.shadowOffsetY = this.shadowOffsetY, t.shadowColor = this.shadowColor, t.shadowBlur = this.shadowBlur) : (t.shadowOffsetX = 0, t.shadowOffsetY = 0, t.shadowColor = 0, t.shadowBlur = 0); }, update(t) { return t && (this._font = [this.fontStyle, this.fontSize, this.fontFamily].join(' '), this.metrics = o(this)), this.parent.updateText(); }, setFont(t) { return typeof t === 'string' ? (this.fontFamily = t, this.fontSize = '', this.fontStyle = '') : (this.fontFamily = r(t, 'fontFamily', 'Courier'), this.fontSize = r(t, 'fontSize', '16px'), this.fontStyle = r(t, 'fontStyle', '')), this.update(!0); }, setFontFamily(t) { return this.fontFamily = t, this.update(!0); }, setFontStyle(t) { return this.fontStyle = t, this.update(!0); }, setFontSize(t) { return typeof t === 'number' && (t = `${t.toString()}px`), this.fontSize = t, this.update(!0); }, setTestString(t) { return this.testString = t, this.update(!0); }, setFixedSize(t, e) { return this.fixedWidth = t, this.fixedHeight = e, t && (this.parent.width = t), e && (this.parent.height = e), this.update(!1); }, setBackgroundColor(t) { return this.backgroundColor = t, this.update(!1); }, setFill(t) { return this.color = t, this.update(!1); }, setColor(t) { return this.color = t, this.update(!1); }, setStroke(t, e) { return void 0 === t ? this.strokeThickness = 0 : (void 0 === e && (e = this.strokeThickness), this.stroke = t, this.strokeThickness = e), this.update(!0); }, setShadow(t, e, i, n, s, r) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = '#000'), void 0 === n && (n = 0), void 0 === s && (s = !1), void 0 === r && (r = !0), this.shadowOffsetX = t, this.shadowOffsetY = e, this.shadowColor = i, this.shadowBlur = n, this.shadowStroke = s, this.shadowFill = r, this.update(!1); }, setShadowOffset(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.shadowOffsetX = t, this.shadowOffsetY = e, this.update(!1); }, setShadowColor(t) { return void 0 === t && (t = '#000'), this.shadowColor = t, this.update(!1); }, setShadowBlur(t) { return void 0 === t && (t = 0), this.shadowBlur = t, this.update(!1); }, setShadowStroke(t) { return this.shadowStroke = t, this.update(!1); }, setShadowFill(t) { return this.shadowFill = t, this.update(!1); }, setWordWrapWidth(t, e) { return void 0 === e && (e = !1), this.wordWrapWidth = t, this.wordWrapUseAdvanced = e, this.update(!1); }, setWordWrapCallback(t, e) { return void 0 === e && (e = null), this.wordWrapCallback = t, this.wordWrapCallbackScope = e, this.update(!1); }, setAlign(t) { return void 0 === t && (t = 'left'), this.align = t, this.update(!1); }, setMaxLines(t) { return void 0 === t && (t = 0), this.maxLines = t, this.update(!1); }, getTextMetrics() { const t = this.metrics; return { ascent: t.ascent, descent: t.descent, fontSize: t.fontSize }; }, toJSON() { const t = {}; for (const e in a)t[e] = this[e]; return t.metrics = this.getTextMetrics(), t; }, destroy() { this.parent = void 0; },
  }); t.exports = h;
}, function (t, e, i) { const n = i(2); t.exports = function (t, e, i, s, r) { if (!(n.RENDER_MASK !== e.renderFlags || e.cameraFilter > 0 && e.cameraFilter & s._id || e.text === '')) { const o = t.currentContext; t.currentBlendMode !== e.blendMode && (t.currentBlendMode = e.blendMode, o.globalCompositeOperation = t.blendModes[e.blendMode]), t.currentAlpha !== e.alpha && (t.currentAlpha = e.alpha, o.globalAlpha = e.alpha), t.currentScaleMode !== e.scaleMode && (t.currentScaleMode = e.scaleMode); const a = e.canvas; if (o.save(), void 0 !== r) { const h = r.matrix; o.transform(h[0], h[1], h[2], h[3], h[4], h[5]); } let l = e.x - s.scrollX * e.scrollFactorX; let u = e.y - s.scrollY * e.scrollFactorY; t.config.roundPixels && (l |= 0, u |= 0), o.translate(l, u), o.rotate(e.rotation), o.scale(e.scaleX, e.scaleY), o.translate(a.width * (e.flipX ? 1 : 0), a.height * (e.flipY ? 1 : 0)), o.scale(e.flipX ? -1 : 1, e.flipY ? -1 : 1), o.drawImage(a, 0, 0, a.width, a.height, -e.displayOriginX, -e.displayOriginY, a.width, a.height), o.restore(); } }; }, function (t, e, i) { const n = i(2); t.exports = function (t, e, i, s, r) { n.RENDER_MASK !== e.renderFlags || e.cameraFilter > 0 && e.cameraFilter & s._id || e.text === '' || (e.dirty && (e.canvasTexture = t.canvasToTexture(e.canvas, e.canvasTexture), e.dirty = !1), this.pipeline.batchText(this, s, r)); }; }, function (t, e, i) { let n = i(3); let s = i(3); n = i(402), s = i(401), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e) {
  t.exports = function (t, e, i) {
    const n = t.canvas; const s = t.context; const r = t.style; const o = []; let a = 0; let h = i.length; r.maxLines > 0 && r.maxLines < i.length && (h = r.maxLines), r.syncFont(n, s); for (let l = 0; l < h; l++) { let u = r.strokeThickness; u += s.measureText(i[l]).width, r.wordWrap && (u -= s.measureText(' ').width), o[l] = Math.ceil(u), a = Math.max(a, o[l]); } const c = e.fontSize + r.strokeThickness; let d = c * h; let f = t._lineSpacing || 0; return f < 0 && Math.abs(f) > c && (f = -c), f !== 0 && (d += f > 0 ? f * i.length : f * (i.length - 1)), {
      width: a, height: d, lines: h, lineWidths: o, lineSpacing: f, lineHeight: c,
    };
  };
}, function (t, e, i) {
  const n = i(0); const s = i(38); const r = i(61); const o = i(4); const a = i(34); const h = i(60); const l = i(7); const u = new n({
    Extends: a, initialize(t, e, i, n, s, r) { a.call(this, t, i, n, s, r), this.path = e, this.rotateToPath = !1, this.pathRotationVerticalAdjust = !1, this.pathRotationOffset = 0, this.pathOffset = new l(i, n), this.pathVector = new l(), this.pathTween, this.pathConfig = null, this._prevDirection = h.PLAYING_FORWARD; }, setPath(t, e) { void 0 === e && (e = this.pathConfig); const i = this.pathTween; return i && i.isPlaying() && i.stop(), this.path = t, e && this.startFollow(e), this; }, setRotateToPath(t, e, i) { return void 0 === e && (e = 0), void 0 === i && (i = !1), this.rotateToPath = t, this.pathRotationOffset = e, this.pathRotationVerticalAdjust = i, this; }, isFollowing() { const t = this.pathTween; return t && t.isPlaying(); }, startFollow(t, e) { void 0 === t && (t = {}), void 0 === e && (e = 0); const i = this.pathTween; i && i.isPlaying() && i.stop(), typeof t === 'number' && (t = { duration: t }), t.from = 0, t.to = 1; const n = r(t, 'positionOnPath', !1); if (this.rotateToPath = r(t, 'rotateToPath', !1), this.pathRotationOffset = o(t, 'rotationOffset', 0), this.pathRotationVerticalAdjust = r(t, 'verticalAdjust', !1), this.pathTween = this.scene.sys.tweens.addCounter(t), this.path.getStartPoint(this.pathOffset), n && (this.x = this.pathOffset.x, this.y = this.pathOffset.y), this.pathOffset.x = this.x - this.pathOffset.x, this.pathOffset.y = this.y - this.pathOffset.y, this._prevDirection = h.PLAYING_FORWARD, this.rotateToPath) { const a = this.path.getPoint(0.1); this.rotation = Math.atan2(a.y - this.y, a.x - this.x) + s(this.pathRotationOffset); } return this.pathConfig = t, this; }, pauseFollow() { const t = this.pathTween; return t && t.isPlaying() && t.pause(), this; }, resumeFollow() { const t = this.pathTween; return t && t.isPaused() && t.resume(), this; }, stopFollow() { const t = this.pathTween; return t && t.isPlaying() && t.stop(), this; }, preUpdate(t, e) { this.anims.update(t, e); const i = this.pathTween; if (i) { const n = i.data[0]; if (n.state !== h.PLAYING_FORWARD && n.state !== h.PLAYING_BACKWARD) return; const r = this.pathVector; this.path.getPoint(i.getValue(), r), r.add(this.pathOffset); const o = this.x; const a = this.y; this.setPosition(r.x, r.y); const l = this.x - o; const u = this.y - a; if (l === 0 && u === 0) return; if (n.state !== this._prevDirection) return void (this._prevDirection = n.state); this.rotateToPath && (this.rotation = Math.atan2(u, l) + s(this.pathRotationOffset), this.pathRotationVerticalAdjust && (this.flipY = this.rotation !== 0 && n.state === h.PLAYING_BACKWARD)); } },
  }); t.exports = u;
}, function (t, e, i) { const n = i(0); const s = i(7); const r = new n({ initialize(t) { this.source = t, this._tempVec = new s(); }, getPoint(t) { const e = this._tempVec; this.source.getRandomPoint(e), t.x = e.x, t.y = e.y; } }); t.exports = r; }, function (t, e) { t.exports = function (t, e) { for (let i = 0; i < e.length; i++) if (t.hasOwnProperty(e[i])) return !0; return !1; }; }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = 1), t <= 0 ? 0 : t >= 1 ? 1 : 1 / e * (1 + (e * t | 0)); }; }, function (t, e) { t.exports = function (t) { return t === 0 ? 0 : t === 1 ? 1 : 0.5 * (1 - Math.cos(Math.PI * t)); }; }, function (t, e) { t.exports = function (t) { return t === 0 ? 0 : t === 1 ? 1 : Math.sin(t * Math.PI / 2); }; }, function (t, e) { t.exports = function (t) { return t === 0 ? 0 : t === 1 ? 1 : 1 - Math.cos(t * Math.PI / 2); }; }, function (t, e) { t.exports = function (t) { return (t *= 2) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2); }; }, function (t, e) { t.exports = function (t) { return --t * t * t * t * t + 1; }; }, function (t, e) { t.exports = function (t) { return t * t * t * t * t; }; }, function (t, e) { t.exports = function (t) { return (t *= 2) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2); }; }, function (t, e) { t.exports = function (t) { return 1 - --t * t * t * t; }; }, function (t, e) { t.exports = function (t) { return t * t * t * t; }; }, function (t, e) { t.exports = function (t) { return (t *= 2) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1); }; }, function (t, e) { t.exports = function (t) { return t * (2 - t); }; }, function (t, e) { t.exports = function (t) { return t * t; }; }, function (t, e) { t.exports = function (t) { return t; }; }, function (t, e) { t.exports = function (t) { return (t *= 2) < 1 ? 0.5 * Math.pow(2, 10 * (t - 1)) : 0.5 * (2 - Math.pow(2, -10 * (t - 1))); }; }, function (t, e) { t.exports = function (t) { return 1 - Math.pow(2, -10 * t); }; }, function (t, e) { t.exports = function (t) { return Math.pow(2, 10 * (t - 1)) - 0.001; }; }, function (t, e) { t.exports = function (t, e, i) { if (void 0 === e && (e = 0.1), void 0 === i && (i = 0.1), t === 0) return 0; if (t === 1) return 1; let n = i / 4; return e < 1 ? e = 1 : n = i * Math.asin(1 / e) / (2 * Math.PI), (t *= 2) < 1 ? e * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - n) * (2 * Math.PI) / i) * -0.5 : e * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - n) * (2 * Math.PI) / i) * 0.5 + 1; }; }, function (t, e) { t.exports = function (t, e, i) { if (void 0 === e && (e = 0.1), void 0 === i && (i = 0.1), t === 0) return 0; if (t === 1) return 1; let n = i / 4; return e < 1 ? e = 1 : n = i * Math.asin(1 / e) / (2 * Math.PI), e * Math.pow(2, -10 * t) * Math.sin((t - n) * (2 * Math.PI) / i) + 1; }; }, function (t, e) { t.exports = function (t, e, i) { if (void 0 === e && (e = 0.1), void 0 === i && (i = 0.1), t === 0) return 0; if (t === 1) return 1; let n = i / 4; return e < 1 ? e = 1 : n = i * Math.asin(1 / e) / (2 * Math.PI), -e * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - n) * (2 * Math.PI) / i); }; }, function (t, e) { t.exports = function (t) { return (t *= 2) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2); }; }, function (t, e) { t.exports = function (t) { return --t * t * t + 1; }; }, function (t, e) { t.exports = function (t) { return t * t * t; }; }, function (t, e) { t.exports = function (t) { return (t *= 2) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1); }; }, function (t, e) { t.exports = function (t) { return Math.sqrt(1 - --t * t); }; }, function (t, e) { t.exports = function (t) { return 1 - Math.sqrt(1 - t * t); }; }, function (t, e) { t.exports = function (t) { let e = !1; return t < 0.5 ? (t = 1 - 2 * t, e = !0) : t = 2 * t - 1, t < 1 / 2.75 ? t *= 7.5625 * t : t = t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375, e ? 0.5 * (1 - t) : 0.5 * t + 0.5; }; }, function (t, e) { t.exports = function (t) { return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375; }; }, function (t, e) { t.exports = function (t) { return (t = 1 - t) < 1 / 2.75 ? 1 - 7.5625 * t * t : t < 2 / 2.75 ? 1 - (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) : t < 2.5 / 2.75 ? 1 - (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) : 1 - (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375); }; }, function (t, e) { t.exports = function (t, e) { void 0 === e && (e = 1.70158); const i = 1.525 * e; return (t *= 2) < 1 ? t * t * ((i + 1) * t - i) * 0.5 : 0.5 * ((t -= 2) * t * ((i + 1) * t + i) + 2); }; }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = 1.70158), --t * t * ((e + 1) * t + e) + 1; }; }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = 1.70158), t * t * ((e + 1) * t - e); }; }, function (t, e, i) {
  const n = i(246); const s = i(245); const r = i(244); const o = i(243); const a = i(242); const h = i(241); const l = i(240); const u = i(239); const c = i(238); const d = i(237); const f = i(236); const p = i(235); t.exports = {
    Power0: l, Power1: u.Out, Power2: o.Out, Power3: c.Out, Power4: d.Out, Linear: l, Quad: u.Out, Cubic: o.Out, Quart: c.Out, Quint: d.Out, Sine: f.Out, Expo: h.Out, Circ: r.Out, Elastic: a.Out, Back: n.Out, Bounce: s.Out, Stepped: p, 'Quad.easeIn': u.In, 'Cubic.easeIn': o.In, 'Quart.easeIn': c.In, 'Quint.easeIn': d.In, 'Sine.easeIn': f.In, 'Expo.easeIn': h.In, 'Circ.easeIn': r.In, 'Elastic.easeIn': a.In, 'Back.easeIn': n.In, 'Bounce.easeIn': s.In, 'Quad.easeOut': u.Out, 'Cubic.easeOut': o.Out, 'Quart.easeOut': c.Out, 'Quint.easeOut': d.Out, 'Sine.easeOut': f.Out, 'Expo.easeOut': h.Out, 'Circ.easeOut': r.Out, 'Elastic.easeOut': a.Out, 'Back.easeOut': n.Out, 'Bounce.easeOut': s.Out, 'Quad.easeInOut': u.InOut, 'Cubic.easeInOut': o.InOut, 'Quart.easeInOut': c.InOut, 'Quint.easeInOut': d.InOut, 'Sine.easeInOut': f.InOut, 'Expo.easeInOut': h.InOut, 'Circ.easeInOut': r.InOut, 'Elastic.easeInOut': a.InOut, 'Back.easeInOut': n.InOut, 'Bounce.easeInOut': s.InOut,
  };
}, function (t, e, i) {
  const n = new (i(0))({
    initialize(t, e, i, n, s) { void 0 === n && (n = !1), void 0 === s && (s = !0), this.source = t, this.points = [], this.quantity = e, this.stepRate = i, this.yoyo = n, this.counter = -1, this.seamless = s, this._length = 0, this._direction = 0, this.updateSource(); }, updateSource() { if (this.points = this.source.getPoints(this.quantity, this.stepRate), this.seamless) { const t = this.points[0]; const e = this.points[this.points.length - 1]; t.x === e.x && t.y === e.y && this.points.pop(); } const i = this._length; return this._length = this.points.length, this._length < i && this.counter > this._length && (this.counter = this._length - 1), this; }, changeSource(t) { return this.source = t, this.updateSource(); }, getPoint(t) { this._direction === 0 ? (this.counter++, this.counter >= this._length && (this.yoyo ? (this._direction = 1, this.counter = this._length - 1) : this.counter = 0)) : (this.counter--, this.counter === -1 && (this.yoyo ? (this._direction = 0, this.counter = 0) : this.counter = this._length - 1)); const e = this.points[this.counter]; e && (t.x = e.x, t.y = e.y); },
  }); t.exports = n;
}, function (t, e, i) { const n = new (i(0))({ initialize(t, e) { this.source = t, this.killOnEnter = e; }, willKill(t) { const e = this.source.contains(t.x, t.y); return e && this.killOnEnter || !e && !this.killOnEnter; } }); t.exports = n; }, function (t, e, i) {
  const n = i(50); const s = i(0); const r = i(15); const o = i(442); const a = i(441); const h = i(897); const l = i(1); const u = i(145); const c = i(407); const d = i(108); const f = i(444); const p = i(406); const g = i(14); const v = i(82); const y = i(7); const m = i(39); const x = new s({
    Mixins: [r.BlendMode, r.Mask, r.ScrollFactor, r.Visible], initialize(t, e) { this.manager = t, this.texture = t.texture, this.frames = [t.defaultFrame], this.defaultFrame = t.defaultFrame, this.configFastMap = ['active', 'blendMode', 'collideBottom', 'collideLeft', 'collideRight', 'collideTop', 'deathCallback', 'deathCallbackScope', 'emitCallback', 'emitCallbackScope', 'follow', 'frequency', 'gravityX', 'gravityY', 'maxParticles', 'name', 'on', 'particleBringToTop', 'particleClass', 'radial', 'timeScale', 'trackVisible', 'visible'], this.configOpMap = ['accelerationX', 'accelerationY', 'angle', 'alpha', 'bounce', 'delay', 'lifespan', 'maxVelocityX', 'maxVelocityY', 'moveToX', 'moveToY', 'quantity', 'rotate', 'scaleX', 'scaleY', 'speedX', 'speedY', 'tint', 'x', 'y'], this.name = '', this.particleClass = f, this.x = new h(e, 'x', 0), this.y = new h(e, 'y', 0), this.radial = !0, this.gravityX = 0, this.gravityY = 0, this.acceleration = !1, this.accelerationX = new h(e, 'accelerationX', 0, !0), this.accelerationY = new h(e, 'accelerationY', 0, !0), this.maxVelocityX = new h(e, 'maxVelocityX', 1e4, !0), this.maxVelocityY = new h(e, 'maxVelocityY', 1e4, !0), this.speedX = new h(e, 'speedX', 0, !0), this.speedY = new h(e, 'speedY', 0, !0), this.moveTo = !1, this.moveToX = new h(e, 'moveToX', 0, !0), this.moveToY = new h(e, 'moveToY', 0, !0), this.bounce = new h(e, 'bounce', 0, !0), this.scaleX = new h(e, 'scaleX', 1), this.scaleY = new h(e, 'scaleY', 1), this.tint = new h(e, 'tint', 4294967295), this.alpha = new h(e, 'alpha', 1), this.lifespan = new h(e, 'lifespan', 1e3), this.angle = new h(e, 'angle', { min: 0, max: 360 }), this.rotate = new h(e, 'rotate', 0), this.emitCallback = null, this.emitCallbackScope = null, this.deathCallback = null, this.deathCallbackScope = null, this.maxParticles = 0, this.quantity = new h(e, 'quantity', 1, !0), this.delay = new h(e, 'delay', 0, !0), this.frequency = 0, this.on = !0, this.particleBringToTop = !0, this.timeScale = 1, this.emitZone = null, this.deathZone = null, this.bounds = null, this.collideLeft = !0, this.collideRight = !0, this.collideTop = !0, this.collideBottom = !0, this.active = !0, this.visible = !0, this.blendMode = n.NORMAL, this.follow = null, this.followOffset = new y(), this.trackVisible = !1, this.currentFrame = 0, this.randomFrame = !0, this.frameQuantity = 1, this.dead = [], this.alive = [], this._counter = 0, this._frameCounter = 0, e && this.fromJSON(e); }, fromJSON(t) { if (!t) return this; let e = 0; let i = ''; for (e = 0; e < this.configFastMap.length; e++)i = this.configFastMap[e], d(t, i) && (this[i] = l(t, i)); for (e = 0; e < this.configOpMap.length; e++)i = this.configOpMap[e], d(t, i) && this[i].loadConfig(t); if (this.acceleration = this.accelerationX.propertyValue !== 0 || this.accelerationY.propertyValue !== 0, this.moveTo = this.moveToX.propertyValue !== 0 || this.moveToY.propertyValue !== 0, d(t, 'speed') && (this.speedX.loadConfig(t, 'speed'), this.speedY = null), (c(t, ['speedX', 'speedY']) || this.moveTo) && (this.radial = !1), d(t, 'scale') && (this.scaleX.loadConfig(t, 'scale'), this.scaleY = null), d(t, 'callbackScope')) { const n = l(t, 'callbackScope', null); this.emitCallbackScope = n, this.deathCallbackScope = n; } return d(t, 'emitZone') && this.setEmitZone(t.emitZone), d(t, 'deathZone') && this.setDeathZone(t.deathZone), d(t, 'bounds') && this.setBounds(t.bounds), d(t, 'followOffset') && this.followOffset.setFromObject(l(t, 'followOffset', 0)), d(t, 'frame') && this.setFrame(t.frame), this; }, toJSON(t) { void 0 === t && (t = {}); let e = 0; let i = ''; for (e = 0; e < this.configFastMap.length; e++)t[i = this.configFastMap[e]] = this[i]; for (e = 0; e < this.configOpMap.length; e++) this[i = this.configOpMap[e]] && (t[i] = this[i].toJSON()); return this.speedY || (delete t.speedX, t.speed = this.speedX.toJSON()), this.scaleY || (delete t.scaleX, t.scale = this.scaleX.toJSON()), t; }, startFollow(t, e, i, n) { return void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = !1), this.follow = t, this.followOffset.set(e, i), this.trackVisible = n, this; }, stopFollow() { return this.follow = null, this.followOffset.set(0, 0), this.trackVisible = !1, this; }, getFrame() { if (this.frames.length === 1) return this.defaultFrame; if (this.randomFrame) return u(this.frames); const t = this.frames[this.currentFrame]; return this._frameCounter++, this._frameCounter === this.frameQuantity && (this._frameCounter = 0, this.currentFrame = m(this.currentFrame + 1, 0, this._frameLength)), t; }, setFrame(t, e, i) { void 0 === e && (e = !0), void 0 === i && (i = 1), this.randomFrame = e, this.frameQuantity = i, this.currentFrame = 0, this._frameCounter = 0; const n = typeof t; if (Array.isArray(t) || n === 'string' || n === 'number') this.manager.setEmitterFrames(t, this); else if (n === 'object') { const s = t; (t = l(s, 'frames', null)) && this.manager.setEmitterFrames(t, this); const r = l(s, 'cycle', !1); this.randomFrame = !r, this.frameQuantity = l(s, 'quantity', i); } return this._frameLength = this.frames.length, this._frameLength === 1 && (this.frameQuantity = 1, this.randomFrame = !1), this; }, setRadial(t) { return void 0 === t && (t = !0), this.radial = t, this; }, setPosition(t, e) { return this.x.onChange(t), this.y.onChange(e), this; }, setBounds(t, e, i, n) { if (typeof t === 'object') { const s = t; t = s.x, e = s.y, i = d(s, 'w') ? s.w : s.width, n = d(s, 'h') ? s.h : s.height; } return this.bounds ? this.bounds.setTo(t, e, i, n) : this.bounds = new g(t, e, i, n), this; }, setSpeedX(t) { return this.speedX.onChange(t), this.radial = !1, this; }, setSpeedY(t) { return this.speedY && (this.speedY.onChange(t), this.radial = !1), this; }, setSpeed(t) { return this.speedX.onChange(t), this.speedY = null, this.radial = !0, this; }, setScaleX(t) { return this.scaleX.onChange(t), this; }, setScaleY(t) { return this.scaleY.onChange(t), this; }, setScale(t) { return this.scaleX.onChange(t), this.scaleY = null, this; }, setGravityX(t) { return this.gravityX = t, this; }, setGravityY(t) { return this.gravityY = t, this; }, setGravity(t, e) { return this.gravityX = t, this.gravityY = e, this; }, setAlpha(t) { return this.alpha.onChange(t), this; }, setEmitterAngle(t) { return this.angle.onChange(t), this; }, setAngle(t) { return this.angle.onChange(t), this; }, setLifespan(t) { return this.lifespan.onChange(t), this; }, setQuantity(t) { return this.quantity.onChange(t), this; }, setFrequency(t, e) { return this.frequency = t, this._counter = 0, e && this.quantity.onChange(e), this; }, setEmitZone(t) { if (void 0 === t) this.emitZone = null; else { const e = l(t, 'type', 'random'); const i = l(t, 'source', null); switch (e) { case 'random': this.emitZone = new p(i); break; case 'edge': var n = l(t, 'quantity', 1); var s = l(t, 'stepRate', 0); var r = l(t, 'yoyo', !1); var o = l(t, 'seamless', !0); this.emitZone = new a(i, n, s, r, o); } } return this; }, setDeathZone(t) { if (void 0 === t) this.deathZone = null; else { const e = l(t, 'type', 'onEnter'); const i = l(t, 'source', null); if (i && typeof i.contains === 'function') { const n = e === 'onEnter'; this.deathZone = new o(i, n); } } return this; }, reserve(t) { for (let e = this.dead, i = 0; i < t; i++)e.push(new this.particleClass(this)); return this; }, getAliveParticleCount() { return this.alive.length; }, getDeadParticleCount() { return this.dead.length; }, getParticleCount() { return this.getAliveParticleCount() + this.getDeadParticleCount(); }, atLimit() { return this.maxParticles > 0 && this.getParticleCount() === this.maxParticles; }, onParticleEmit(t, e) { return void 0 === t ? (this.emitCallback = null, this.emitCallbackScope = null) : typeof t === 'function' && (this.emitCallback = t, e && (this.emitCallbackScope = e)), this; }, onParticleDeath(t, e) { return void 0 === t ? (this.deathCallback = null, this.deathCallbackScope = null) : typeof t === 'function' && (this.deathCallback = t, e && (this.deathCallbackScope = e)), this; }, killAll() { for (let t = this.dead, e = this.alive; e.length > 0;)t.push(e.pop()); return this; }, forEachAlive(t, e) { for (let i = this.alive, n = i.length, s = 0; s < n; ++s)t.call(e, i[s], this); return this; }, forEachDead(t, e) { for (let i = this.dead, n = i.length, s = 0; s < n; ++s)t.call(e, i[s], this); return this; }, start() { return this.on = !0, this._counter = 0, this; }, pause() { return this.active = !1, this; }, resume() { return this.active = !0, this; }, depthSort() { return v.inplace(this.alive, this.depthSortCallback), this; }, flow(t, e) { return void 0 === e && (e = 1), this.frequency = t, this.quantity.onChange(e), this.start(); }, explode(t, e, i) { return this.frequency = -1, this.emitParticle(t, e, i); }, emitParticleAt(t, e, i) { return this.emitParticle(i, t, e); }, emitParticle(t, e, i) { if (!this.atLimit()) { void 0 === t && (t = this.quantity.onEmit()); for (let n = this.dead, s = 0; s < t; s++) { var r; if ((r = n.length > 0 ? n.pop() : new this.particleClass(this)).fire(e, i), this.particleBringToTop ? this.alive.push(r) : this.alive.unshift(r), this.emitCallback && this.emitCallback.call(this.emitCallbackScope, r, this), this.atLimit()) break; } return r; } }, preUpdate(t, e) { const i = (e *= this.timeScale) / 1e3; this.trackVisible && (this.visible = this.follow.visible); for (var n = this.manager.getProcessors(), s = this.alive, r = s.length, o = 0; o < r; o++) { const a = s[o]; if (a.update(e, i, n)) { const h = s[r - 1]; s[r - 1] = a, s[o] = h, o -= 1, r -= 1; } } const l = s.length - r; if (l > 0) { const u = s.splice(s.length - l, l); const c = this.deathCallback; const d = this.deathCallbackScope; if (c) for (let f = 0; f < u.length; f++)c.call(d, u[f]); this.dead.concat(u), v.inplace(s, this.indexSortCallback); } this.on && (this.frequency === 0 ? this.emitParticle() : this.frequency > 0 && (this._counter -= e, this._counter <= 0 && (this.emitParticle(), this._counter = this.frequency - Math.abs(this._counter)))); }, depthSortCallback(t, e) { return t.y - e.y; }, indexSortCallback(t, e) { return t.index - e.index; },
  }); t.exports = x;
}, function (t, e, i) {
  const n = i(0); const s = i(38); const r = i(57); const o = function (t) { return (t >> 16) + (65280 & t) + ((255 & t) << 16); }; const a = new n({
    initialize(t) {
      this.emitter = t, this.frame = null, this.index = 0, this.x = 0, this.y = 0, this.velocityX = 0, this.velocityY = 0, this.accelerationX = 0, this.accelerationY = 0, this.maxVelocityX = 1e4, this.maxVelocityY = 1e4, this.bounce = 0, this.scaleX = 1, this.scaleY = 1, this.alpha = 1, this.angle = 0, this.rotation = 0, this.tint = 16777215, this.color = 16777215, this.life = 1e3, this.lifeCurrent = 1e3, this.delayCurrent = 0, this.lifeT = 0, this.data = {
        tint: { min: 16777215, max: 16777215, current: 16777215 }, alpha: { min: 1, max: 1 }, rotate: { min: 0, max: 0 }, scaleX: { min: 1, max: 1 }, scaleY: { min: 1, max: 1 },
      };
    },
    isAlive() { return this.lifeCurrent > 0; },
    fire(t, e) { const i = this.emitter; this.frame = i.getFrame(), i.emitZone && i.emitZone.getPoint(this), void 0 === t ? (i.follow && (this.x += i.follow.x + i.followOffset.x), this.x += i.x.onEmit(this, 'x')) : this.x += t, void 0 === e ? (i.follow && (this.y += i.follow.y + i.followOffset.y), this.y += i.y.onEmit(this, 'y')) : this.y += e, this.life = i.lifespan.onEmit(this, 'lifespan'), this.lifeCurrent = this.life, this.lifeT = 0; const n = i.speedX.onEmit(this, 'speedX'); const a = i.speedY ? i.speedY.onEmit(this, 'speedY') : n; if (i.radial) { const h = s(i.angle.onEmit(this, 'angle')); this.velocityX = Math.cos(h) * Math.abs(n), this.velocityY = Math.sin(h) * Math.abs(a); } else if (i.moveTo) { const l = i.moveToX.onEmit(this, 'moveToX'); const u = i.moveToY ? i.moveToY.onEmit(this, 'moveToY') : l; const c = Math.atan2(u - this.y, l - this.x); const d = r(this.x, this.y, l, u) / (this.life / 1e3); this.velocityX = Math.cos(c) * d, this.velocityY = Math.sin(c) * d; } else this.velocityX = n, this.velocityY = a; i.acceleration && (this.accelerationX = i.accelerationX.onEmit(this, 'accelerationX'), this.accelerationY = i.accelerationY.onEmit(this, 'accelerationY')), this.maxVelocityX = i.maxVelocityX.onEmit(this, 'maxVelocityX'), this.maxVelocityY = i.maxVelocityY.onEmit(this, 'maxVelocityY'), this.delayCurrent = i.delay.onEmit(this, 'delay'), this.scaleX = i.scaleX.onEmit(this, 'scaleX'), this.scaleY = i.scaleY ? i.scaleY.onEmit(this, 'scaleY') : this.scaleX, this.angle = i.rotate.onEmit(this, 'rotate'), this.rotation = s(this.angle), this.bounce = i.bounce.onEmit(this, 'bounce'), this.alpha = i.alpha.onEmit(this, 'alpha'), this.tint = i.tint.onEmit(this, 'tint'); const f = 255 & (255 * this.alpha | 0); this.color = (f << 24 | o(this.tint)) >>> 0, this.index = i.alive.length; },
    computeVelocity(t, e, i, n) { let s = this.velocityX; let r = this.velocityY; const o = this.accelerationX; const a = this.accelerationY; const h = this.maxVelocityX; const l = this.maxVelocityY; s += t.gravityX * i, r += t.gravityY * i, o && (s += o * i), a && (r += a * i), s > h ? s = h : s < -h && (s = -h), r > l ? r = l : r < -l && (r = -l), this.velocityX = s, this.velocityY = r; for (let u = 0; u < n.length; u++)n[u].update(this, e, i); },
    checkBounds(t) { const e = t.bounds; const i = -this.bounce; this.x < e.x && t.collideLeft ? (this.x = e.x, this.velocityX *= i) : this.x > e.right && t.collideRight && (this.x = e.right, this.velocityX *= i), this.y < e.y && t.collideTop ? (this.y = e.y, this.velocityY *= i) : this.y > e.bottom && t.collideBottom && (this.y = e.bottom, this.velocityY *= i); },
    update(t, e, i) { if (this.delayCurrent > 0) return this.delayCurrent -= t, !1; const n = this.emitter; const r = 1 - this.lifeCurrent / this.life; if (this.lifeT = r, this.computeVelocity(n, t, e, i), this.x += this.velocityX * e, this.y += this.velocityY * e, n.bounds && this.checkBounds(n), n.deathZone && n.deathZone.willKill(this)) return this.lifeCurrent = 0, !0; this.scaleX = n.scaleX.onUpdate(this, 'scaleX', r, this.scaleX), n.scaleY ? this.scaleY = n.scaleY.onUpdate(this, 'scaleY', r, this.scaleY) : this.scaleY = this.scaleX, this.angle = n.rotate.onUpdate(this, 'rotate', r, this.angle), this.rotation = s(this.angle), this.alpha = n.alpha.onUpdate(this, 'alpha', r, this.alpha), this.tint = n.tint.onUpdate(this, 'tint', r, this.tint); const a = 255 & (255 * this.alpha | 0); return this.color = (a << 24 | o(this.tint)) >>> 0, this.lifeCurrent -= t, this.lifeCurrent <= 0; },
  }); t.exports = a;
}, function (t, e, i) {
  const n = i(0); const s = i(1); const r = new n({
    initialize(t, e, i, n, r) { if (typeof t === 'object') { const o = t; t = s(o, 'x', 0), e = s(o, 'y', 0), i = s(o, 'power', 0), n = s(o, 'epsilon', 100), r = s(o, 'gravity', 50); } else void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 100), void 0 === r && (r = 50); this.x = t, this.y = e, this.active = !0, this._gravity = r, this._power = 0, this._epsilon = 0, this.power = i, this.epsilon = n; }, update(t, e) { const i = this.x - t.x; const n = this.y - t.y; let s = i * i + n * n; if (s !== 0) { const r = Math.sqrt(s); s < this._epsilon && (s = this._epsilon); const o = this._power * e / (s * r) * 100; t.velocityX += i * o, t.velocityY += n * o; } }, epsilon: { get() { return Math.sqrt(this._epsilon); }, set(t) { this._epsilon = t * t; } }, power: { get() { return this._power / this._gravity; }, set(t) { this._power = t * this._gravity; } }, gravity: { get() { return this._gravity; }, set(t) { const e = this.power; this._gravity = t, this.power = e; } },
  }); t.exports = r;
}, function (t, e, i) { const n = i(2); t.exports = function (t, e, i, s, r) { n.RENDER_MASK !== e.renderFlags || e.cameraFilter > 0 && e.cameraFilter & s._id || t.drawImage(e, s, r); }; }, function (t, e, i) { const n = i(2); t.exports = function (t, e, i, s, r) { n.RENDER_MASK !== e.renderFlags || e.cameraFilter > 0 && e.cameraFilter & s._id || this.pipeline.batchSprite(e, s, r); }; }, function (t, e, i) { let n = i(3); let s = i(3); n = i(447), s = i(446), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const n = i(2); t.exports = function (t, e, i, s, r) { n.RENDER_MASK !== e.renderFlags || e.cameraFilter > 0 && e.cameraFilter & s._id || this.pipeline.batchGraphics(this, s, r); }; }, function (t, e, i) { let n = i(3); let s = i(3); n = i(449), s = i(168), s = i(168), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e) { t.exports = function (t, e) { return t.x += e.x, t.y += e.y, t; }; }, function (t, e) { t.exports = function (t, e, i) { return t.x += e, t.y += i, t; }; }, function (t, e, i) { const n = i(14); t.exports = function (t, e) { return void 0 === e && (e = new n()), e.x = t.left, e.y = t.top, e.width = t.width, e.height = t.height, e; }; }, function (t, e) { t.exports = function (t, e) { return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height; }; }, function (t, e) { t.exports = function (t, e) { return e.setTo(t.x, t.y, t.width, t.height); }; }, function (t, e, i) { const n = i(53); t.exports = function (t, e) { return n(t, e.x, e.y) && n(t, e.right, e.y) && n(t, e.x, e.bottom) && n(t, e.right, e.bottom); }; }, function (t, e, i) { const n = i(53); t.exports = function (t, e) { return n(t, e.x, e.y); }; }, function (t, e, i) { const n = i(111); t.exports = function (t) { return new n(t.x, t.y, t.width, t.height); }; }, function (t, e) { t.exports = function (t) { return t.isEmpty() ? 0 : t.getMajorRadius() * t.getMinorRadius() * Math.PI; }; }, function (t, e, i) { const n = i(14); t.exports = function (t, e, i) { void 0 === i && (i = new n()); const s = Math.min(t.x, e.x); const r = Math.min(t.y, e.y); const o = Math.max(t.right, e.right) - s; const a = Math.max(t.bottom, e.bottom) - r; return i.setTo(s, r, o, a); }; }, function (t, e) {
  function i(t, e) { return parseInt(t.getAttribute(e), 10); }t.exports = function (t, e, n, s) {
    void 0 === e && (e = 0), void 0 === n && (n = 0); const r = {}; const o = t.getElementsByTagName('info')[0]; const a = t.getElementsByTagName('common')[0]; r.font = o.getAttribute('face'), r.size = i(o, 'size'), r.lineHeight = i(a, 'lineHeight') + n, r.chars = {}; const h = t.getElementsByTagName('char'); const l = void 0 !== s && s.trimmed; if (l) {
      var u = s.height;
      var c = s.width;
    } for (var d = 0; d < h.length; d++) {
      const f = h[d]; const p = i(f, 'id'); const g = i(f, 'x'); const v = i(f, 'y'); const y = i(f, 'width'); const m = i(f, 'height'); l && (g < c && (c = g), v < u && (u = v)), r.chars[p] = {
        x: g, y: v, width: y, height: m, centerX: Math.floor(y / 2), centerY: Math.floor(m / 2), xOffset: i(f, 'xoffset'), yOffset: i(f, 'yoffset'), xAdvance: i(f, 'xadvance') + e, data: {}, kerning: {},
      };
    } if (l && u !== 0 && c !== 0) for (const x in r.chars) { const w = r.chars[x]; w.x -= s.x, w.y -= s.y; } const b = t.getElementsByTagName('kerning'); for (d = 0; d < b.length; d++) { const T = b[d]; const S = i(T, 'first'); const A = i(T, 'second'); const C = i(T, 'amount'); r.chars[A].kerning[S] = C; } return r;
  };
}, function (t, e) {
  t.exports = function (t, e) {
    for (var i = t.text, n = i.length, s = Number.MAX_VALUE, r = Number.MAX_VALUE, o = 0, a = 0, h = t.fontData.chars, l = t.fontData.lineHeight, u = t.letterSpacing, c = 0, d = 0, f = 0, p = 0, g = null, v = 0, y = 0, m = 0, x = 0, w = null, b = 0, T = 0; T < n; ++T) if ((p = i.charCodeAt(T)) !== 10) { if (g = h[p]) { if (v = g.width, y = g.height, m = f + g.xOffset + c, x = g.yOffset + d, w !== null) { const S = g.kerning[b]; m += void 0 !== S ? S : 0; }s > m && (s = m), r > x && (r = x); const A = m + v - s; const C = x + y - r; o < A && (o = A), a < C && (a = C), c += g.xAdvance + u, f += 1, w = g, b = p; } } else c = 0, f = 0, d += l, w = null; const M = t.fontSize / t.fontData.size; const _ = M * t.scaleX; const E = M * t.scaleY; const P = {
      local: {
        x: s * M, y: r * M, width: o * M, height: a * M,
      },
      global: {
        x: t.x + s * _, y: t.y + r * E, width: o * _, height: a * E,
      },
    }; return e && (P.local.x = Math.round(P.local.x), P.local.y = Math.round(P.local.y), P.local.width = Math.round(P.local.width), P.local.height = Math.round(P.local.height), P.global.x = Math.round(P.global.x), P.global.y = Math.round(P.global.y), P.global.width = Math.round(P.global.width), P.global.height = Math.round(P.global.height)), P;
  };
}, function (t, e, i) {
  const n = i(0); const s = i(12); const r = new n({
    initialize(t) { this.scene = t, this.systems = t.sys, this._list = [], this._pendingInsertion = [], this._pendingRemoval = [], t.sys.events.once('boot', this.boot, this), t.sys.events.on('start', this.start, this); }, boot() { this.systems.events.once('destroy', this.destroy, this); }, start() { const t = this.systems.events; t.on('preupdate', this.preUpdate, this), t.on('update', this.update, this), t.once('shutdown', this.shutdown, this); }, add(t) { return this._list.indexOf(t) === -1 && this._pendingInsertion.indexOf(t) === -1 && this._pendingInsertion.push(t), t; }, preUpdate() { const t = this._pendingRemoval.length; const e = this._pendingInsertion.length; if (t !== 0 || e !== 0) { let i; let n; for (i = 0; i < t; i++) { n = this._pendingRemoval[i]; const s = this._list.indexOf(n); s > -1 && this._list.splice(s, 1); } this._list = this._list.concat(this._pendingInsertion.splice(0)), this._pendingRemoval.length = 0, this._pendingInsertion.length = 0; } }, update(t, e) { for (let i = 0; i < this._list.length; i++) { const n = this._list[i]; n.active && n.preUpdate.call(n, t, e); } }, remove(t) { const e = this._list.indexOf(t); return e !== -1 && this._list.splice(e, 1), t; }, removeAll() { for (let t = this._list.length; t--;) this.remove(this._list[t]); return this; }, shutdown() { this.removeAll(), this._list.length = 0, this._pendingRemoval.length = 0, this._pendingInsertion.length = 0; const t = this.systems.events; t.off('preupdate', this.preUpdate, this), t.off('update', this.update, this), t.off('shutdown', this.shutdown, this); }, destroy() { this.shutdown(), this.scene.sys.events.off('start', this.start, this), this.scene = null, this.systems = null; },
  }); s.register('UpdateList', r, 'updateList'), t.exports = r;
}, function (t, e) { t.exports = function (t, e, i) { if (e !== i) { const n = t.indexOf(e); const s = t.indexOf(i); if (n < 0 || s < 0) throw new Error('Supplied items must be elements of the same array'); return t[n] = i, t[s] = e, t; } }; }, function (t, e, i) { const n = i(29); t.exports = function (t, e, i, s, r) { if (void 0 === s && (s = 0), void 0 === r && (r = t.length), n(t, s, r)) for (let o = s; o < r; o++) { const a = t[o]; a.hasOwnProperty(e) && (a[e] = i); } return t; }; }, function (t, e) { t.exports = function (t, e) { const i = t.indexOf(e); return i !== -1 && i > 0 && (t.splice(i, 1), t.unshift(e)), e; }; }, function (t, e) { t.exports = function (t, e, i) { const n = t.indexOf(e); const s = t.indexOf(i); return n !== -1 && s === -1 && (t[n] = i, !0); }; }, function (t, e, i) { const n = i(55); t.exports = function (t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = t.length); const s = e + Math.floor(Math.random() * i); return n(t, s); }; }, function (t, e, i) { const n = i(29); t.exports = function (t, e, i, s, r) { if (void 0 === e && (e = 0), void 0 === i && (i = t.length), void 0 === r && (r = t), n(t, e, i)) { const o = i - e; const a = t.splice(e, o); if (s) for (let h = 0; h < a.length; h++) { const l = a[h]; s.call(r, l); } return a; } return []; }; }, function (t, e, i) { const n = i(55); t.exports = function (t, e, i, s) { if (void 0 === s && (s = t), e < 0 || e > t.length - 1) throw new Error('Index out of bounds'); const r = n(t, e); return i && i.call(s, r), r; }; }, function (t, e, i) { const n = i(254); t.exports = function (t, e, i) { void 0 === t && (t = 0), void 0 === e && (e = null), void 0 === i && (i = 1), e === null && (e = t, t = 0); for (var s = [], r = Math.max(n((e - t) / (i || 1)), 0), o = 0; o < r; o++)s.push(t), t += i; return s; }; }, function (t, e) { t.exports = function (t, e, i, n) { for (var s = [], r = t; r <= e; r++) if (i || n) { let o = i ? i + r.toString() : r.toString(); n && (o = o.concat(n)), s.push(o); } else s.push(r); return s; }; }, function (t, e) { t.exports = function (t, e) { const i = t.indexOf(e); if (i !== -1 && i < t.length - 2) { const n = t[i + 1]; const s = t.indexOf(n); t[i] = n, t[s] = e; } return t; }; }, function (t, e) { t.exports = function (t, e, i) { const n = t.indexOf(e); if (n === -1 || i < 0 || i >= t.length) throw new Error('Supplied index out of bounds'); return n !== i && (t.splice(n, 1), t.splice(i, 0, e)), e; }; }, function (t, e) { t.exports = function (t, e) { const i = t.indexOf(e); if (i > 0) { const n = t[i - 1]; const s = t.indexOf(n); t[i] = n, t[s] = e; } return t; }; }, function (t, e, i) { const n = i(29); t.exports = function (t, e, i, s, r) { if (void 0 === s && (s = 0), void 0 === r && (r = t.length), n(t, s, r)) for (let o = s; o < r; o++) { const a = t[o]; if (!e || e && void 0 === i && a.hasOwnProperty(e) || e && void 0 !== i && a[e] === i) return a; } return null; }; }, function (t, e, i) { const n = i(29); t.exports = function (t, e, i, s, r) { void 0 === s && (s = 0), void 0 === r && (r = t.length); const o = []; if (n(t, s, r)) for (let a = s; a < r; a++) { const h = t[a]; (!e || e && void 0 === i && h.hasOwnProperty(e) || e && void 0 !== i && h[e] === i) && o.push(h); } return o; }; }, function (t, e, i) { const n = i(29); t.exports = function (t, e, i, s, r) { if (void 0 === s && (s = 0), void 0 === r && (r = t.length), n(t, s, r)) { let o; const a = [null]; for (o = 5; o < arguments.length; o++)a.push(arguments[o]); for (o = s; o < r; o++)a[0] = t[o], e.apply(i, a); } return t; }; }, function (t, e) { t.exports = function (t, e, i) { let n; const s = [null]; for (n = 2; n < arguments.length; n++)s.push(arguments[n]); for (n = 0; n < t.length; n++)s[0] = t[n], e.apply(i, s); return t; }; }, function (t, e, i) { const n = i(29); t.exports = function (t, e, i, s, r) { void 0 === s && (s = 0), void 0 === r && (r = t.length); let o = 0; if (n(t, s, r)) for (let a = s; a < r; a++)t[a][e] === i && o++; return o; }; }, function (t, e) { t.exports = function (t, e) { const i = t.indexOf(e); return i !== -1 && i < t.length && (t.splice(i, 1), t.push(e)), e; }; }, function (t, e) { t.exports = function (t, e, i, n, s, r) { if (void 0 === i && (i = 0), void 0 === r && (r = t), n > 0) { var o = n - t.length; if (o <= 0) return null; } if (!Array.isArray(e)) return t.indexOf(e) === -1 ? (t.splice(i, 0, e), s && s.call(r, e), e) : null; for (var a = e.length - 1; a >= 0;)t.indexOf(e[a]) !== -1 && e.pop(), a--; if ((a = e.length) === 0) return null; n > 0 && a > o && (e.splice(o), a = o); for (let h = a; h > 0; h--) { const l = e[h]; t.splice(i, 0, l), s && s.call(r, l); } return e; }; }, function (t, e) { t.exports = function (t, e, i, n, s) { if (void 0 === s && (s = t), i > 0) { var r = i - t.length; if (r <= 0) return null; } if (!Array.isArray(e)) return t.indexOf(e) === -1 ? (t.push(e), n && n.call(s, e), e) : null; for (var o = e.length - 1; o >= 0;)t.indexOf(e[o]) !== -1 && e.pop(), o--; if ((o = e.length) === 0) return null; i > 0 && o > r && (e.splice(r), o = r); for (let a = 0; a < o; a++) { const h = e[a]; t.push(h), n && n.call(s, h); } return e; }; }, function (t, e, i) { const n = i(75); t.exports = function (t) { return n(t, -90); }; }, function (t, e, i) { const n = i(75); t.exports = function (t) { return n(t, 90); }; }, function (t, e, i) { const n = i(75); t.exports = function (t) { return n(t, 180); }; }, function (t, e) { t.exports = function (t) { return t.reverse(); }; }, function (t, e) { t.exports = function (t) { for (let e = 0; e < t.length; e++)t[e].reverse(); return t; }; }, function (t, e, i) { const n = i(130); const s = i(113); t.exports = function (t) { let e = ''; if (!s(t)) return e; for (let i = 0; i < t.length; i++) { for (let r = 0; r < t[i].length; r++) { const o = t[i][r].toString(); e += o !== 'undefined' ? n(o, 2) : '?', r < t[i].length - 1 && (e += ' |'); } if (i < t.length - 1) { e += '\n'; for (let a = 0; a < t[i].length; a++)e += '---', a < t[i].length - 1 && (e += '+'); e += '\n'; } } return e; }; }, function (t, e, i) {
  t.exports = {
    CheckMatrix: i(113), MatrixToString: i(489), ReverseColumns: i(488), ReverseRows: i(487), Rotate180: i(486), RotateLeft: i(485), RotateMatrix: i(75), RotateRight: i(484), TransposeMatrix: i(173),
  };
}, function (t, e, i) {
  const n = i(0); const s = i(92); const r = i(12); const o = i(82); const a = new n({
    Extends: s, initialize(t) { s.call(this, t), this.sortChildrenFlag = !1, this.scene = t, this.systems = t.sys, t.sys.events.once('boot', this.boot, this), t.sys.events.on('start', this.start, this); }, boot() { this.systems.events.once('destroy', this.destroy, this); }, start() { this.systems.events.once('shutdown', this.shutdown, this); }, queueDepthSort() { this.sortChildrenFlag = !0; }, depthSort() { this.sortChildrenFlag && (o.inplace(this.list, this.sortByDepth), this.sortChildrenFlag = !1); }, sortByDepth(t, e) { return t._depth - e._depth; }, sortGameObjects(t) { return void 0 === t && (t = this.list), this.scene.sys.depthSort(), t.sort(this.sortIndexHandler.bind(this)); }, getTopGameObject(t) { return this.sortGameObjects(t), t[t.length - 1]; }, shutdown() { this.removeAll(), this.systems.events.off('shutdown', this.shutdown, this); }, destroy() { this.shutdown(), this.scene.sys.events.off('start', this.start, this), this.scene = null, this.systems = null; },
  }); r.register('DisplayList', a, 'displayList'), t.exports = a;
}, function (t, e) { t.exports = function (t) { let e; const i = t.events; void 0 !== document.hidden ? e = 'visibilitychange' : ['webkit', 'moz', 'ms'].forEach((t) => { void 0 !== document[`${t}Hidden`] && (document.hidden = function () { return document[`${t}Hidden`]; }, e = `${t}visibilitychange`); }); e && document.addEventListener(e, (t) => { document.hidden || t.type === 'pause' ? i.emit('hidden') : i.emit('visible'); }, !1), window.onblur = function () { i.emit('blur'); }, window.onfocus = function () { i.emit('focus'); }, window.focus && t.config.autoFocus && (window.focus(), t.canvas.addEventListener('mousedown', () => { window.focus(); }, { passive: !0 })); }; }, function (t, e, i) {
  const n = i(0); const s = i(4); const r = i(3); const o = i(267); const a = new n({
    initialize(t, e) { this.game = t, this.raf = new o(), this.started = !1, this.running = !1, this.minFps = s(e, 'min', 5), this.targetFps = s(e, 'target', 60), this._min = 1e3 / this.minFps, this._target = 1e3 / this.targetFps, this.actualFps = this.targetFps, this.nextFpsUpdate = 0, this.framesThisSecond = 0, this.callback = r, this.forceSetTimeOut = s(e, 'forceSetTimeOut', !1), this.time = 0, this.startTime = 0, this.lastTime = 0, this.frame = 0, this.inFocus = !0, this._pauseTime = 0, this._coolDown = 0, this.delta = 0, this.deltaIndex = 0, this.deltaHistory = [], this.deltaSmoothingMax = s(e, 'deltaHistory', 10), this.panicMax = s(e, 'panicMax', 120), this.rawDelta = 0; }, blur() { this.inFocus = !1; }, focus() { this.inFocus = !0, this.resetDelta(); }, pause() { this._pauseTime = window.performance.now(); }, resume() { this.resetDelta(), this.startTime += this.time - this._pauseTime; }, resetDelta() { const t = window.performance.now(); this.time = t, this.lastTime = t, this.nextFpsUpdate = t + 1e3, this.framesThisSecond = 0, this.frame = 0; for (let e = 0; e < this.deltaSmoothingMax; e++) this.deltaHistory[e] = Math.min(this._target, this.deltaHistory[e]); this.delta = 0, this.deltaIndex = 0, this._coolDown = this.panicMax; }, start(t) { if (this.started) return this; this.started = !0, this.running = !0; for (let e = 0; e < this.deltaSmoothingMax; e++) this.deltaHistory[e] = this._target; this.resetDelta(), this.startTime = window.performance.now(), this.callback = t, this.raf.start(this.step.bind(this), this.forceSetTimeOut); }, step(t) { this.frame++, this.rawDelta = t - this.lastTime; const e = this.deltaIndex; const i = this.deltaHistory; const n = this.deltaSmoothingMax; let s = t - this.lastTime; (this._coolDown > 0 || !this.inFocus) && (this._coolDown--, s = Math.min(s, this._target)), s > this._min && (s = i[e], s = Math.min(s, this._min)), i[e] = s, this.deltaIndex++, this.deltaIndex > n && (this.deltaIndex = 0); for (var r = 0, o = 0; o < n; o++)r += i[o]; r /= n, this.delta = r, this.time += this.rawDelta, t > this.nextFpsUpdate && (this.actualFps = 0.25 * this.framesThisSecond + 0.75 * this.actualFps, this.nextFpsUpdate = t + 1e3, this.framesThisSecond = 0), this.framesThisSecond++; const a = r / this._target; this.callback(t, r, a), this.lastTime = t; }, tick() { this.step(window.performance.now()); }, sleep() { this.running && (this.raf.stop(), this.running = !1); }, wake(t) { this.running ? this.sleep() : t && (this.startTime += -this.lastTime + (this.lastTime = window.performance.now())), this.raf.start(this.step.bind(this), this.useRAF), this.running = !0, this.step(window.performance.now()); }, stop() { return this.running = !1, this.started = !1, this.raf.stop(), this; }, destroy() { this.stop(), this.callback = r, this.raf = null, this.game = null; },
  }); t.exports = a;
}, function (t, e) {
  let i = 0; const n = function (t, e, n, s) { const r = i - s.y - s.height; t.add(n, e, s.x, r, s.width, s.height); }; t.exports = function (t, e, s) {
    const r = t.source[e]; t.add('__BASE', e, 0, 0, r.width, r.height), i = r.height; for (var o = s.split('\n'), a = /^[ ]*(- )*(\w+)+[: ]+(.*)/, h = '', l = '', u = {
        x: 0, y: 0, width: 0, height: 0,
      }, c = 0; c < o.length; c++) {
      const d = o[c].match(a); if (d) {
        const f = d[1] === '- '; const p = d[2]; const g = d[3]; if (f && (l !== h && (n(t, e, l, u), h = l), u = {
          x: 0, y: 0, width: 0, height: 0,
        }), p !== 'name') switch (p) { case 'x': case 'y': case 'width': case 'height': u[p] = parseInt(g, 10); } else l = g;
      }
    } return l !== h && n(t, e, l, u), t;
  };
}, function (t, e, i) { const n = i(1); t.exports = function (t, e, i) { const s = n(i, 'frameWidth', null); const r = n(i, 'frameHeight', s); if (!s) throw new Error('TextureManager.SpriteSheetFromAtlas: Invalid frameWidth given.'); let o; let a = n(i, 'startFrame', 0); const h = n(i, 'endFrame', -1); const l = n(i, 'margin', 0); const u = n(i, 'spacing', 0); const c = e.cutX; const d = e.cutY; const f = e.cutWidth; const p = e.cutHeight; const g = e.realWidth; const v = e.realHeight; const y = Math.floor((g - l + u) / (s + u)); const m = Math.floor((v - l + u) / (r + u)); let x = y * m; const w = e.x; const b = s - w; const T = s - (g - f - w); const S = e.y; const A = r - S; const C = r - (v - p - S); (a > x || a < -x) && (a = 0), a < 0 && (a = x + a), h !== -1 && (x = a + (h + 1)); for (let M = l, _ = l, E = 0, P = e.sourceIndex, L = 0; L < m; L++) { for (var F = L === 0, k = L === m - 1, R = 0; R < y; R++) { const O = R === 0; const B = R === y - 1; if (o = t.add(E, P, c + M, d + _, s, r), O || F || B || k) { const D = O ? w : 0; const I = F ? S : 0; let z = s; let Y = r; O ? z = b : B && (z = T), F ? Y = A : k && (Y = C), o.cutWidth = z, o.cutHeight = Y, o.setTrim(s, r, D, I, z, Y); }M += u, M += O ? b : B || s, E++; }M = l, _ += u, _ += F ? A : k ? C : r; } return t; }; }, function (t, e, i) { const n = i(1); t.exports = function (t, e, i, s, r, o, a) { const h = n(a, 'frameWidth', null); const l = n(a, 'frameHeight', h); if (h === null) throw new Error('TextureManager.SpriteSheet: Invalid frameWidth given.'); const u = t.source[e]; t.add('__BASE', e, 0, 0, u.width, u.height); let c = n(a, 'startFrame', 0); const d = n(a, 'endFrame', -1); const f = n(a, 'margin', 0); const p = n(a, 'spacing', 0); let g = Math.floor((r - f + p) / (h + p)) * Math.floor((o - f + p) / (l + p)); (c > g || c < -g) && (c = 0), c < 0 && (c = g + c), d !== -1 && (g = c + (d + 1)); for (let v = f, y = f, m = 0, x = 0, w = 0; w < g; w++) { m = 0, x = 0; const b = v + h; const T = y + l; b > r && (m = b - r), T > o && (x = T - o), t.add(w, e, i + v, s + y, h - m, l - x), (v += h + p) + h > r && (v = f, y += l + p); } return t; }; }, function (t, e, i) { const n = i(33); t.exports = function (t, e, i) { if (i.frames) { const s = t.source[e]; t.add('__BASE', e, 0, 0, s.width, s.height); let r; const o = i.frames; for (const a in o) { const h = o[a]; r = t.add(a, e, h.frame.x, h.frame.y, h.frame.w, h.frame.h), h.trimmed && r.setTrim(h.sourceSize.w, h.sourceSize.h, h.spriteSourceSize.x, h.spriteSourceSize.y, h.spriteSourceSize.w, h.spriteSourceSize.h), h.rotated && (r.rotated = !0, r.updateUVsInverted()), r.customData = n(h); } for (const l in i)l !== 'frames' && (Array.isArray(i[l]) ? t.customData[l] = i[l].slice(0) : t.customData[l] = i[l]); return t; }console.warn("Invalid Texture Atlas JSON Hash given, missing 'frames' Object"); }; }, function (t, e, i) { const n = i(33); t.exports = function (t, e, i) { if (i.frames || i.textures) { const s = t.source[e]; t.add('__BASE', e, 0, 0, s.width, s.height); for (var r, o = Array.isArray(i.textures) ? i.textures[e].frames : i.frames, a = 0; a < o.length; a++) { const h = o[a]; r = t.add(h.filename, e, h.frame.x, h.frame.y, h.frame.w, h.frame.h), h.trimmed && r.setTrim(h.sourceSize.w, h.sourceSize.h, h.spriteSourceSize.x, h.spriteSourceSize.y, h.spriteSourceSize.w, h.spriteSourceSize.h), h.rotated && (r.rotated = !0, r.updateUVsInverted()), h.anchor && (r.customPivot = !0, r.pivotX = h.anchor.x, r.pivotY = h.anchor.y), r.customData = n(h); } for (const l in i)l !== 'frames' && (Array.isArray(i[l]) ? t.customData[l] = i[l].slice(0) : t.customData[l] = i[l]); return t; }console.warn('Invalid Texture Atlas JSON Array'); }; }, function (t, e) { t.exports = function (t, e) { const i = t.source[e]; return t.add('__BASE', e, 0, 0, i.width, i.height), t; }; }, function (t, e) { t.exports = function (t, e) { const i = t.source[e]; return t.add('__BASE', e, 0, 0, i.width, i.height), t; }; }, function (t, e) { t.exports = function (t, e, i) { if (i.getElementsByTagName('TextureAtlas')) { const n = t.source[e]; t.add('__BASE', e, 0, 0, n.width, n.height); for (var s, r = i.getElementsByTagName('SubTexture'), o = 0; o < r.length; o++) { const a = r[o].attributes; const h = a.name.value; const l = parseInt(a.x.value, 10); const u = parseInt(a.y.value, 10); const c = parseInt(a.width.value, 10); const d = parseInt(a.height.value, 10); if (s = t.add(h, e, l, u, c, d), a.frameX) { const f = Math.abs(parseInt(a.frameX.value, 10)); const p = Math.abs(parseInt(a.frameY.value, 10)); const g = parseInt(a.frameWidth.value, 10); const v = parseInt(a.frameHeight.value, 10); s.setTrim(c, d, f, p, g, v); } } return t; }console.warn('Invalid Texture Atlas XML given'); }; }, function (t, e, i) {
  const n = i(0); const s = i(84); const r = i(114); const o = new n({
    Extends: r, initialize(t, e, i, n, s) { r.call(this, t, e, i, n, s), this.add('__BASE', 0, 0, 0, n, s), this._source = this.frames.__BASE.source, this.canvas = this._source.image, this.context = this.canvas.getContext('2d'), this.width = n, this.height = s; }, refresh() { return this._source.update(), this; }, getCanvas() { return this.canvas; }, getContext() { return this.context; }, clear() { return this.context.clearRect(0, 0, this.width, this.height), this; }, setSize(t, e) { return void 0 === e && (e = t), t === this.width && e === this.height || (this.canvas.width = t, this.canvas.height = e, this._source.width = t, this._source.height = e, this._source.isPowerOf2 = s(t, e), this.frames.__BASE.setSize(t, e, 0, 0), this.refresh()), this; },
  }); t.exports = o;
}, function (t, e) {
  t.exports = {
    game: 'game', anims: 'anims', cache: 'cache', plugins: 'plugins', registry: 'registry', sound: 'sound', textures: 'textures', events: 'events', cameras: 'cameras', cameras3d: 'cameras3d', add: 'add', make: 'make', scenePlugin: 'scene', displayList: 'children', lights: 'lights', data: 'data', input: 'input', load: 'load', time: 'time', tweens: 'tweens', arcadePhysics: 'physics', impactPhysics: 'impact', matterPhysics: 'matter',
  };
}, function (t, e, i) { const n = i(1); t.exports = function (t) { const e = t.plugins.getDefaultScenePlugins(); const i = n(t.settings, 'plugins', !1); return Array.isArray(i) ? i : e || []; }; }, function (t, e, i) { const n = i(1); const s = i(255); t.exports = function (t) { const e = t.game.config.defaultPhysicsSystem; const i = n(t.settings, 'physics', !1); if (e || i) { const r = []; if (e && r.push(s(`${e}Physics`)), i) for (let o in i)o = s(o.concat('Physics')), r.indexOf(o) === -1 && r.push(o); return r; } }; }, function (t, e) { t.exports = function (t, e) { if (t.originalEvent = e, t.preventDefault && e.preventDefault(), t.enabled) return t.isDown = !1, t.isUp = !0, t.timeUp = e.timeStamp, t.duration = t.timeUp - t.timeDown, t.repeats = 0, t._justDown = !1, t._justUp = !0, t; }; }, function (t, e) { t.exports = function (t, e) { if (t.originalEvent = e, t.preventDefault && e.preventDefault(), t.enabled) return t.altKey = e.altKey, t.ctrlKey = e.ctrlKey, t.shiftKey = e.shiftKey, t.location = e.location, !1 === t.isDown && (t.isDown = !0, t.isUp = !1, t.timeDown = e.timeStamp, t.duration = 0, t._justDown = !0, t._justUp = !1), t.repeats++, t; }; }, function (t, e, i) { const n = i(116); const s = {}; for (const r in n)s[n[r]] = r; t.exports = s; }, function (t, e) { t.exports = function (t) { return t.current = t.keyCodes[0], t.index = 0, t.timeLastMatched = 0, t.matched = !1, t.timeMatched = 0, t; }; }, function (t, e) { t.exports = function (t, e) { return e.timeLastMatched = t.timeStamp, e.index++, e.index === e.size || (e.current = e.keyCodes[e.index], !1); }; }, function (t, e, i) { const n = i(510); t.exports = function (t, e) { if (e.matched) return !0; let i = !1; let s = !1; if (t.keyCode === e.current) if (e.index > 0 && e.maxKeyDelay > 0) { const r = e.timeLastMatched + e.maxKeyDelay; t.timeStamp <= r && (s = !0, i = n(t, e)); } else s = !0, i = n(t, e); return !s && e.resetOnWrongKey && (e.index = 0, e.current = e.keyCodes[0]), i && (e.timeLastMatched = t.timeStamp, e.matched = !0, e.timeMatched = t.timeStamp), i; }; }, function (t, e) {
  const i = {
    available: !1, cancel: '', keyboard: !1, request: '',
  }; t.exports = (function () { let t; const e = ['requestFullscreen', 'requestFullScreen', 'webkitRequestFullscreen', 'webkitRequestFullScreen', 'msRequestFullscreen', 'msRequestFullScreen', 'mozRequestFullScreen', 'mozRequestFullscreen']; const n = document.createElement('div'); for (t = 0; t < e.length; t++) if (n[e[t]]) { i.available = !0, i.request = e[t]; break; } const s = ['cancelFullScreen', 'exitFullscreen', 'webkitCancelFullScreen', 'webkitExitFullscreen', 'msCancelFullScreen', 'msExitFullscreen', 'mozCancelFullScreen', 'mozExitFullscreen']; if (i.available) for (t = 0; t < s.length; t++) if (document[s[t]]) { i.cancel = s[t]; break; } return window.Element && Element.ALLOW_KEYBOARD_INPUT && (i.keyboard = !0), i; }());
}, function (t, e) {
  const i = {
    h264Video: !1, hlsVideo: !1, mp4Video: !1, oggVideo: !1, vp9Video: !1, webmVideo: !1,
  }; t.exports = (function () { const t = document.createElement('video'); const e = !!t.canPlayType; try { e && (t.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, '') && (i.oggVideo = !0), t.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, '') && (i.h264Video = !0, i.mp4Video = !0), t.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, '') && (i.webmVideo = !0), t.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, '') && (i.vp9Video = !0), t.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, '') && (i.hlsVideo = !0)); } catch (t) {} return i; }());
}, function (t, e, i) {
  const n = i(78); const s = {
    audioData: !1, dolby: !1, m4a: !1, mp3: !1, ogg: !1, opus: !1, wav: !1, webAudio: !1, webm: !1,
  }; t.exports = (function () { s.audioData = !!window.Audio, s.webAudio = !(!window.AudioContext && !window.webkitAudioContext); const t = document.createElement('audio'); const e = !!t.canPlayType; try { if (e && (t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, '') && (s.ogg = !0), (t.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, '') || t.canPlayType('audio/opus;').replace(/^no$/, '')) && (s.opus = !0), t.canPlayType('audio/mpeg;').replace(/^no$/, '') && (s.mp3 = !0), t.canPlayType('audio/wav; codecs="1"').replace(/^no$/, '') && (s.wav = !0), (t.canPlayType('audio/x-m4a;') || t.canPlayType('audio/aac;').replace(/^no$/, '')) && (s.m4a = !0), t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, '') && (s.webm = !0), t.canPlayType('audio/mp4;codecs="ec-3"') !== '')) if (n.edge)s.dolby = !0; else if (n.safari && n.safariVersion >= 9 && /Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)) { const i = parseInt(RegExp.$1, 10); const r = parseInt(RegExp.$2, 10); (i === 10 && r >= 11 || i > 10) && (s.dolby = !0); } } catch (t) {} return s; }());
}, function (t, e, i) {
  const n = i(56); const s = i(78); const r = {
    gamepads: !1, mspointer: !1, touch: !1, wheelEvent: null,
  }; t.exports = (('ontouchstart' in document.documentElement || navigator.maxTouchPoints && navigator.maxTouchPoints >= 1) && (r.touch = !0), (navigator.msPointerEnabled || navigator.pointerEnabled) && (r.mspointer = !0), navigator.getGamepads && (r.gamepads = !0), n.cocoonJS || ('onwheel' in window || s.ie && 'WheelEvent' in window ? r.wheelEvent = 'wheel' : 'onmousewheel' in window ? r.wheelEvent = 'mousewheel' : s.firefox && 'MouseScrollEvent' in window && (r.wheelEvent = 'DOMMouseScroll')), r);
}, function (t, e, i) {
  t.exports = {
    os: i(56), browser: i(78), features: i(118), input: i(515), audio: i(514), video: i(513), fullscreen: i(512), canvasFeatures: i(201),
  };
}, function (t, e, i) { const n = i(20); t.exports = function (t) { const e = t.config; if (!e.hideBanner) { let i = 'WebGL'; e.renderType === n.CANVAS ? i = 'Canvas' : e.renderType === n.HEADLESS && (i = 'Headless'); let s; const r = e.audio; const o = t.device.audio; if (s = !o.webAudio || r && r.disableWebAudio ? r && r.noAudio || !o.webAudio && !o.audioData ? 'No Audio' : 'HTML5 Audio' : 'Web Audio', t.device.browser.ie)window.console && console.log(`Phaser v${n.VERSION} / https://phaser.io`); else { let a; let h = ''; const l = [h]; Array.isArray(e.bannerBackgroundColor) ? (e.bannerBackgroundColor.forEach((t) => { h = h.concat('%c '), l.push(`background: ${t}`), a = t; }), l[l.length - 1] = `color: ${e.bannerTextColor}; background: ${a}`) : (h = h.concat('%c '), l.push(`color: ${e.bannerTextColor}; background: ${e.bannerBackgroundColor}`)), l.push('background: #fff'), e.gameTitle && (h = h.concat(e.gameTitle), e.gameVersion && (h = h.concat(` v${e.gameVersion}`)), e.hidePhaser || (h = h.concat(' / '))), e.hidePhaser || (h = h.concat(`Phaser v${n.VERSION} (${i} | ${s})`)), h = h.concat(` %c ${e.gameURL}`), l[0] = h, console.log.apply(console, l); } } }; }, function (t, e) { t.exports = ['#define SHADER_NAME PHASER_TEXTURE_TINT_VS', '', 'precision mediump float;', '', 'uniform mat4 uProjectionMatrix;', 'uniform mat4 uViewMatrix;', 'uniform mat4 uModelMatrix;', '', 'attribute vec2 inPosition;', 'attribute vec2 inTexCoord;', 'attribute vec4 inTint;', '', 'varying vec2 outTexCoord;', 'varying vec4 outTint;', '', 'void main ()', '{', '    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(inPosition, 1.0, 1.0);', '    outTexCoord = inTexCoord;', '    outTint = inTint;', '}', '', ''].join('\n'); }, function (t, e) { t.exports = ['#define SHADER_NAME PHASER_TEXTURE_TINT_FS', '', 'precision mediump float;', '', 'uniform sampler2D uMainSampler;', '', 'varying vec2 outTexCoord;', 'varying vec4 outTint;', '', 'void main()', '{', '    vec4 texel = texture2D(uMainSampler, outTexCoord);', '    texel *= vec4(outTint.rgb * outTint.a, outTint.a);', '    gl_FragColor = texel;', '}', ''].join('\n'); }, function (t, e) { t.exports = ['#define SHADER_NAME PHASER_FORWARD_DIFFUSE_FS', '', 'precision mediump float;', '', 'struct Light', '{', '    vec2 position;', '    vec3 color;', '    float intensity;', '    float radius;', '};', '', 'const int kMaxLights = %LIGHT_COUNT%;', '', 'uniform vec4 uCamera; /* x, y, rotation, zoom */', 'uniform vec2 uResolution;', 'uniform sampler2D uMainSampler;', 'uniform sampler2D uNormSampler;', 'uniform vec3 uAmbientLightColor;', 'uniform Light uLights[kMaxLights];', '', 'varying vec2 outTexCoord;', 'varying vec4 outTint;', '', 'void main()', '{', '    vec3 finalColor = vec3(0.0, 0.0, 0.0);', '    vec4 color = texture2D(uMainSampler, outTexCoord) * vec4(outTint.rgb * outTint.a, outTint.a);', '    vec3 normalMap = texture2D(uNormSampler, outTexCoord).rgb;', '    vec3 normal = normalize(vec3(normalMap * 2.0 - 1.0));', '    vec2 res = vec2(min(uResolution.x, uResolution.y)) * uCamera.w;', '', '    for (int index = 0; index < kMaxLights; ++index)', '    {', '        Light light = uLights[index];', '        vec3 lightDir = vec3((light.position.xy / res) - (gl_FragCoord.xy / res), 0.1);', '        vec3 lightNormal = normalize(lightDir);', '        float distToSurf = length(lightDir) * uCamera.w;', '        float diffuseFactor = max(dot(normal, lightNormal), 0.0);', '        float radius = (light.radius / res.x * uCamera.w) * uCamera.w;', '        float attenuation = clamp(1.0 - distToSurf * distToSurf / (radius * radius), 0.0, 1.0);', '        vec3 diffuse = light.color * diffuseFactor;', '        finalColor += (attenuation * diffuse) * light.intensity;', '    }', '', '    vec4 colorOutput = vec4(uAmbientLightColor + finalColor, 1.0);', '    gl_FragColor = color * vec4(colorOutput.rgb * colorOutput.a, colorOutput.a);', '', '}', ''].join('\n'); }, function (t, e) { t.exports = ['#define SHADER_NAME PHASER_FLAT_TINT_VS', '', 'precision mediump float;', '', 'uniform mat4 uProjectionMatrix;', 'uniform mat4 uViewMatrix;', 'uniform mat4 uModelMatrix;', '', 'attribute vec2 inPosition;', 'attribute vec4 inTint;', '', 'varying vec4 outTint;', '', 'void main () {', '    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(inPosition, 1.0, 1.0);', '    outTint = inTint;', '}', ''].join('\n'); }, function (t, e) { t.exports = ['#define SHADER_NAME PHASER_FLAT_TINT_FS', '', 'precision mediump float;', '', 'varying vec4 outTint;', '', 'void main() {', '    gl_FragColor = vec4(outTint.rgb * outTint.a, outTint.a);', '}', ''].join('\n'); }, function (t, e) { t.exports = ['#define SHADER_NAME PHASER_BITMAP_MASK_VS', '', 'precision mediump float;', '', 'attribute vec2 inPosition;', '', 'void main()', '{', '    gl_Position = vec4(inPosition, 0.0, 1.0);', '}', ''].join('\n'); }, function (t, e) { t.exports = ['#define SHADER_NAME PHASER_BITMAP_MASK_FS', '', 'precision mediump float;', '', 'uniform vec2 uResolution;', 'uniform sampler2D uMainSampler;', 'uniform sampler2D uMaskSampler;', 'uniform bool uInvertMaskAlpha;', '', 'void main()', '{', '    vec2 uv = gl_FragCoord.xy / uResolution;', '    vec4 mainColor = texture2D(uMainSampler, uv);', '    vec4 maskColor = texture2D(uMaskSampler, uv);', '    float alpha = mainColor.a;', '', '    if (!uInvertMaskAlpha)', '    {', '        alpha *= (maskColor.a);', '    }', '    else', '    {', '        alpha *= (1.0 - maskColor.a);', '    }', '', '    gl_FragColor = vec4(mainColor.rgb * alpha, alpha);', '}', ''].join('\n'); }, function (t, e, i) { const n = i(272); const s = i(22); const r = i(20); const o = i(118); t.exports = function (t) { let e; let a; const h = t.config; if (h.renderType !== r.HEADLESS) if (h.renderType === r.CANVAS || h.renderType !== r.CANVAS && !o.webGL) { if (!o.canvas) throw new Error('Cannot create Canvas or WebGL context, aborting.'); h.renderType = r.CANVAS; } else h.renderType = r.WEBGL; h.pixelArt && s.disableSmoothing(), h.canvas ? t.canvas = h.canvas : t.canvas = s.create(t, h.width, h.height, h.renderType), h.canvasStyle && (t.canvas.style = h.canvasStyle), h.pixelArt && n.setCrisp(t.canvas), h.zoom !== 1 && (t.canvas.style.width = `${(h.width * h.zoom).toString()}px`, t.canvas.style.height = `${(h.height * h.zoom).toString()}px`), h.renderType !== r.HEADLESS && (e = i(266), a = i(261), h.renderType === r.WEBGL ? (t.renderer = new a(t), t.context = null) : (t.renderer = new e(t), t.context = t.renderer.gameContext)); }; }, function (t, e, i) { const n = i(0); const s = i(20); const r = i(1); const o = i(4); const a = i(8); const h = i(16); const l = i(3); const u = i(119); const c = i(129); const d = new n({ initialize(t) { void 0 === t && (t = {}); this.width = o(t, 'width', 1024), this.height = o(t, 'height', 768), this.zoom = o(t, 'zoom', 1), this.resolution = o(t, 'resolution', 1), this.renderType = o(t, 'type', s.AUTO), this.parent = o(t, 'parent', null), this.canvas = o(t, 'canvas', null), this.context = o(t, 'context', null), this.canvasStyle = o(t, 'canvasStyle', null), this.sceneConfig = o(t, 'scene', null), this.seed = o(t, 'seed', [(Date.now() * Math.random()).toString()]), h.RND.init(this.seed), this.gameTitle = o(t, 'title', ''), this.gameURL = o(t, 'url', 'https://phaser.io'), this.gameVersion = o(t, 'version', ''), this.autoFocus = o(t, 'autoFocus', !0), this.inputKeyboard = o(t, 'input.keyboard', !0), this.inputKeyboardEventTarget = o(t, 'input.keyboard.target', window), this.inputMouse = o(t, 'input.mouse', !0), this.inputMouseEventTarget = o(t, 'input.mouse.target', null), this.inputMouseCapture = o(t, 'input.mouse.capture', !0), this.inputTouch = o(t, 'input.touch', !0), this.inputTouchEventTarget = o(t, 'input.touch.target', null), this.inputTouchCapture = o(t, 'input.touch.capture', !0), this.inputGamepad = o(t, 'input.gamepad', !1), this.disableContextMenu = o(t, 'disableContextMenu', !1), this.audio = o(t, 'audio'), this.hideBanner = !1 === o(t, 'banner', null), this.hidePhaser = o(t, 'banner.hidePhaser', !1), this.bannerTextColor = o(t, 'banner.text', '#ffffff'), this.bannerBackgroundColor = o(t, 'banner.background', ['#ff0000', '#ffff00', '#00ff00', '#00ffff', '#000000']), this.gameTitle === '' && this.hidePhaser && (this.hideBanner = !0), this.fps = o(t, 'fps', null); const e = o(t, 'render', t); this.antialias = o(e, 'antialias', !0), this.pixelArt = o(e, 'pixelArt', !1), this.autoResize = o(e, 'autoResize', !1), this.roundPixels = o(e, 'roundPixels', !1), this.transparent = o(e, 'transparent', !1), this.clearBeforeRender = o(e, 'clearBeforeRender', !0), this.premultipliedAlpha = o(e, 'premultipliedAlpha', !0), this.preserveDrawingBuffer = o(e, 'preserveDrawingBuffer', !1), this.failIfMajorPerformanceCaveat = o(e, 'failIfMajorPerformanceCaveat', !1), this.powerPreference = o(e, 'powerPreference', 'default'); const i = o(t, 'backgroundColor', 0); this.backgroundColor = c(i), i === 0 && this.transparent && (this.backgroundColor.alpha = 0), this.preBoot = o(t, 'callbacks.preBoot', l), this.postBoot = o(t, 'callbacks.postBoot', l), this.physics = o(t, 'physics', {}), this.defaultPhysicsSystem = o(this.physics, 'default', !1), this.loaderBaseURL = o(t, 'loader.baseURL', ''), this.loaderPath = o(t, 'loader.path', ''), this.loaderMaxParallelDownloads = o(t, 'loader.maxParallelDownloads', 32), this.loaderCrossOrigin = o(t, 'loader.crossOrigin', void 0), this.loaderResponseType = o(t, 'loader.responseType', ''), this.loaderAsync = o(t, 'loader.async', !0), this.loaderUser = o(t, 'loader.user', ''), this.loaderPassword = o(t, 'loader.password', ''), this.loaderTimeout = o(t, 'loader.timeout', 0), this.installGlobalPlugins = [], this.installScenePlugins = []; const n = o(t, 'plugins', null); let d = u.DefaultScene; n && (Array.isArray(n) ? this.defaultPlugins = n : a(n) && (this.installGlobalPlugins = r(n, 'global', []), this.installScenePlugins = r(n, 'scene', []), Array.isArray(n.default) ? d = n.default : Array.isArray(n.defaultMerge) && (d = d.concat(n.defaultMerge)))), this.defaultPlugins = d; const f = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAg'; this.defaultImage = o(t, 'images.default', `${f}AQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==`), this.missingImage = o(t, 'images.missing', `${f}CAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==`); } }); t.exports = d; }, function (t, e, i) {
  const n = i(127); const s = i(205); const r = i(203); const o = i(22); const a = i(0); const h = i(526); const l = i(525); const u = i(79); const c = i(517); const d = i(516); const f = i(270); const p = i(9); const g = i(199); const v = i(188); const y = i(186); const m = i(183); const x = i(176); const w = i(493); const b = i(492); const T = new a({
    initialize(t) { this.config = new h(t), this.renderer = null, this.canvas = null, this.context = null, this.isBooted = !1, this.isRunning = !1, this.events = new p(), this.anims = new s(this), this.textures = new x(this), this.cache = new r(this), this.registry = new u(this), this.input = new g(this, this.config), this.scene = new y(this, this.config.sceneConfig), this.device = d, this.sound = m.create(this), this.loop = new w(this, this.config.fps), this.plugins = new v(this, this.config), this.pendingDestroy = !1, this.removeCanvas = !1, this.hasFocus = !1, f(this.boot.bind(this)); }, boot() { this.isBooted = !0, this.config.preBoot(this), l(this), c(this), n(this.canvas, this.config.parent), this.events.emit('boot'), this.events.once('ready', this.start, this); }, start() { this.isRunning = !0, this.config.postBoot(this), this.renderer ? this.loop.start(this.step.bind(this)) : this.loop.start(this.headlessStep.bind(this)), b(this); const t = this.events; t.on('hidden', this.onHidden, this), t.on('visible', this.onVisible, this), t.on('blur', this.onBlur, this), t.on('focus', this.onFocus, this); }, step(t, e) { if (this.pendingDestroy) return this.runDestroy(); const i = this.events; i.emit('prestep', t, e), i.emit('step', t, e), this.scene.update(t, e), i.emit('poststep', t, e); const n = this.renderer; n.preRender(), i.emit('prerender', n, t, e), this.scene.render(n), n.postRender(), i.emit('postrender', n, t, e); }, headlessStep(t, e) { const i = this.events; i.emit('prestep', t, e), i.emit('step', t, e), this.scene.update(t, e), i.emit('poststep', t, e), i.emit('prerender'), i.emit('postrender'); }, onHidden() { this.loop.pause(), this.events.emit('pause'); }, onVisible() { this.loop.resume(), this.events.emit('resume'); }, onBlur() { this.hasFocus = !1, this.loop.blur(); }, onFocus() { this.hasFocus = !0, this.loop.focus(); }, resize(t, e) { this.config.width = t, this.config.height = e, this.renderer.resize(t, e), this.input.resize(), this.scene.resize(t, e), this.events.emit('resize', t, e); }, destroy(t) { this.pendingDestroy = !0, this.removeCanvas = t; }, runDestroy() { this.events.emit('destroy'), this.events.removeAllListeners(), this.scene.destroy(), this.renderer && this.renderer.destroy(), this.removeCanvas && this.canvas && (o.remove(this.canvas), this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas)), this.loop.destroy(), this.pendingDestroy = !1; },
  }); t.exports = T;
}, function (t, e, i) {
  const n = i(0); const s = i(9); const r = i(12); const o = new n({
    Extends: s, initialize() { s.call(this); }, shutdown() { this.removeAllListeners(); }, destroy() { this.removeAllListeners(); },
  }); r.register('EventEmitter', o, 'events'), t.exports = o;
}, function (t, e, i) { t.exports = { EventEmitter: i(528) }; }, function (t, e) { let i; let n; const s = t.exports = {}; function r() { throw new Error('setTimeout has not been defined'); } function o() { throw new Error('clearTimeout has not been defined'); } function a(t) { if (i === setTimeout) return setTimeout(t, 0); if ((i === r || !i) && setTimeout) return i = setTimeout, setTimeout(t, 0); try { return i(t, 0); } catch (e) { try { return i.call(null, t, 0); } catch (e) { return i.call(this, t, 0); } } }!(function () { try { i = typeof setTimeout === 'function' ? setTimeout : r; } catch (t) { i = r; } try { n = typeof clearTimeout === 'function' ? clearTimeout : o; } catch (t) { n = o; } }()); let h; let l = []; let u = !1; let c = -1; function d() { u && h && (u = !1, h.length ? l = h.concat(l) : c = -1, l.length && f()); } function f() { if (!u) { const t = a(d); u = !0; for (let e = l.length; e;) { for (h = l, l = []; ++c < e;)h && h[c].run(); c = -1, e = l.length; }h = null, u = !1, (function (t) { if (n === clearTimeout) return clearTimeout(t); if ((n === o || !n) && clearTimeout) return n = clearTimeout, clearTimeout(t); try { n(t); } catch (e) { try { return n.call(null, t); } catch (e) { return n.call(this, t); } } }(t)); } } function p(t, e) { this.fun = t, this.array = e; } function g() {}s.nextTick = function (t) { const e = new Array(arguments.length - 1); if (arguments.length > 1) for (let i = 1; i < arguments.length; i++)e[i - 1] = arguments[i]; l.push(new p(t, e)), l.length !== 1 || u || a(f); }, p.prototype.run = function () { this.fun.apply(null, this.array); }, s.title = 'browser', s.browser = !0, s.env = {}, s.argv = [], s.version = '', s.versions = {}, s.on = g, s.addListener = g, s.once = g, s.off = g, s.removeListener = g, s.removeAllListeners = g, s.emit = g, s.prependListener = g, s.prependOnceListener = g, s.listeners = function (t) { return []; }, s.binding = function (t) { throw new Error('process.binding is not supported'); }, s.cwd = function () { return '/'; }, s.chdir = function (t) { throw new Error('process.chdir is not supported'); }, s.umask = function () { return 0; }; }, function (t, e, i) { t.exports = { BitmapMask: i(212), GeometryMask: i(211) }; }, function (t, e, i) {
  const n = i(150); t.exports = function (t, e, i) {
    void 0 === e && (e = 1), void 0 === i && (i = 1); const s = Math.floor(6 * t); const r = 6 * t - s; const o = Math.floor(i * (1 - e) * 255); const a = Math.floor(i * (1 - r * e) * 255); const h = Math.floor(i * (1 - (1 - r) * e) * 255); const l = {
      r: i = Math.floor(i *= 255), g: i, b: i, color: 0,
    }; const u = s % 6; return u === 0 ? (l.g = h, l.b = o) : u === 1 ? (l.r = a, l.b = o) : u === 2 ? (l.r = o, l.b = h) : u === 3 ? (l.r = o, l.g = a) : u === 4 ? (l.r = h, l.g = o) : u === 5 && (l.g = o, l.b = a), l.color = n(l.r, l.g, l.b), l;
  };
}, function (t, e) { t.exports = function (t, e, i) { return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < 0.5 ? e : i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t; }; }, function (t, e) { t.exports = function (t) { const e = t.toString(16); return e.length === 1 ? `0${e}` : e; }; }, function (t, e, i) { const n = i(30); n.ColorToRGBA = i(921), n.ComponentToHex = i(534), n.GetColor = i(150), n.GetColor32 = i(284), n.HexStringToColor = i(285), n.HSLToColor = i(920), n.HSVColorWheel = i(919), n.HSVToRGB = i(532), n.HueToComponent = i(533), n.IntegerToColor = i(283), n.IntegerToRGB = i(282), n.Interpolate = i(918), n.ObjectToColor = i(281), n.RandomRGB = i(917), n.RGBStringToColor = i(280), n.RGBToHSV = i(916), n.RGBToString = i(915), n.ValueToColor = i(129), t.exports = n; }, function (t, e, i) {
  const n = i(0); const s = i(79); const r = i(12); const o = new n({
    Extends: s, initialize(t) { s.call(this, t, t.sys.events), this.scene = t, this.systems = t.sys, t.sys.events.once('boot', this.boot, this), t.sys.events.on('start', this.start, this); }, boot() { this.events = this.systems.events, this.events.once('destroy', this.destroy, this); }, start() { this.events.once('shutdown', this.shutdown, this); }, shutdown() { this.systems.events.off('shutdown', this.shutdown, this); }, destroy() { s.prototype.destroy.call(this), this.events.off('start', this.start, this), this.scene = null, this.systems = null; },
  }); r.register('DataManagerPlugin', o, 'data'), t.exports = o;
}, function (t, e, i) { t.exports = { DataManager: i(79), DataManagerPlugin: i(536) }; }, function (t, e, i) {
  const n = i(273); const s = i(0); const r = i(85); const o = i(7); const a = new s({
    Extends: r, initialize(t) { void 0 === t && (t = []), r.call(this, 'SplineCurve'), this.points = [], this.addPoints(t); }, addPoints(t) { for (let e = 0; e < t.length; e++) { const i = new o(); typeof t[e] === 'number' ? (i.x = t[e], i.y = t[e + 1], e++) : Array.isArray(t[e]) ? (i.x = t[e][0], i.y = t[e][1]) : (i.x = t[e].x, i.y = t[e].y), this.points.push(i); } return this; }, addPoint(t, e) { const i = new o(t, e); return this.points.push(i), i; }, getStartPoint(t) { return void 0 === t && (t = new o()), t.copy(this.points[0]); }, getResolution(t) { return t * this.points.length; }, getPoint(t, e) { void 0 === e && (e = new o()); const i = this.points; const s = (i.length - 1) * t; const r = Math.floor(s); const a = s - r; const h = i[r === 0 ? r : r - 1]; const l = i[r]; const u = i[r > i.length - 2 ? i.length - 1 : r + 1]; const c = i[r > i.length - 3 ? i.length - 1 : r + 2]; return e.set(n(a, h.x, l.x, u.x, c.x), n(a, h.y, l.y, u.y, c.y)); }, toJSON() { for (var t = [], e = 0; e < this.points.length; e++)t.push(this.points[e].x), t.push(this.points[e].y); return { type: this.type, points: t }; },
  }); a.fromJSON = function (t) { return new a(t.points); }, t.exports = a;
}, function (t, e) { t.exports = function (t, e, i, n) { return (function (t, e) { const i = 1 - t; return i * i * e; }(t, e)) + (function (t, e) { return 2 * (1 - t) * t * e; }(t, i)) + (function (t, e) { return t * t * e; }(t, n)); }; }, function (t, e, i) {
  const n = i(0); const s = i(85); const r = i(539); const o = i(7); const a = new n({
    Extends: s, initialize(t, e, i) { s.call(this, 'QuadraticBezier'), Array.isArray(t) && (i = new o(t[4], t[5]), e = new o(t[2], t[3]), t = new o(t[0], t[1])), this.p0 = t, this.p1 = e, this.p2 = i; }, getStartPoint(t) { return void 0 === t && (t = new o()), t.copy(this.p0); }, getResolution(t) { return t; }, getPoint(t, e) { void 0 === e && (e = new o()); const i = this.p0; const n = this.p1; const s = this.p2; return e.set(r(t, i.x, n.x, s.x), r(t, i.y, n.y, s.y)); }, draw(t, e) { void 0 === e && (e = 32); const i = this.getPoints(e); t.beginPath(), t.moveTo(this.p0.x, this.p0.y); for (let n = 1; n < i.length; n++)t.lineTo(i[n].x, i[n].y); return t.strokePath(), t; }, toJSON() { return { type: this.type, points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y, this.p2.x, this.p2.y] }; },
  }); a.fromJSON = function (t) { const e = t.points; const i = new o(e[0], e[1]); const n = new o(e[2], e[3]); const s = new o(e[4], e[5]); return new a(i, n, s); }, t.exports = a;
}, function (t, e, i) {
  const n = i(0); const s = i(85); const r = i(274); const o = i(14); const a = i(7); const h = new a(); const l = new n({
    Extends: s, initialize(t, e) { s.call(this, 'LineCurve'), Array.isArray(t) && (e = new a(t[2], t[3]), t = new a(t[0], t[1])), this.p0 = t, this.p1 = e; }, getBounds(t) { return void 0 === t && (t = new o()), r([this.p0, this.p1], t); }, getStartPoint(t) { return void 0 === t && (t = new a()), t.copy(this.p0); }, getResolution(t) { return void 0 === t && (t = 1), t; }, getPoint(t, e) { return void 0 === e && (e = new a()), t === 1 ? e.copy(this.p1) : (e.copy(this.p1).subtract(this.p0).scale(t).add(this.p0), e); }, getPointAt(t, e) { return this.getPoint(t, e); }, getTangent() { return h.copy(this.p1).subtract(this.p0).normalize(); }, draw(t) { return t.lineBetween(this.p0.x, this.p0.y, this.p1.x, this.p1.y), t; }, toJSON() { return { type: this.type, points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y] }; },
  }); l.fromJSON = function (t) { const e = t.points; const i = new a(e[0], e[1]); const n = new a(e[2], e[3]); return new l(i, n); }, t.exports = l;
}, function (t, e, i) {
  const n = i(0); const s = i(85); const r = i(38); const o = i(4); const a = i(148); const h = i(7); const l = new n({
    Extends: s,
    initialize(t, e, i, n, a, l, u, c) { if (typeof t === 'object') { const d = t; t = o(d, 'x', 0), e = o(d, 'y', 0), i = o(d, 'xRadius', 0), n = o(d, 'yRadius', i), a = o(d, 'startAngle', 0), l = o(d, 'endAngle', 360), u = o(d, 'clockwise', !1), c = o(d, 'rotation', 0); } else void 0 === n && (n = i), void 0 === a && (a = 0), void 0 === l && (l = 360), void 0 === u && (u = !1), void 0 === c && (c = 0); s.call(this, 'EllipseCurve'), this.p0 = new h(t, e), this._xRadius = i, this._yRadius = n, this._startAngle = r(a), this._endAngle = r(l), this._clockwise = u, this._rotation = r(c); },
    getStartPoint(t) { return void 0 === t && (t = new h()), this.getPoint(0, t); },
    getResolution(t) { return 2 * t; },
    getPoint(t, e) { void 0 === e && (e = new h()); for (var i = 2 * Math.PI, n = this._endAngle - this._startAngle, s = Math.abs(n) < Number.EPSILON; n < 0;)n += i; for (;n > i;)n -= i; n < Number.EPSILON && (n = s ? 0 : i), this._clockwise && !s && (n === i ? n = -i : n -= i); const r = this._startAngle + t * n; let o = this.p0.x + this._xRadius * Math.cos(r); let a = this.p0.y + this._yRadius * Math.sin(r); if (this._rotation !== 0) { const l = Math.cos(this._rotation); const u = Math.sin(this._rotation); const c = o - this.p0.x; const d = a - this.p0.y; o = c * l - d * u + this.p0.x, a = c * u + d * l + this.p0.y; } return e.set(o, a); },
    setXRadius(t) { return this.xRadius = t, this; },
    setYRadius(t) { return this.yRadius = t, this; },
    setWidth(t) { return this.xRadius = 2 * t, this; },
    setHeight(t) { return this.yRadius = 2 * t, this; },
    setStartAngle(t) { return this.startAngle = t, this; },
    setEndAngle(t) { return this.endAngle = t, this; },
    setClockwise(t) { return this.clockwise = t, this; },
    setRotation(t) { return this.rotation = t, this; },
    x: { get() { return this.p0.x; }, set(t) { this.p0.x = t; } },
    y: { get() { return this.p0.y; }, set(t) { this.p0.y = t; } },
    xRadius: { get() { return this._xRadius; }, set(t) { this._xRadius = t; } },
    yRadius: { get() { return this._yRadius; }, set(t) { this._yRadius = t; } },
    startAngle: { get() { return a(this._startAngle); }, set(t) { this._startAngle = r(t); } },
    endAngle: { get() { return a(this._endAngle); }, set(t) { this._endAngle = r(t); } },
    clockwise: { get() { return this._clockwise; }, set(t) { this._clockwise = t; } },
    rotation: { get() { return this._rotation; }, set(t) { this._rotation = r(t); } },
    toJSON() {
      return {
        type: this.type, x: this.p0.x, y: this.p0.y, xRadius: this._xRadius, yRadius: this._yRadius, startAngle: a(this._startAngle), endAngle: a(this._endAngle), clockwise: this._clockwise, rotation: a(this._rotation),
      };
    },
  }); l.fromJSON = function (t) { return new l(t); }, t.exports = l;
}, function (t, e) { t.exports = function (t, e, i, n, s) { return (function (t, e) { const i = 1 - t; return i * i * i * e; }(t, e)) + (function (t, e) { const i = 1 - t; return 3 * i * i * t * e; }(t, i)) + (function (t, e) { return 3 * (1 - t) * t * t * e; }(t, n)) + (function (t, e) { return t * t * t * e; }(t, s)); }; }, function (t, e, i) {
  const n = i(0); const s = i(543); const r = i(85); const o = i(7); const a = new n({
    Extends: r, initialize(t, e, i, n) { r.call(this, 'CubicBezierCurve'), Array.isArray(t) && (n = new o(t[6], t[7]), i = new o(t[4], t[5]), e = new o(t[2], t[3]), t = new o(t[0], t[1])), this.p0 = t, this.p1 = e, this.p2 = i, this.p3 = n; }, getStartPoint(t) { return void 0 === t && (t = new o()), t.copy(this.p0); }, getResolution(t) { return t; }, getPoint(t, e) { void 0 === e && (e = new o()); const i = this.p0; const n = this.p1; const r = this.p2; const a = this.p3; return e.set(s(t, i.x, n.x, r.x, a.x), s(t, i.y, n.y, r.y, a.y)); }, draw(t, e) { void 0 === e && (e = 32); const i = this.getPoints(e); t.beginPath(), t.moveTo(this.p0.x, this.p0.y); for (let n = 1; n < i.length; n++)t.lineTo(i[n].x, i[n].y); return t.strokePath(), t; }, toJSON() { return { type: this.type, points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y, this.p2.x, this.p2.y, this.p3.x, this.p3.y] }; },
  }); a.fromJSON = function (t) { const e = t.points; const i = new o(e[0], e[1]); const n = new o(e[2], e[3]); const s = new o(e[4], e[5]); const r = new o(e[6], e[7]); return new a(i, n, s, r); }, t.exports = a;
}, function (t, e, i) {
  const n = i(279); const s = i(0); const r = new (i(86))(); const o = new s({
    Extends: n, initialize(t, e, i, s) { void 0 === e && (e = 80), void 0 === i && (i = 0), void 0 === s && (s = 0), n.call(this, t), this.viewportWidth = i, this.viewportHeight = s, this.fieldOfView = e * Math.PI / 180, this.update(); }, setFOV(t) { return this.fieldOfView = t * Math.PI / 180, this; }, update() { const t = this.viewportWidth / this.viewportHeight; return this.projection.perspective(this.fieldOfView, t, Math.abs(this.near), Math.abs(this.far)), r.copy(this.position).add(this.direction), this.view.lookAt(this.position, r, this.up), this.combined.copy(this.projection).multiply(this.view), this.invProjectionView.copy(this.combined).invert(), this.billboardMatrixDirty = !0, this.updateChildren(), this; },
  }); t.exports = o;
}, function (t, e, i) {
  const n = i(279); const s = i(0); const r = new (i(86))(); const o = new s({
    Extends: n, initialize(t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = 0), n.call(this, t), this.viewportWidth = e, this.viewportHeight = i, this._zoom = 1, this.near = 0, this.update(); }, setToOrtho(t, e, i) { void 0 === e && (e = this.viewportWidth), void 0 === i && (i = this.viewportHeight); const n = this.zoom; return this.up.set(0, t ? -1 : 1, 0), this.direction.set(0, 0, t ? 1 : -1), this.position.set(n * e / 2, n * i / 2, 0), this.viewportWidth = e, this.viewportHeight = i, this.update(); }, update() { const t = this.viewportWidth; const e = this.viewportHeight; const i = Math.abs(this.near); const n = Math.abs(this.far); const s = this.zoom; return t === 0 || e === 0 ? this : (this.projection.ortho(s * -t / 2, s * t / 2, s * -e / 2, s * e / 2, i, n), r.copy(this.position).add(this.direction), this.view.lookAt(this.position, r, this.up), this.combined.copy(this.projection).multiply(this.view), this.invProjectionView.copy(this.combined).invert(), this.billboardMatrixDirty = !0, this.updateChildren(), this); }, zoom: { get() { return this._zoom; }, set(t) { this._zoom = t, this.update(); } },
  }); t.exports = o;
}, function (t, e, i) { const n = i(2); t.exports = function (t, e, i, s, r) { n.RENDER_MASK !== e.renderFlags || e.cameraFilter > 0 && e.cameraFilter & s._id || t.drawImage(e, s, r); }; }, function (t, e, i) { const n = i(2); t.exports = function (t, e, i, s, r) { n.RENDER_MASK !== e.renderFlags || e.cameraFilter > 0 && e.cameraFilter & s._id || this.pipeline.batchSprite(e, s, r); }; }, function (t, e, i) { let n = i(3); let s = i(3); n = i(548), s = i(547), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) {
  var n = new (i(0))({
    initialize(t) { this.val = new Float32Array(9), t ? this.copy(t) : this.identity(); }, clone() { return new n(this); }, set(t) { return this.copy(t); }, copy(t) { const e = this.val; const i = t.val; return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this; }, fromMat4(t) { const e = t.val; const i = this.val; return i[0] = e[0], i[1] = e[1], i[2] = e[2], i[3] = e[4], i[4] = e[5], i[5] = e[6], i[6] = e[8], i[7] = e[9], i[8] = e[10], this; }, fromArray(t) { const e = this.val; return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], this; }, identity() { const t = this.val; return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, this; }, transpose() { const t = this.val; const e = t[1]; const i = t[2]; const n = t[5]; return t[1] = t[3], t[2] = t[6], t[3] = e, t[5] = t[7], t[6] = i, t[7] = n, this; }, invert() { const t = this.val; const e = t[0]; const i = t[1]; const n = t[2]; const s = t[3]; const r = t[4]; const o = t[5]; const a = t[6]; const h = t[7]; const l = t[8]; const u = l * r - o * h; const c = -l * s + o * a; const d = h * s - r * a; let f = e * u + i * c + n * d; return f ? (f = 1 / f, t[0] = u * f, t[1] = (-l * i + n * h) * f, t[2] = (o * i - n * r) * f, t[3] = c * f, t[4] = (l * e - n * a) * f, t[5] = (-o * e + n * s) * f, t[6] = d * f, t[7] = (-h * e + i * a) * f, t[8] = (r * e - i * s) * f, this) : null; }, adjoint() { const t = this.val; const e = t[0]; const i = t[1]; const n = t[2]; const s = t[3]; const r = t[4]; const o = t[5]; const a = t[6]; const h = t[7]; const l = t[8]; return t[0] = r * l - o * h, t[1] = n * h - i * l, t[2] = i * o - n * r, t[3] = o * a - s * l, t[4] = e * l - n * a, t[5] = n * s - e * o, t[6] = s * h - r * a, t[7] = i * a - e * h, t[8] = e * r - i * s, this; }, determinant() { const t = this.val; const e = t[0]; const i = t[1]; const n = t[2]; const s = t[3]; const r = t[4]; const o = t[5]; const a = t[6]; const h = t[7]; const l = t[8]; return e * (l * r - o * h) + i * (-l * s + o * a) + n * (h * s - r * a); }, multiply(t) { const e = this.val; const i = e[0]; const n = e[1]; const s = e[2]; const r = e[3]; const o = e[4]; const a = e[5]; const h = e[6]; const l = e[7]; const u = e[8]; const c = t.val; const d = c[0]; const f = c[1]; const p = c[2]; const g = c[3]; const v = c[4]; const y = c[5]; const m = c[6]; const x = c[7]; const w = c[8]; return e[0] = d * i + f * r + p * h, e[1] = d * n + f * o + p * l, e[2] = d * s + f * a + p * u, e[3] = g * i + v * r + y * h, e[4] = g * n + v * o + y * l, e[5] = g * s + v * a + y * u, e[6] = m * i + x * r + w * h, e[7] = m * n + x * o + w * l, e[8] = m * s + x * a + w * u, this; }, translate(t) { const e = this.val; const i = t.x; const n = t.y; return e[6] = i * e[0] + n * e[3] + e[6], e[7] = i * e[1] + n * e[4] + e[7], e[8] = i * e[2] + n * e[5] + e[8], this; }, rotate(t) { const e = this.val; const i = e[0]; const n = e[1]; const s = e[2]; const r = e[3]; const o = e[4]; const a = e[5]; const h = Math.sin(t); const l = Math.cos(t); return e[0] = l * i + h * r, e[1] = l * n + h * o, e[2] = l * s + h * a, e[3] = l * r - h * i, e[4] = l * o - h * n, e[5] = l * a - h * s, this; }, scale(t) { const e = this.val; const i = t.x; const n = t.y; return e[0] = i * e[0], e[1] = i * e[1], e[2] = i * e[2], e[3] = n * e[3], e[4] = n * e[4], e[5] = n * e[5], this; }, fromQuat(t) { const e = t.x; const i = t.y; const n = t.z; const s = t.w; const r = e + e; const o = i + i; const a = n + n; const h = e * r; const l = e * o; const u = e * a; const c = i * o; const d = i * a; const f = n * a; const p = s * r; const g = s * o; const v = s * a; const y = this.val; return y[0] = 1 - (c + f), y[3] = l + v, y[6] = u - g, y[1] = l - v, y[4] = 1 - (h + f), y[7] = d + p, y[2] = u + g, y[5] = d - p, y[8] = 1 - (h + c), this; }, normalFromMat4(t) { const e = t.val; const i = this.val; const n = e[0]; const s = e[1]; const r = e[2]; const o = e[3]; const a = e[4]; const h = e[5]; const l = e[6]; const u = e[7]; const c = e[8]; const d = e[9]; const f = e[10]; const p = e[11]; const g = e[12]; const v = e[13]; const y = e[14]; const m = e[15]; const x = n * h - s * a; const w = n * l - r * a; const b = n * u - o * a; const T = s * l - r * h; const S = s * u - o * h; const A = r * u - o * l; const C = c * v - d * g; const M = c * y - f * g; const _ = c * m - p * g; const E = d * y - f * v; const P = d * m - p * v; const L = f * m - p * y; let F = x * L - w * P + b * E + T * _ - S * M + A * C; return F ? (F = 1 / F, i[0] = (h * L - l * P + u * E) * F, i[1] = (l * _ - a * L - u * M) * F, i[2] = (a * P - h * _ + u * C) * F, i[3] = (r * P - s * L - o * E) * F, i[4] = (n * L - r * _ + o * M) * F, i[5] = (s * _ - n * P - o * C) * F, i[6] = (v * A - y * S + m * T) * F, i[7] = (y * b - g * A - m * w) * F, i[8] = (g * S - v * b + m * x) * F, this) : null; },
  }); t.exports = n;
}, function (t, e, i) {
  const n = i(0); const s = i(86); const r = i(550); const o = new Int8Array([1, 2, 0]); const a = new Float32Array([0, 0, 0]); const h = new s(1, 0, 0); const l = new s(0, 1, 0); const u = new s(); const c = new r(); const d = new n({
    initialize(t, e, i, n) { typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0, this.w = t.w || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = n || 0); }, copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w, this; }, set(t, e, i, n) { return typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0, this.w = t.w || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = n || 0), this; }, add(t) { return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this; }, subtract(t) { return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this; }, scale(t) { return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this; }, length() { const t = this.x; const e = this.y; const i = this.z; const n = this.w; return Math.sqrt(t * t + e * e + i * i + n * n); }, lengthSq() { const t = this.x; const e = this.y; const i = this.z; const n = this.w; return t * t + e * e + i * i + n * n; }, normalize() { const t = this.x; const e = this.y; const i = this.z; const n = this.w; let s = t * t + e * e + i * i + n * n; return s > 0 && (s = 1 / Math.sqrt(s), this.x = t * s, this.y = e * s, this.z = i * s, this.w = n * s), this; }, dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w; }, lerp(t, e) { void 0 === e && (e = 0); const i = this.x; const n = this.y; const s = this.z; const r = this.w; return this.x = i + e * (t.x - i), this.y = n + e * (t.y - n), this.z = s + e * (t.z - s), this.w = r + e * (t.w - r), this; }, rotationTo(t, e) { const i = t.x * e.x + t.y * e.y + t.z * e.z; return i < -0.999999 ? (u.copy(h).cross(t).length() < 1e-6 && u.copy(l).cross(t), u.normalize(), this.setAxisAngle(u, Math.PI)) : i > 0.999999 ? (this.x = 0, this.y = 0, this.z = 0, this.w = 1, this) : (u.copy(t).cross(e), this.x = u.x, this.y = u.y, this.z = u.z, this.w = 1 + i, this.normalize()); }, setAxes(t, e, i) { const n = c.val; return n[0] = e.x, n[3] = e.y, n[6] = e.z, n[1] = i.x, n[4] = i.y, n[7] = i.z, n[2] = -t.x, n[5] = -t.y, n[8] = -t.z, this.fromMat3(c).normalize(); }, identity() { return this.x = 0, this.y = 0, this.z = 0, this.w = 1, this; }, setAxisAngle(t, e) { e *= 0.5; const i = Math.sin(e); return this.x = i * t.x, this.y = i * t.y, this.z = i * t.z, this.w = Math.cos(e), this; }, multiply(t) { const e = this.x; const i = this.y; const n = this.z; const s = this.w; const r = t.x; const o = t.y; const a = t.z; const h = t.w; return this.x = e * h + s * r + i * a - n * o, this.y = i * h + s * o + n * r - e * a, this.z = n * h + s * a + e * o - i * r, this.w = s * h - e * r - i * o - n * a, this; }, slerp(t, e) { const i = this.x; const n = this.y; const s = this.z; const r = this.w; let o = t.x; let a = t.y; let h = t.z; let l = t.w; let u = i * o + n * a + s * h + r * l; u < 0 && (u = -u, o = -o, a = -a, h = -h, l = -l); let c = 1 - e; let d = e; if (1 - u > 1e-6) { const f = Math.acos(u); const p = Math.sin(f); c = Math.sin((1 - e) * f) / p, d = Math.sin(e * f) / p; } return this.x = c * i + d * o, this.y = c * n + d * a, this.z = c * s + d * h, this.w = c * r + d * l, this; }, invert() { const t = this.x; const e = this.y; const i = this.z; const n = this.w; const s = t * t + e * e + i * i + n * n; const r = s ? 1 / s : 0; return this.x = -t * r, this.y = -e * r, this.z = -i * r, this.w = n * r, this; }, conjugate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this; }, rotateX(t) { t *= 0.5; const e = this.x; const i = this.y; const n = this.z; const s = this.w; const r = Math.sin(t); const o = Math.cos(t); return this.x = e * o + s * r, this.y = i * o + n * r, this.z = n * o - i * r, this.w = s * o - e * r, this; }, rotateY(t) { t *= 0.5; const e = this.x; const i = this.y; const n = this.z; const s = this.w; const r = Math.sin(t); const o = Math.cos(t); return this.x = e * o - n * r, this.y = i * o + s * r, this.z = n * o + e * r, this.w = s * o - i * r, this; }, rotateZ(t) { t *= 0.5; const e = this.x; const i = this.y; const n = this.z; const s = this.w; const r = Math.sin(t); const o = Math.cos(t); return this.x = e * o + i * r, this.y = i * o - e * r, this.z = n * o + s * r, this.w = s * o - n * r, this; }, calculateW() { const t = this.x; const e = this.y; const i = this.z; return this.w = -Math.sqrt(Math.abs(1 - t * t - e * e - i * i)), this; }, fromMat3(t) { let e; const i = t.val; const n = i[0] + i[4] + i[8]; if (n > 0)e = Math.sqrt(n + 1), this.w = 0.5 * e, e = 0.5 / e, this.x = (i[7] - i[5]) * e, this.y = (i[2] - i[6]) * e, this.z = (i[3] - i[1]) * e; else { let s = 0; i[4] > i[0] && (s = 1), i[8] > i[3 * s + s] && (s = 2); const r = o[s]; const h = o[r]; e = Math.sqrt(i[3 * s + s] - i[3 * r + r] - i[3 * h + h] + 1), a[s] = 0.5 * e, e = 0.5 / e, a[r] = (i[3 * r + s] + i[3 * s + r]) * e, a[h] = (i[3 * h + s] + i[3 * s + h]) * e, this.x = a[0], this.y = a[1], this.z = a[2], this.w = (i[3 * h + r] - i[3 * r + h]) * e; } return this; },
  }); t.exports = d;
}, function (t, e, i) { const n = i(86); const s = i(278); const r = i(551); const o = new s(); const a = new r(); const h = new n(); t.exports = function (t, e, i) { return a.setAxisAngle(e, i), o.fromRotationTranslation(a, h.set(0, 0, 0)), t.transformMat4(o); }; }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = 1), t.x = (2 * Math.random() - 1) * e, t.y = (2 * Math.random() - 1) * e, t.z = (2 * Math.random() - 1) * e, t.w = (2 * Math.random() - 1) * e, t; }; }, function (t, e) { t.exports = function (t, e) { void 0 === e && (e = 1); const i = 2 * Math.random() * Math.PI; const n = 2 * Math.random() - 1; const s = Math.sqrt(1 - n * n) * e; return t.x = Math.cos(i) * s, t.y = Math.sin(i) * s, t.z = n * e, t; }; }, function (t, e, i) {
  const n = i(121); const s = i(0); const r = i(1); const o = i(12); const a = i(31); const h = new s({
    initialize(t) { this.scene = t, this.systems = t.sys, this.currentCameraId = 1, this.cameras = [], this.cameraPool = [], this.main, this.baseScale = 1, t.sys.events.once('boot', this.boot, this), t.sys.events.on('start', this.start, this); }, boot() { const t = this.systems; t.settings.cameras ? this.fromJSON(t.settings.cameras) : this.add(), this.main = this.cameras[0], this.systems.events.once('destroy', this.destroy, this); }, start() { this.main || this.boot(); const t = this.systems.events; t.on('update', this.update, this), t.once('shutdown', this.shutdown, this); }, add(t, e, i, s, r, o) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.scene.sys.game.config.width), void 0 === s && (s = this.scene.sys.game.config.height), void 0 === r && (r = !1), void 0 === o && (o = ''); let a = null; return this.cameraPool.length > 0 ? (a = this.cameraPool.pop()).setViewport(t, e, i, s) : a = new n(t, e, i, s), a.setName(o), a.setScene(this.scene), this.cameras.push(a), r && (this.main = a), a._id = this.currentCameraId, this.currentCameraId <<= 1, a; }, addExisting(t) { const e = this.cameras.indexOf(t); const i = this.cameraPool.indexOf(t); return e < 0 && i >= 0 ? (this.cameras.push(t), this.cameraPool.slice(i, 1), t) : null; }, fromJSON(t) { Array.isArray(t) || (t = [t]); for (let e = this.scene.sys.game.config.width, i = this.scene.sys.game.config.height, n = 0; n < t.length; n++) { const s = t[n]; const o = r(s, 'x', 0); const a = r(s, 'y', 0); const h = r(s, 'width', e); const l = r(s, 'height', i); const u = this.add(o, a, h, l); u.name = r(s, 'name', ''), u.zoom = r(s, 'zoom', 1), u.rotation = r(s, 'rotation', 0), u.scrollX = r(s, 'scrollX', 0), u.scrollY = r(s, 'scrollY', 0), u.roundPixels = r(s, 'roundPixels', !1); const c = r(s, 'backgroundColor', !1); c && u.setBackgroundColor(c); const d = r(s, 'bounds', null); if (d) { const f = r(d, 'x', 0); const p = r(d, 'y', 0); const g = r(d, 'width', e); const v = r(d, 'height', i); u.setBounds(f, p, g, v); } } return this; }, getCamera(t) { for (let e = 0; e < this.cameras.length; e++) if (this.cameras[e].name === t) return this.cameras[e]; return null; }, getCameraBelowPointer(t) { for (let e = this.cameras, i = e.length - 1; i >= 0; i--) { const n = e[i]; if (n.inputEnabled && a(n, t.x, t.y)) return n; } }, remove(t) { const e = this.cameras.indexOf(t); e >= 0 && this.cameras.length > 1 && (this.cameraPool.push(this.cameras[e]), this.cameras.splice(e, 1), this.main === t && (this.main = this.cameras[0])); }, render(t, e, i) { for (let n = this.cameras, s = this.baseScale, r = 0, o = n.length; r < o; ++r) { const a = n[r]; a.preRender(s, t.config.resolution), t.render(this.scene, e, i, a); } }, resetAll() { for (;this.cameras.length > 0;) this.cameraPool.push(this.cameras.pop()); return this.main = this.add(), this.main; }, update(t, e) { for (let i = 0, n = this.cameras.length; i < n; ++i) this.cameras[i].update(t, e); }, resize(t, e) { for (let i = 0, n = this.cameras.length; i < n; ++i) this.cameras[i].setSize(t, e); }, shutdown() { this.main = void 0; for (var t = 0; t < this.cameras.length; t++) this.cameras[t].destroy(); for (t = 0; t < this.cameraPool.length; t++) this.cameraPool[t].destroy(); this.cameras = [], this.cameraPool = []; const e = this.systems.events; e.off('update', this.update, this), e.off('shutdown', this.shutdown, this); }, destroy() { this.shutdown(), this.scene.sys.events.off('start', this.start, this), this.scene = null, this.systems = null; },
  }); o.register('CameraManager', h, 'cameras'), t.exports = h;
}, function (t, e, i) {
  const n = i(23); const s = i(0); const r = i(7); const o = new s({
    initialize(t) { this.camera = t, this.isRunning = !1, this.duration = 0, this.intensity = new r(), this.progress = 0, this._elapsed = 0, this._offsetX = 0, this._offsetY = 0, this._onUpdate, this._onUpdateScope; }, start(t, e, i, n, s) { return void 0 === t && (t = 100), void 0 === e && (e = 0.05), void 0 === i && (i = !1), void 0 === n && (n = null), void 0 === s && (s = this.camera.scene), !i && this.isRunning ? this.camera : (this.isRunning = !0, this.duration = t, this.progress = 0, typeof e === 'number' ? this.intensity.set(e) : this.intensity.set(e.x, e.y), this._elapsed = 0, this._offsetX = 0, this._offsetY = 0, this._onUpdate = n, this._onUpdateScope = s, this.camera.emit('camerashakestart', this.camera, this, t, e), this.camera); }, preRender() { this.isRunning && this.camera.matrix.translate(this._offsetX, this._offsetY); }, update(t, e) { if (this.isRunning) if (this._elapsed += e, this.progress = n(this._elapsed / this.duration, 0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress), this._elapsed < this.duration) { const i = this.intensity; const s = this.camera.width; const r = this.camera.height; const o = this.camera.zoom; this._offsetX = (Math.random() * i.x * s * 2 - i.x * s) * o, this._offsetY = (Math.random() * i.y * r * 2 - i.y * r) * o, this.camera.roundPixels && (this._offsetX |= 0, this._offsetY |= 0); } else this.effectComplete(); }, effectComplete() { this._offsetX = 0, this._offsetY = 0, this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit('camerashakecomplete', this.camera, this); }, reset() { this.isRunning = !1, this._offsetX = 0, this._offsetY = 0, this._onUpdate = null, this._onUpdateScope = null; }, destroy() { this.reset(), this.camera = null, this.intensity = null; },
  }); t.exports = o;
}, function (t, e, i) {
  const n = i(23); const s = new (i(0))({
    initialize(t) { this.camera = t, this.isRunning = !1, this.duration = 0, this.red = 0, this.green = 0, this.blue = 0, this.alpha = 0, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope; }, start(t, e, i, n, s, r, o) { return void 0 === t && (t = 250), void 0 === e && (e = 255), void 0 === i && (i = 255), void 0 === n && (n = 255), void 0 === s && (s = !1), void 0 === r && (r = null), void 0 === o && (o = this.camera.scene), !s && this.isRunning ? this.camera : (this.isRunning = !0, this.duration = t, this.progress = 0, this.red = e, this.green = i, this.blue = n, this.alpha = 1, this._elapsed = 0, this._onUpdate = r, this._onUpdateScope = o, this.camera.emit('cameraflashstart', this.camera, this, t, e, i, n), this.camera); }, update(t, e) { this.isRunning && (this._elapsed += e, this.progress = n(this._elapsed / this.duration, 0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress), this._elapsed < this.duration ? this.alpha = 1 - this.progress : this.effectComplete()); }, postRenderCanvas(t) { if (!this.isRunning) return !1; const e = this.camera; return t.fillStyle = `rgba(${this.red},${this.green},${this.blue},${this.alpha})`, t.fillRect(e.x, e.y, e.width, e.height), !0; }, postRenderWebGL(t, e) { if (!this.isRunning) return !1; const i = this.camera; const n = this.red / 255; const s = this.blue / 255; const r = this.green / 255; return t.batchFillRect(0, 0, 1, 1, 0, i.x, i.y, i.width, i.height, e(n, r, s, 1), this.alpha, 1, 0, 0, 1, 0, 0, [1, 0, 0, 1, 0, 0]), !0; }, effectComplete() { this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit('cameraflashcomplete', this.camera, this); }, reset() { this.isRunning = !1, this._onUpdate = null, this._onUpdateScope = null; }, destroy() { this.reset(), this.camera = null; },
  }); t.exports = s;
}, function (t, e, i) {
  const n = i(23); const s = new (i(0))({
    initialize(t) { this.camera = t, this.isRunning = !1, this.isComplete = !1, this.direction = !0, this.duration = 0, this.red = 0, this.green = 0, this.blue = 0, this.alpha = 0, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope; }, start(t, e, i, n, s, r, o, a) { if (void 0 === t && (t = !0), void 0 === e && (e = 1e3), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = !1), void 0 === o && (o = null), void 0 === a && (a = this.camera.scene), !r && this.isRunning) return this.camera; this.isRunning = !0, this.isComplete = !1, this.duration = e, this.direction = t, this.progress = 0, this.red = i, this.green = n, this.blue = s, this.alpha = t ? Number.MIN_VALUE : 1, this._elapsed = 0, this._onUpdate = o, this._onUpdateScope = a; const h = t ? 'camerafadeoutstart' : 'camerafadeinstart'; return this.camera.emit(h, this.camera, this, e, i, n, s), this.camera; }, update(t, e) { this.isRunning && (this._elapsed += e, this.progress = n(this._elapsed / this.duration, 0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress), this._elapsed < this.duration ? this.alpha = this.direction ? this.progress : 1 - this.progress : this.effectComplete()); }, postRenderCanvas(t) { if (!this.isRunning && !this.isComplete) return !1; const e = this.camera; return t.fillStyle = `rgba(${this.red},${this.green},${this.blue},${this.alpha})`, t.fillRect(e.x, e.y, e.width, e.height), !0; }, postRenderWebGL(t, e) { if (!this.isRunning && !this.isComplete) return !1; const i = this.camera; const n = this.red / 255; const s = this.blue / 255; const r = this.green / 255; return t.batchFillRect(0, 0, 1, 1, 0, i.x, i.y, i.width, i.height, e(n, r, s, 1), this.alpha, 1, 0, 0, 1, 0, 0, [1, 0, 0, 1, 0, 0]), !0; }, effectComplete() { this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.isComplete = !0; const t = this.direction ? 'camerafadeoutcomplete' : 'camerafadeincomplete'; this.camera.emit(t, this.camera, this); }, reset() { this.isRunning = !1, this.isComplete = !1, this._onUpdate = null, this._onUpdateScope = null; }, destroy() { this.reset(), this.camera = null; },
  }); t.exports = s;
}, function (t, e, i) { t.exports = { Camera: i(121), CameraManager: i(555), Effects: i(202) }; }, function (t, e, i) {
  const n = i(0); const s = i(4); const r = new n({
    initialize(t) { this.camera = s(t, 'camera', null), this.left = s(t, 'left', null), this.right = s(t, 'right', null), this.up = s(t, 'up', null), this.down = s(t, 'down', null), this.zoomIn = s(t, 'zoomIn', null), this.zoomOut = s(t, 'zoomOut', null), this.zoomSpeed = s(t, 'zoomSpeed', 0.01), this.accelX = 0, this.accelY = 0; const e = s(t, 'acceleration', null); typeof e === 'number' ? (this.accelX = e, this.accelY = e) : (this.accelX = s(t, 'acceleration.x', 0), this.accelY = s(t, 'acceleration.y', 0)), this.dragX = 0, this.dragY = 0; const i = s(t, 'drag', null); typeof i === 'number' ? (this.dragX = i, this.dragY = i) : (this.dragX = s(t, 'drag.x', 0), this.dragY = s(t, 'drag.y', 0)), this.maxSpeedX = 0, this.maxSpeedY = 0; const n = s(t, 'maxSpeed', null); typeof n === 'number' ? (this.maxSpeedX = n, this.maxSpeedY = n) : (this.maxSpeedX = s(t, 'maxSpeed.x', 0), this.maxSpeedY = s(t, 'maxSpeed.y', 0)), this._speedX = 0, this._speedY = 0, this._zoom = 0, this.active = this.camera !== null; }, start() { return this.active = this.camera !== null, this; }, stop() { return this.active = !1, this; }, setCamera(t) { return this.camera = t, this; }, update(t) { if (this.active) { void 0 === t && (t = 1); const e = this.camera; this._speedX > 0 ? (this._speedX -= this.dragX * t, this._speedX < 0 && (this._speedX = 0)) : this._speedX < 0 && (this._speedX += this.dragX * t, this._speedX > 0 && (this._speedX = 0)), this._speedY > 0 ? (this._speedY -= this.dragY * t, this._speedY < 0 && (this._speedY = 0)) : this._speedY < 0 && (this._speedY += this.dragY * t, this._speedY > 0 && (this._speedY = 0)), this.up && this.up.isDown ? (this._speedY += this.accelY, this._speedY > this.maxSpeedY && (this._speedY = this.maxSpeedY)) : this.down && this.down.isDown && (this._speedY -= this.accelY, this._speedY < -this.maxSpeedY && (this._speedY = -this.maxSpeedY)), this.left && this.left.isDown ? (this._speedX += this.accelX, this._speedX > this.maxSpeedX && (this._speedX = this.maxSpeedX)) : this.right && this.right.isDown && (this._speedX -= this.accelX, this._speedX < -this.maxSpeedX && (this._speedX = -this.maxSpeedX)), this.zoomIn && this.zoomIn.isDown ? this._zoom = -this.zoomSpeed : this.zoomOut && this.zoomOut.isDown ? this._zoom = this.zoomSpeed : this._zoom = 0, this._speedX !== 0 && (e.scrollX -= this._speedX * t | 0), this._speedY !== 0 && (e.scrollY -= this._speedY * t | 0), this._zoom !== 0 && (e.zoom += this._zoom, e.zoom < 0.1 && (e.zoom = 0.1)); } }, destroy() { this.camera = null, this.left = null, this.right = null, this.up = null, this.down = null, this.zoomIn = null, this.zoomOut = null; },
  }); t.exports = r;
}, function (t, e, i) {
  const n = i(0); const s = i(4); const r = new n({
    initialize(t) { this.camera = s(t, 'camera', null), this.left = s(t, 'left', null), this.right = s(t, 'right', null), this.up = s(t, 'up', null), this.down = s(t, 'down', null), this.zoomIn = s(t, 'zoomIn', null), this.zoomOut = s(t, 'zoomOut', null), this.zoomSpeed = s(t, 'zoomSpeed', 0.01), this.speedX = 0, this.speedY = 0; const e = s(t, 'speed', null); typeof e === 'number' ? (this.speedX = e, this.speedY = e) : (this.speedX = s(t, 'speed.x', 0), this.speedY = s(t, 'speed.y', 0)), this._zoom = 0, this.active = this.camera !== null; }, start() { return this.active = this.camera !== null, this; }, stop() { return this.active = !1, this; }, setCamera(t) { return this.camera = t, this; }, update(t) { if (this.active) { void 0 === t && (t = 1); const e = this.camera; this.up && this.up.isDown ? e.scrollY -= this.speedY * t | 0 : this.down && this.down.isDown && (e.scrollY += this.speedY * t | 0), this.left && this.left.isDown ? e.scrollX -= this.speedX * t | 0 : this.right && this.right.isDown && (e.scrollX += this.speedX * t | 0), this.zoomIn && this.zoomIn.isDown ? (e.zoom -= this.zoomSpeed, e.zoom < 0.1 && (e.zoom = 0.1)) : this.zoomOut && this.zoomOut.isDown && (e.zoom += this.zoomSpeed); } }, destroy() { this.camera = null, this.left = null, this.right = null, this.up = null, this.down = null, this.zoomIn = null, this.zoomOut = null; },
  }); t.exports = r;
}, function (t, e, i) { t.exports = { BaseCache: i(204), CacheManager: i(203) }; }, function (t, e, i) { t.exports = { Animation: i(208), AnimationFrame: i(206), AnimationManager: i(205) }; }, function (t, e) { t.exports = function (t, e, i) { void 0 === e && (e = 1), void 0 === i && (i = []); let n = Math.round(t.x1); let s = Math.round(t.y1); const r = Math.round(t.x2); const o = Math.round(t.y2); const a = Math.abs(r - n); const h = Math.abs(o - s); const l = n < r ? 1 : -1; const u = s < o ? 1 : -1; let c = a - h; i.push({ x: n, y: s }); for (let d = 1; n !== r || s !== o;) { const f = c << 1; f > -h && (c -= h, n += l), f < a && (c += a, s += u), d % e == 0 && i.push({ x: n, y: s }), d++; } return i; }; }, function (t, e, i) { const n = i(96); const s = i(5); t.exports = function (t, e, i, r) { if (void 0 === r && (r = []), !e && !i) return r; e ? i = Math.round(n(t) / e) : e = n(t) / i; for (let o = t.x, a = t.y, h = 0, l = 0; l < i; l++) switch (r.push(new s(o, a)), h) { case 0: (o += e) >= t.right && (h = 1, a += o - t.right, o = t.right); break; case 1: (a += e) >= t.bottom && (h = 2, o -= a - t.bottom, a = t.bottom); break; case 2: (o -= e) <= t.left && (h = 3, a -= t.left - o, o = t.left); break; case 3: (a -= e) <= t.top && (h = 0, a = t.top); } return r; }; }, function (t, e) { const i = { _visible: !0, visible: { get() { return this._visible; }, set(t) { t ? (this._visible = !0, this.renderFlags |= 1) : (this._visible = !1, this.renderFlags &= -2); } }, setVisible(t) { return this.visible = t, this; } }; t.exports = i; }, function (t, e, i) {
  const n = i(16); const s = i(63); const r = i(210); const o = i(209); const a = {
    _scaleX: 1, _scaleY: 1, _rotation: 0, x: 0, y: 0, z: 0, w: 0, scaleX: { get() { return this._scaleX; }, set(t) { this._scaleX = t, this._scaleX === 0 ? this.renderFlags &= -5 : this.renderFlags |= 4; } }, scaleY: { get() { return this._scaleY; }, set(t) { this._scaleY = t, this._scaleY === 0 ? this.renderFlags &= -5 : this.renderFlags |= 4; } }, angle: { get() { return o(this._rotation * n.RAD_TO_DEG); }, set(t) { this.rotation = o(t) * n.DEG_TO_RAD; } }, rotation: { get() { return this._rotation; }, set(t) { this._rotation = r(t); } }, setPosition(t, e, i, n) { return void 0 === t && (t = 0), void 0 === e && (e = t), void 0 === i && (i = 0), void 0 === n && (n = 0), this.x = t, this.y = e, this.z = i, this.w = n, this; }, setRandomPosition(t, e, i, n) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.scene.sys.game.config.width), void 0 === n && (n = this.scene.sys.game.config.height), this.x = t + Math.random() * i, this.y = e + Math.random() * n, this; }, setRotation(t) { return void 0 === t && (t = 0), this.rotation = t, this; }, setAngle(t) { return void 0 === t && (t = 0), this.angle = t, this; }, setScale(t, e) { return void 0 === t && (t = 1), void 0 === e && (e = t), this.scaleX = t, this.scaleY = e, this; }, setX(t) { return void 0 === t && (t = 0), this.x = t, this; }, setY(t) { return void 0 === t && (t = 0), this.y = t, this; }, setZ(t) { return void 0 === t && (t = 0), this.z = t, this; }, setW(t) { return void 0 === t && (t = 0), this.w = t, this; }, getLocalTransformMatrix(t) { return void 0 === t && (t = new s()), t.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY); }, getWorldTransformMatrix(t) { void 0 === t && (t = new s()); let e = this.parentContainer; if (!e) return this.getLocalTransformMatrix(t); for (var i = []; e;)i.unshift(e), e = e.parentContainer; t.loadIdentity(); for (let n = i.length, r = 0; r < n; ++r)e = i[r], t.translate(e.x, e.y), t.rotate(e.rotation), t.scale(e.scaleX, e.scaleY); return t.translate(this.x, this.y), t.rotate(this._rotation), t.scale(this._scaleX, this._scaleY), t; },
  }; t.exports = a;
}, function (t, e) {
  t.exports = function (t) {
    const e = {
      name: t.name, type: t.type, x: t.x, y: t.y, depth: t.depth, scale: { x: t.scaleX, y: t.scaleY }, origin: { x: t.originX, y: t.originY }, flipX: t.flipX, flipY: t.flipY, rotation: t.rotation, alpha: t.alpha, visible: t.visible, scaleMode: t.scaleMode, blendMode: t.blendMode, textureKey: '', frameKey: '', data: {},
    }; return t.texture && (e.textureKey = t.texture.key, e.frameKey = t.frame.name), e;
  };
}, function (t, e) {
  const i = function (t) { return (t >> 16) + (65280 & t) + ((255 & t) << 16); }; const n = {
    _tintTL: 16777215, _tintTR: 16777215, _tintBL: 16777215, _tintBR: 16777215, clearTint() { return this.setTint(16777215), this; }, setTint(t, e, n, s) { return void 0 === t && (t = 16777215), void 0 === e && (e = t, n = t, s = t), this._tintTL = i(t), this._tintTR = i(e), this._tintBL = i(n), this._tintBR = i(s), this; }, tintTopLeft: { get() { return this._tintTL; }, set(t) { this._tintTL = i(t); } }, tintTopRight: { get() { return this._tintTR; }, set(t) { this._tintTR = i(t); } }, tintBottomLeft: { get() { return this._tintBL; }, set(t) { this._tintBL = i(t); } }, tintBottomRight: { get() { return this._tintBR; }, set(t) { this._tintBR = i(t); } }, tint: { set(t) { this.setTint(t, t, t, t); } },
  }; t.exports = n;
}, function (t, e) {
  const i = {
    texture: null, frame: null, setTexture(t, e) { return this.texture = this.scene.sys.textures.get(t), this.setFrame(e); }, setFrame(t, e, i) { return void 0 === e && (e = !0), void 0 === i && (i = !0), this.frame = this.texture.get(t), this.frame.cutWidth && this.frame.cutHeight ? this.renderFlags |= 8 : this.renderFlags &= -9, this._sizeComponent && e && this.setSizeToFrame(), this._originComponent && i && (this.frame.customPivot ? this.setOrigin(this.frame.pivotX, this.frame.pivotY) : this.updateDisplayOrigin()), this; },
  }; t.exports = i;
}, function (t, e) {
  const i = {
    _sizeComponent: !0, width: 0, height: 0, displayWidth: { get() { return this.scaleX * this.frame.realWidth; }, set(t) { this.scaleX = t / this.frame.realWidth; } }, displayHeight: { get() { return this.scaleY * this.frame.realHeight; }, set(t) { this.scaleY = t / this.frame.realHeight; } }, setSizeToFrame(t) { return void 0 === t && (t = this.frame), this.width = t.realWidth, this.height = t.realHeight, this; }, setSize(t, e) { return this.width = t, this.height = e, this; }, setDisplaySize(t, e) { return this.displayWidth = t, this.displayHeight = e, this; },
  }; t.exports = i;
}, function (t, e) { const i = { scrollFactorX: 1, scrollFactorY: 1, setScrollFactor(t, e) { return void 0 === e && (e = t), this.scrollFactorX = t, this.scrollFactorY = e, this; } }; t.exports = i; }, function (t, e, i) { const n = i(58); const s = { _scaleMode: n.DEFAULT, scaleMode: { get() { return this._scaleMode; }, set(t) { t !== n.LINEAR && t !== n.NEAREST || (this._scaleMode = t); } }, setScaleMode(t) { return this.scaleMode = t, this; } }; t.exports = s; }, function (t, e) {
  const i = {
    _originComponent: !0, originX: 0.5, originY: 0.5, _displayOriginX: 0, _displayOriginY: 0, displayOriginX: { get() { return this._displayOriginX; }, set(t) { this._displayOriginX = t, this.originX = t / this.width; } }, displayOriginY: { get() { return this._displayOriginY; }, set(t) { this._displayOriginY = t, this.originY = t / this.height; } }, setOrigin(t, e) { return void 0 === t && (t = 0.5), void 0 === e && (e = t), this.originX = t, this.originY = e, this.updateDisplayOrigin(); }, setOriginFromFrame() { return this.frame && this.frame.customPivot ? (this.originX = this.frame.pivotX, this.originY = this.frame.pivotY, this.updateDisplayOrigin()) : this.setOrigin(); }, setDisplayOrigin(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.displayOriginX = t, this.displayOriginY = e, this; }, updateDisplayOrigin() { return this._displayOriginX = Math.round(this.originX * this.width), this._displayOriginY = Math.round(this.originY * this.height), this; },
  }; t.exports = i;
}, function (t, e) {
  const i = {
    matrixStack: null, currentMatrix: null, currentMatrixIndex: 0, initMatrixStack() { return this.matrixStack = new Float32Array(6e3), this.currentMatrix = new Float32Array([1, 0, 0, 1, 0, 0]), this.currentMatrixIndex = 0, this; }, save() { if (this.currentMatrixIndex >= this.matrixStack.length) return this; const t = this.matrixStack; const e = this.currentMatrix; const i = this.currentMatrixIndex; return this.currentMatrixIndex += 6, t[i + 0] = e[0], t[i + 1] = e[1], t[i + 2] = e[2], t[i + 3] = e[3], t[i + 4] = e[4], t[i + 5] = e[5], this; }, restore() { if (this.currentMatrixIndex <= 0) return this; this.currentMatrixIndex -= 6; const t = this.matrixStack; const e = this.currentMatrix; const i = this.currentMatrixIndex; return e[0] = t[i + 0], e[1] = t[i + 1], e[2] = t[i + 2], e[3] = t[i + 3], e[4] = t[i + 4], e[5] = t[i + 5], this; }, loadIdentity() { return this.setTransform(1, 0, 0, 1, 0, 0), this; }, transform(t, e, i, n, s, r) { const o = this.currentMatrix; const a = o[0]; const h = o[1]; const l = o[2]; const u = o[3]; const c = o[4]; const d = o[5]; return o[0] = a * t + l * e, o[1] = h * t + u * e, o[2] = a * i + l * n, o[3] = h * i + u * n, o[4] = a * s + l * r + c, o[5] = h * s + u * r + d, this; }, setTransform(t, e, i, n, s, r) { const o = this.currentMatrix; return o[0] = t, o[1] = e, o[2] = i, o[3] = n, o[4] = s, o[5] = r, this; }, translate(t, e) { const i = this.currentMatrix; const n = i[0]; const s = i[1]; const r = i[2]; const o = i[3]; const a = i[4]; const h = i[5]; return i[4] = n * t + r * e + a, i[5] = s * t + o * e + h, this; }, scale(t, e) { const i = this.currentMatrix; const n = i[0]; const s = i[1]; const r = i[2]; const o = i[3]; return i[0] = n * t, i[1] = s * t, i[2] = r * e, i[3] = o * e, this; }, rotate(t) { const e = this.currentMatrix; const i = e[0]; const n = e[1]; const s = e[2]; const r = e[3]; const o = Math.sin(t); const a = Math.cos(t); return e[0] = i * a + s * o, e[1] = n * a + r * o, e[2] = i * -o + s * a, e[3] = n * -o + r * a, this; },
  }; t.exports = i;
}, function (t, e, i) {
  const n = i(212); const s = i(211); const r = {
    mask: null, setMask(t) { return this.mask = t, this; }, clearMask(t) { return void 0 === t && (t = !1), t && this.mask.destroy(), this.mask = null, this; }, createBitmapMask(t) { return void 0 === t && this.texture && (t = this), new n(this.scene, t); }, createGeometryMask(t) { return void 0 === t && this.type === 'Graphics' && (t = this), new s(this.scene, t); },
  }; t.exports = r;
}, function (t, e, i) {
  const n = i(14); const s = i(292); const r = i(7); const o = {
    getCenter(t) { return void 0 === t && (t = new r()), t.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2, t.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2, t; }, getTopLeft(t, e) { (t || (t = new r()), void 0 === e && (e = !1), t.x = this.x - this.displayWidth * this.originX, t.y = this.y - this.displayHeight * this.originY, this.rotation !== 0 && s(t, this.x, this.y, this.rotation), e && this.parentContainer) && this.parentContainer.getBoundsTransformMatrix().transformPoint(t.x, t.y, t); return t; }, getTopRight(t, e) { (t || (t = new r()), void 0 === e && (e = !1), t.x = this.x - this.displayWidth * this.originX + this.displayWidth, t.y = this.y - this.displayHeight * this.originY, this.rotation !== 0 && s(t, this.x, this.y, this.rotation), e && this.parentContainer) && this.parentContainer.getBoundsTransformMatrix().transformPoint(t.x, t.y, t); return t; }, getBottomLeft(t, e) { (t || (t = new r()), void 0 === e && (e = !1), t.x = this.x - this.displayWidth * this.originX, t.y = this.y - this.displayHeight * this.originY + this.displayHeight, this.rotation !== 0 && s(t, this.x, this.y, this.rotation), e && this.parentContainer) && this.parentContainer.getBoundsTransformMatrix().transformPoint(t.x, t.y, t); return t; }, getBottomRight(t, e) { (t || (t = new r()), void 0 === e && (e = !1), t.x = this.x - this.displayWidth * this.originX + this.displayWidth, t.y = this.y - this.displayHeight * this.originY + this.displayHeight, this.rotation !== 0 && s(t, this.x, this.y, this.rotation), e && this.parentContainer) && this.parentContainer.getBoundsTransformMatrix().transformPoint(t.x, t.y, t); return t; }, getBounds(t) { let e; let i; let s; let r; let o; let a; let h; let l; if (void 0 === t && (t = new n()), this.parentContainer) { const u = this.parentContainer.getBoundsTransformMatrix(); this.getTopLeft(t), u.transformPoint(t.x, t.y, t), e = t.x, i = t.y, this.getTopRight(t), u.transformPoint(t.x, t.y, t), s = t.x, r = t.y, this.getBottomLeft(t), u.transformPoint(t.x, t.y, t), o = t.x, a = t.y, this.getBottomRight(t), u.transformPoint(t.x, t.y, t), h = t.x, l = t.y; } else this.getTopLeft(t), e = t.x, i = t.y, this.getTopRight(t), s = t.x, r = t.y, this.getBottomLeft(t), o = t.x, a = t.y, this.getBottomRight(t), h = t.x, l = t.y; return t.x = Math.min(e, s, o, h), t.y = Math.min(i, r, a, l), t.width = Math.max(e, s, o, h) - t.x, t.height = Math.max(i, r, a, l) - t.y, t; },
  }; t.exports = o;
}, function (t, e) {
  t.exports = {
    flipX: !1, flipY: !1, toggleFlipX() { return this.flipX = !this.flipX, this; }, toggleFlipY() { return this.flipY = !this.flipY, this; }, setFlipX(t) { return this.flipX = t, this; }, setFlipY(t) { return this.flipY = t, this; }, setFlip(t, e) { return this.flipX = t, this.flipY = e, this; }, resetFlip() { return this.flipX = !1, this.flipY = !1, this; },
  };
}, function (t, e) { const i = { _depth: 0, depth: { get() { return this._depth; }, set(t) { this.scene.sys.queueDepthSort(), this._depth = t; } }, setDepth(t) { return void 0 === t && (t = 0), this.depth = t, this; } }; t.exports = i; }, function (t, e) {
  t.exports = {
    width: 0, height: 0, displayWidth: { get() { return this.scaleX * this.width; }, set(t) { this.scaleX = t / this.width; } }, displayHeight: { get() { return this.scaleY * this.height; }, set(t) { this.scaleY = t / this.height; } }, setSize(t, e) { return this.width = t, this.height = e, this; }, setDisplaySize(t, e) { return this.displayWidth = t, this.displayHeight = e, this; },
  };
}, function (t, e, i) { const n = i(50); const s = { _blendMode: n.NORMAL, blendMode: { get() { return this._blendMode; }, set(t) { typeof t === 'string' && (t = n[t]), (t |= 0) >= 0 && (this._blendMode = t); } }, setBlendMode(t) { return this.blendMode = t, this; } }; t.exports = s; }, function (t, e, i) {
  const n = i(23); const s = {
    _alpha: 1, _alphaTL: 1, _alphaTR: 1, _alphaBL: 1, _alphaBR: 1, clearAlpha() { return this.setAlpha(1); }, setAlpha(t, e, i, s) { return void 0 === t && (t = 1), void 0 === e ? this.alpha = t : (this._alphaTL = n(t, 0, 1), this._alphaTR = n(e, 0, 1), this._alphaBL = n(i, 0, 1), this._alphaBR = n(s, 0, 1)), this; }, alpha: { get() { return this._alpha; }, set(t) { const e = n(t, 0, 1); this._alpha = e, this._alphaTL = e, this._alphaTR = e, this._alphaBL = e, this._alphaBR = e, e === 0 ? this.renderFlags &= -3 : this.renderFlags |= 2; } }, alphaTopLeft: { get() { return this._alphaTL; }, set(t) { const e = n(t, 0, 1); this._alphaTL = e, e !== 0 && (this.renderFlags |= 2); } }, alphaTopRight: { get() { return this._alphaTR; }, set(t) { const e = n(t, 0, 1); this._alphaTR = e, e !== 0 && (this.renderFlags |= 2); } }, alphaBottomLeft: { get() { return this._alphaBL; }, set(t) { const e = n(t, 0, 1); this._alphaBL = e, e !== 0 && (this.renderFlags |= 2); } }, alphaBottomRight: { get() { return this._alphaBR; }, set(t) { const e = n(t, 0, 1); this._alphaBR = e, e !== 0 && (this.renderFlags |= 2); } },
  }; t.exports = s;
}, function (t, e, i) { const n = i(44); const s = i(42); const r = i(43); const o = i(41); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, n(e) + i), o(t, s(e) - a), t; }; }, function (t, e, i) { const n = i(46); const s = i(42); const r = i(45); const o = i(41); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, n(e) - i), o(t, s(e) - a), t; }; }, function (t, e, i) { const n = i(91); const s = i(42); const r = i(90); const o = i(41); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, n(e) + i), o(t, s(e) - a), t; }; }, function (t, e, i) { const n = i(88); const s = i(44); const r = i(89); const o = i(43); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) + i), r(t, n(e) + a), t; }; }, function (t, e, i) { const n = i(88); const s = i(46); const r = i(89); const o = i(45); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) - i), r(t, n(e) + a), t; }; }, function (t, e, i) { const n = i(90); const s = i(89); t.exports = function (t, e, i) { return n(t, e), s(t, i); }; }, function (t, e, i) { const n = i(588); const s = i(91); const r = i(88); t.exports = function (t, e, i, o) { return void 0 === i && (i = 0), void 0 === o && (o = 0), n(t, s(e) + i, r(e) + o), t; }; }, function (t, e, i) { const n = i(48); const s = i(44); const r = i(47); const o = i(43); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) + i), r(t, n(e) + a), t; }; }, function (t, e, i) { const n = i(48); const s = i(46); const r = i(47); const o = i(45); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) - i), r(t, n(e) + a), t; }; }, function (t, e, i) { const n = i(48); const s = i(91); const r = i(47); const o = i(90); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) + i), r(t, n(e) + a), t; }; }, function (t, e, i) { const n = i(299); const s = []; s[n.BOTTOM_CENTER] = i(592), s[n.BOTTOM_LEFT] = i(591), s[n.BOTTOM_RIGHT] = i(590), s[n.CENTER] = i(589), s[n.LEFT_CENTER] = i(587), s[n.RIGHT_CENTER] = i(586), s[n.TOP_CENTER] = i(585), s[n.TOP_LEFT] = i(584), s[n.TOP_RIGHT] = i(583); t.exports = function (t, e, i, n, r) { return s[i](t, e, n, r); }; }, function (t, e, i) {
  t.exports = {
    Angle: i(1003), Call: i(1002), GetFirst: i(1001), GetLast: i(1e3), GridAlign: i(999), IncAlpha: i(998), IncX: i(997), IncXY: i(996), IncY: i(995), PlaceOnCircle: i(994), PlaceOnEllipse: i(993), PlaceOnLine: i(992), PlaceOnRectangle: i(991), PlaceOnTriangle: i(990), PlayAnimation: i(989), PropertyValueInc: i(35), PropertyValueSet: i(25), RandomCircle: i(988), RandomEllipse: i(987), RandomLine: i(986), RandomRectangle: i(985), RandomTriangle: i(984), Rotate: i(983), RotateAround: i(982), RotateAroundDistance: i(981), ScaleX: i(980), ScaleXY: i(979), ScaleY: i(978), SetAlpha: i(977), SetBlendMode: i(976), SetDepth: i(975), SetHitArea: i(974), SetOrigin: i(973), SetRotation: i(972), SetScale: i(971), SetScaleX: i(970), SetScaleY: i(969), SetTint: i(968), SetVisible: i(967), SetX: i(966), SetXY: i(965), SetY: i(964), ShiftPosition: i(963), Shuffle: i(962), SmootherStep: i(961), SmoothStep: i(960), Spread: i(959), ToggleVisible: i(958), WrapInRectangle: i(957),
  };
}, function (t, e) { if (typeof window.Uint32Array !== 'function' && typeof window.Uint32Array !== 'object') { const i = function (t) { const e = new Array(); window[t] = function (t) { if (typeof t === 'number') { Array.call(this, t), this.length = t; for (var e = 0; e < this.length; e++) this[e] = 0; } else { Array.call(this, t.length), this.length = t.length; for (e = 0; e < this.length; e++) this[e] = t[e]; } }, window[t].prototype = e, window[t].constructor = window[t]; }; i('Float32Array'), i('Uint32Array'), i('Uint16Array'), i('Int16Array'), i('ArrayBuffer'); } }, function (t, e, i) { (function (t) { if (Date.now && Date.prototype.getTime || (Date.now = function () { return (new Date()).getTime(); }), !t.performance || !t.performance.now) { const e = Date.now(); t.performance || (t.performance = {}), t.performance.now = function () { return Date.now() - e; }; } for (var i = Date.now(), n = ['ms', 'moz', 'webkit', 'o'], s = 0; s < n.length && !t.requestAnimationFrame; ++s)t.requestAnimationFrame = t[`${n[s]}RequestAnimationFrame`], t.cancelAnimationFrame = t[`${n[s]}CancelAnimationFrame`] || t[`${n[s]}CancelRequestAnimationFrame`]; t.requestAnimationFrame || (t.requestAnimationFrame = function (t) { if (typeof t !== 'function') throw new TypeError(`${t}is not a function`); const e = Date.now(); let n = 16 + i - e; return n < 0 && (n = 0), i = e, setTimeout(() => { i = Date.now(), t(performance.now()); }, n); }), t.cancelAnimationFrame || (t.cancelAnimationFrame = function (t) { clearTimeout(t); }); }).call(this, i(213)); }, function (t, e) { !(function () { if ('performance' in window == !1 && (window.performance = {}), Date.now = Date.now || function () { return (new Date()).getTime(); }, 'now' in window.performance == !1) { let t = Date.now(); performance.timing && performance.timing.navigationStart && (t = performance.timing.navigationStart), window.performance.now = function () { return Date.now() - t; }; } }()); }, function (t, e) { Math.trunc || (Math.trunc = function (t) { return t < 0 ? Math.ceil(t) : Math.floor(t); }); }, function (t, e) { let i; Function.prototype.bind || (Function.prototype.bind = (i = Array.prototype.slice, function (t) { const e = this; const n = i.call(arguments, 1); if (typeof e !== 'function') throw new TypeError(); function s() { const r = n.concat(i.call(arguments)); e.apply(this instanceof s ? this : t, r); } return s.prototype = (function t(e) { if (e && (t.prototype = e), !(this instanceof t)) return new t(); }(e.prototype)), s; })); }, function (t, e) { window.console || (window.console = {}, window.console.log = window.console.assert = function () {}, window.console.warn = window.console.assert = function () {}); }, function (t, e) { !(function () { function t(t) { t && (t.setTargetAtTime || (t.setTargetAtTime = t.setTargetValueAtTime)); }window.hasOwnProperty('webkitAudioContext') && !window.hasOwnProperty('AudioContext') && (window.AudioContext = webkitAudioContext, AudioContext.prototype.hasOwnProperty('createGain') || (AudioContext.prototype.createGain = AudioContext.prototype.createGainNode), AudioContext.prototype.hasOwnProperty('createDelay') || (AudioContext.prototype.createDelay = AudioContext.prototype.createDelayNode), AudioContext.prototype.hasOwnProperty('createScriptProcessor') || (AudioContext.prototype.createScriptProcessor = AudioContext.prototype.createJavaScriptNode), AudioContext.prototype.hasOwnProperty('createPeriodicWave') || (AudioContext.prototype.createPeriodicWave = AudioContext.prototype.createWaveTable), AudioContext.prototype.internal_createGain = AudioContext.prototype.createGain, AudioContext.prototype.createGain = function () { const e = this.internal_createGain(); return t(e.gain), e; }, AudioContext.prototype.internal_createDelay = AudioContext.prototype.createDelay, AudioContext.prototype.createDelay = function (e) { const i = e ? this.internal_createDelay(e) : this.internal_createDelay(); return t(i.delayTime), i; }, AudioContext.prototype.internal_createBufferSource = AudioContext.prototype.createBufferSource, AudioContext.prototype.createBufferSource = function () { const e = this.internal_createBufferSource(); return e.start ? (e.internal_start = e.start, e.start = function (t, i, n) { void 0 !== n ? e.internal_start(t || 0, i, n) : e.internal_start(t || 0, i || 0); }) : e.start = function (t, e, i) { e || i ? this.noteGrainOn(t || 0, e, i) : this.noteOn(t || 0); }, e.stop ? (e.internal_stop = e.stop, e.stop = function (t) { e.internal_stop(t || 0); }) : e.stop = function (t) { this.noteOff(t || 0); }, t(e.playbackRate), e; }, AudioContext.prototype.internal_createDynamicsCompressor = AudioContext.prototype.createDynamicsCompressor, AudioContext.prototype.createDynamicsCompressor = function () { const e = this.internal_createDynamicsCompressor(); return t(e.threshold), t(e.knee), t(e.ratio), t(e.reduction), t(e.attack), t(e.release), e; }, AudioContext.prototype.internal_createBiquadFilter = AudioContext.prototype.createBiquadFilter, AudioContext.prototype.createBiquadFilter = function () { const e = this.internal_createBiquadFilter(); return t(e.frequency), t(e.detune), t(e.Q), t(e.gain), e; }, AudioContext.prototype.hasOwnProperty('createOscillator') && (AudioContext.prototype.internal_createOscillator = AudioContext.prototype.createOscillator, AudioContext.prototype.createOscillator = function () { const e = this.internal_createOscillator(); return e.start ? (e.internal_start = e.start, e.start = function (t) { e.internal_start(t || 0); }) : e.start = function (t) { this.noteOn(t || 0); }, e.stop ? (e.internal_stop = e.stop, e.stop = function (t) { e.internal_stop(t || 0); }) : e.stop = function (t) { this.noteOff(t || 0); }, e.setPeriodicWave || (e.setPeriodicWave = e.setWaveTable), t(e.frequency), t(e.detune), e; })), window.hasOwnProperty('webkitOfflineAudioContext') && !window.hasOwnProperty('OfflineAudioContext') && (window.OfflineAudioContext = webkitOfflineAudioContext); }()); }, function (t, e) { Array.isArray || (Array.isArray = function (t) { return Object.prototype.toString.call(t) === '[object Array]'; }); }, function (t, e) {
  Array.prototype.forEach || (Array.prototype.forEach = function (t) {
    if (void 0 === this || this === null) throw new TypeError(); const e = Object(this); const i = e.length >>> 0; if (typeof t !== 'function') throw new TypeError(); for (let n = arguments.length >= 2 ? arguments[1] : void 0, s = 0; s < i; s++)s in e && t.call(n, e[s], s, e);
  });
}, function (t, e, i) { i(603), i(602), i(601), i(600), i(599), i(598), i(597), i(596), i(595); }, function (t, e) {
  const i = {}; t.exports = i, i.create = function (t, e) {
    const n = t.bodyA; const s = t.bodyB; const r = {
      id: i.id(n, s), bodyA: n, bodyB: s, activeContacts: [], separation: 0, isActive: !0, confirmedActive: !0, isSensor: n.isSensor || s.isSensor, timeCreated: e, timeUpdated: e, collision: null, inverseMass: 0, friction: 0, frictionStatic: 0, restitution: 0, slop: 0,
    }; return i.update(r, t, e), r;
  }, i.update = function (t, e, n) { if (t.collision = e, e.collided) { const s = e.supports; const r = t.activeContacts; const o = e.parentA; const a = e.parentB; t.inverseMass = o.inverseMass + a.inverseMass, t.friction = Math.min(o.friction, a.friction), t.frictionStatic = Math.max(o.frictionStatic, a.frictionStatic), t.restitution = Math.max(o.restitution, a.restitution), t.slop = Math.max(o.slop, a.slop); for (let h = 0; h < s.length; h++)r[h] = s[h].contact; const l = s.length; l < r.length && (r.length = l), t.separation = e.depth, i.setActive(t, !0, n); } else !0 === t.isActive && i.setActive(t, !1, n); }, i.setActive = function (t, e, i) { e ? (t.isActive = !0, t.timeUpdated = i) : (t.isActive = !1, t.activeContacts.length = 0); }, i.id = function (t, e) { return t.id < e.id ? `A${t.id}B${e.id}` : `A${e.id}B${t.id}`; };
}, function (t, e, i) {
  t.exports = {
    Bounce: i(1042), Collision: i(1041), Force: i(1040), Friction: i(1039), Gravity: i(1038), Mass: i(1037), Static: i(1036), Sensor: i(1035), SetBody: i(1034), Sleep: i(1033), Transform: i(1032), Velocity: i(1031),
  };
}, function (t, e) { t.exports = function (t) { return t.split('').reverse().join(''); }; }, function (t, e) { t.exports = function (t, e) { return t.replace(/%([0-9]+)/g, (t, i) => e[Number(i) - 1]); }; }, function (t, e, i) {
  t.exports = {
    Format: i(608), Pad: i(130), Reverse: i(607), UppercaseFirst: i(255),
  };
}, function (t, e, i) { const n = i(33); t.exports = function (t, e) { const i = n(t); for (const s in e)i.hasOwnProperty(s) && (i[s] = e[s]); return i; }; }, function (t, e) { t.exports = function (t, e) { for (let i = 0; i < e.length; i++) if (!t.hasOwnProperty(e[i])) return !1; return !0; }; }, function (t, e, i) { const n = i(4); const s = i(23); t.exports = function (t, e, i, r, o) { void 0 === o && (o = i); const a = n(t, e, o); return s(a, i, r); }; }, function (t, e, i) {
  t.exports = {
    Clone: i(33), Extend: i(18), GetAdvancedValue: i(10), GetFastValue: i(1), GetMinMaxValue: i(612), GetValue: i(4), HasAll: i(611), HasAny: i(407), HasValue: i(108), IsPlainObject: i(8), Merge: i(93), MergeRight: i(610),
  };
}, function (t, e, i) { t.exports = { Array: i(146), Objects: i(613), String: i(609) }; }, function (t, e, i) { const n = i(11); const s = i(214); n.register('tilemap', function (t, e, i, n, r, o, a) { return t === null && (t = void 0), e === null && (e = void 0), i === null && (i = void 0), n === null && (n = void 0), r === null && (r = void 0), s(this.scene, t, e, i, n, r, o, a); }); }, function (t, e, i) { const n = i(13); const s = i(214); n.register('tilemap', function (t) { const e = void 0 !== t ? t : {}; return s(this.scene, e.key, e.tileWidth, e.tileHeight, e.width, e.height, e.data, e.insertNull); }); }, function (t, e, i) { const n = i(2); t.exports = function (t, e, i, s) { if (!(n.RENDER_MASK !== e.renderFlags || e.cameraFilter > 0 && e.cameraFilter & s._id)) { e.cull(s); const r = e.culledTiles; const o = this.tileset; const a = t.gameContext; const h = r.length; const l = o.image.getSourceImage(); const u = e.x - s.scrollX * e.scrollFactorX; const c = e.y - s.scrollY * e.scrollFactorY; a.save(), a.translate(u, c), a.rotate(e.rotation), a.scale(e.scaleX, e.scaleY), a.scale(e.flipX ? -1 : 1, e.flipY ? -1 : 1), a.globalAlpha = e.alpha; for (let d = 0; d < h; ++d) { const f = r[d]; const p = o.getTileTextureCoordinates(f.index); p !== null && a.drawImage(l, p.x, p.y, f.width, f.height, f.pixelX, f.pixelY, f.width, f.height); }a.restore(); } }; }, function (t, e, i) { const n = i(2); t.exports = function (t, e, i, s) { n.RENDER_MASK !== e.renderFlags || e.cameraFilter > 0 && e.cameraFilter & s._id || (e.upload(s), this.pipeline.drawStaticTilemapLayer(e, s)); }; }, function (t, e, i) { let n = i(3); let s = i(3); n = i(618), s = i(617), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const n = i(2); t.exports = function (t, e, i, s) { if (!(n.RENDER_MASK !== e.renderFlags || e.cameraFilter > 0 && e.cameraFilter & s._id)) { e.cull(s); const r = e.culledTiles; const o = r.length; const a = e.tileset.image.getSourceImage(); const h = this.tileset; const l = e.x - s.scrollX * e.scrollFactorX; const u = e.y - s.scrollY * e.scrollFactorY; const c = t.gameContext; c.save(), c.translate(l, u), c.rotate(e.rotation), c.scale(e.scaleX, e.scaleY), c.scale(e.flipX ? -1 : 1, e.flipY ? -1 : 1); for (let d = 0; d < o; ++d) { const f = r[d]; const p = h.getTileTextureCoordinates(f.index); if (p !== null) { const g = f.width / 2; const v = f.height / 2; c.save(), c.translate(f.pixelX + g, f.pixelY + v), f.rotation !== 0 && c.rotate(f.rotation), (f.flipX || f.flipY) && c.scale(f.flipX ? -1 : 1, f.flipY ? -1 : 1), c.globalAlpha = e.alpha * f.alpha, c.drawImage(a, p.x, p.y, f.width, f.height, -g, -v, f.width, f.height), c.restore(); } }c.restore(); } }; }, function (t, e, i) { const n = i(2); t.exports = function (t, e, i, s) { n.RENDER_MASK !== e.renderFlags || e.cameraFilter > 0 && e.cameraFilter & s._id || (e.cull(s), this.pipeline.batchDynamicTilemapLayer(e, s)); }; }, function (t, e, i) { let n = i(3); let s = i(3); n = i(621), s = i(620), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const n = i(134); t.exports = function (t) { for (var e = [], i = [], s = 0; s < t.layer.length; s++) { const r = t.layer[s]; const o = r.tilesetName; o !== '' && i.indexOf(o) === -1 && (i.push(o), e.push(new n(o, 0, r.tilesize, r.tilesize, 0, 0))); } return e; }; }, function (t, e, i) {
  const n = i(103); const s = i(65); t.exports = function (t, e) {
    for (var i = [], r = 0; r < t.layer.length; r++) {
      for (var o = t.layer[r], a = new n({
          name: o.name, width: o.width, height: o.height, tileWidth: o.tilesize, tileHeight: o.tilesize, visible: o.visible === 1,
        }), h = [], l = [], u = 0; u < o.data.length; u++) { for (let c = 0; c < o.data[u].length; c++) { var d; const f = o.data[u][c] - 1; d = f > -1 ? new s(a, f, c, u, o.tilesize, o.tilesize) : e ? null : new s(a, -1, c, u, o.tilesize, o.tilesize), h.push(d); }l.push(h), h = []; }a.data = l, i.push(a);
    } return i;
  };
}, function (t, e, i) { const n = i(18); t.exports = function (t) { for (var e, i, s, r, o, a = 0; a < t.layers.length; a++) { e = t.layers[a], r = null; for (let h = 0; h < e.data.length; h++) { o = e.data[h]; for (let l = 0; l < o.length; l++)(i = o[l]) === null || i.index < 0 || (s = t.tiles[i.index][2], r = t.tilesets[s], i.width = r.tileWidth, i.height = r.tileHeight, r.tileProperties && r.tileProperties[i.index - r.firstgid] && (i.properties = n(i.properties, r.tileProperties[i.index - r.firstgid]))); } } }; }, function (t, e) { t.exports = function (t) { for (var e = [], i = 0; i < t.tilesets.length; i++) for (let n = t.tilesets[i], s = n.tileMargin, r = n.tileMargin, o = 0, a = 0, h = 0, l = n.firstgid; l < n.firstgid + n.total && (e[l] = [s, r, i], s += n.tileWidth + n.tileSpacing, ++o !== n.total) && (++a !== n.columns || (s = n.tileMargin, r += n.tileHeight + n.tileSpacing, a = 0, ++h !== n.rows)); l++);return e; }; }, function (t, e, i) { const n = i(1); const s = i(314); const r = i(313); t.exports = function (t) { for (var e = [], i = 0; i < t.layers.length; i++) if (t.layers[i].type === 'objectgroup') { for (var o = t.layers[i], a = n(o, 'offsetx', 0), h = n(o, 'offsety', 0), l = [], u = 0; u < o.objects.length; u++) { const c = s(o.objects[u], a, h); l.push(c); } const d = new r(o); d.objects = l, e.push(d); } return e; }; }, function (t, e, i) { const n = i(108); t.exports = function (t, e) { for (var i = {}, s = 0; s < e.length; s++) { const r = e[s]; n(t, r) && (i[r] = t[r]); } return i; }; }, function (t, e, i) { const n = i(134); const s = i(315); const r = i(314); t.exports = function (t) { for (var e, i = [], o = [], a = null, h = 0; h < t.tilesets.length; h++) { const l = t.tilesets[h]; if (l.source)console.warn("Phaser can't load external tilesets. Use the Embed Tileset button and then export the map again."); else if (l.image) { const u = new n(l.name, l.firstgid, l.tilewidth, l.tileheight, l.margin, l.spacing); if (l.tileproperties && (u.tileProperties = l.tileproperties), l.tiles) for (e in u.tileData = l.tiles, u.tileData) { const c = u.tileData[e].objectgroup; if (c && c.objects) { const d = c.objects.map((t) => r(t)); u.tileData[e].objectgroup.objects = d; } }u.updateTileData(l.imagewidth, l.imageheight), i.push(u); } else { const f = new s(l.name, l.firstgid, l.tilewidth, l.tileheight, l.margin, l.spacing, l.properties); for (e in l.tiles) { const p = l.tiles[e].image; const g = l.firstgid + parseInt(e, 10); f.addImage(g, p); }o.push(f); }a && (a.lastgid = l.firstgid - 1), a = l; } return { tilesets: i, imageCollections: o }; }; }, function (t, e, i) {
  const n = i(1); t.exports = function (t) {
    for (var e = [], i = 0; i < t.layers.length; i++) {
      if (t.layers[i].type === 'imagelayer') {
        const s = t.layers[i]; e.push({
          name: s.name, image: s.image, x: n(s, 'offsetx', 0) + s.x, y: n(s, 'offsety', 0) + s.y, alpha: s.opacity, visible: s.visible, properties: n(s, 'properties', {}),
        });
      }
    } return e;
  };
}, function (t, e) { t.exports = function (t) { for (var e = window.atob(t), i = e.length, n = new Array(i / 4), s = 0; s < i; s += 4)n[s / 4] = (e.charCodeAt(s) | e.charCodeAt(s + 1) << 8 | e.charCodeAt(s + 2) << 16 | e.charCodeAt(s + 3) << 24) >>> 0; return n; }; }, function (t, e, i) {
  const n = i(631); const s = i(1); const r = i(103); const o = i(316); const a = i(65); t.exports = function (t, e) {
    for (var i = [], h = 0; h < t.layers.length; h++) {
      if (t.layers[h].type === 'tilelayer') {
        const l = t.layers[h]; if (l.compression)console.warn(`TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer '${l.name}'`); else {
          l.encoding && l.encoding === 'base64' && (l.data = n(l.data), delete l.encoding); for (var u = new r({
              name: l.name, x: s(l, 'offsetx', 0) + l.x, y: s(l, 'offsety', 0) + l.y, width: l.width, height: l.height, tileWidth: t.tilewidth, tileHeight: t.tileheight, alpha: l.opacity, visible: l.visible, properties: s(l, 'properties', {}),
            }), c = 0, d = [], f = [], p = 0, g = l.data.length; p < g; p++) { const v = o(l.data[p]); if (v.gid > 0) { const y = new a(u, v.gid, c, f.length, t.tilewidth, t.tileheight); y.rotation = v.rotation, y.flipX = v.flipped, d.push(y); } else { const m = e ? null : new a(u, -1, c, f.length, t.tilewidth, t.tileheight); d.push(m); }++c === l.width && (f.push(d), c = 0, d = []); }u.data = f, i.push(u);
        }
      }
    } return i;
  };
}, function (t, e, i) {
  t.exports = {
    Parse: i(319), Parse2DArray: i(215), ParseCSV: i(318), Impact: i(312), Tiled: i(317),
  };
}, function (t, e, i) { const n = i(52); const s = i(51); const r = i(7); t.exports = function (t, e, i, o, a, h) { return void 0 === o && (o = new r(0, 0)), o.x = n(t, i, a, h), o.y = s(e, i, a, h), o; }; }, function (t, e, i) { const n = i(21); t.exports = function (t, e, i, s, r, o) { if (void 0 !== r) { let a; const h = n(t, e, i, s, null, o); let l = 0; for (a = 0; a < r.length; a++)l += r[a].weight; if (!(l <= 0)) for (a = 0; a < h.length; a++) { for (var u = Math.random() * l, c = 0, d = -1, f = 0; f < r.length; f++) if (u <= (c += r[f].weight)) { const p = r[f].index; d = Array.isArray(p) ? p[Math.floor(Math.random() * p.length)] : p; break; }h[a].index = d; } } }; }, function (t, e, i) { const n = i(136); const s = i(135); const r = i(7); t.exports = function (t, e, i, o, a) { return void 0 === i && (i = new r(0, 0)), i.x = n(t, o, a), i.y = s(e, o, a), i; }; }, function (t, e, i) { const n = i(21); t.exports = function (t, e, i, s, r, o, a) { for (let h = n(i, s, r, o, null, a), l = 0; l < h.length; l++)h[l] && (h[l].index === t ? h[l].index = e : h[l].index === e && (h[l].index = t)); }; }, function (t, e, i) { const n = i(21); const s = i(94); t.exports = function (t, e, i, r, o) { const a = n(t, e, i, r, null, o); const h = a.map((t) => t.index); s(h); for (let l = 0; l < a.length; l++)a[l].index = h[l]; }; }, function (t, e, i) { const n = i(21); t.exports = function (t, e, i, s, r, o, a) { for (let h = n(t, e, i, s, null, a), l = 0; l < h.length; l++)h[l].setCollisionCallback(r, o); }; }, function (t, e) { t.exports = function (t, e, i, n) { if (typeof t === 'number')n.callbacks[t] = e !== null ? { callback: e, callbackContext: i } : void 0; else for (let s = 0, r = t.length; s < r; s++)n.callbacks[t[s]] = e !== null ? { callback: e, callbackContext: i } : void 0; }; }, function (t, e, i) { const n = i(66); const s = i(40); t.exports = function (t, e, i) { void 0 === t && (t = !0), void 0 === e && (e = !0); for (let r = 0; r < i.height; r++) for (let o = 0; o < i.width; o++) { const a = i.data[r][o]; if (a) { const h = a.getCollisionGroup(); h && h.objects && h.objects.length > 0 && n(a, t); } }e && s(0, 0, i.width, i.height, i); }; }, function (t, e, i) { const n = i(66); const s = i(40); const r = i(108); t.exports = function (t, e, i, o) { void 0 === e && (e = !0), void 0 === i && (i = !0); for (let a = 0; a < o.height; a++) for (let h = 0; h < o.width; h++) { const l = o.data[a][h]; if (l) for (const u in t) if (r(l.properties, u)) { let c = t[u]; Array.isArray(c) || (c = [c]); for (let d = 0; d < c.length; d++)l.properties[u] === c[d] && n(l, e); } }i && s(0, 0, o.width, o.height, o); }; }, function (t, e, i) { const n = i(66); const s = i(40); const r = i(216); t.exports = function (t, e, i, o) { void 0 === e && (e = !0), void 0 === i && (i = !0), Array.isArray(t) || (t = [t]); for (let a = 0; a < o.height; a++) for (let h = 0; h < o.width; h++) { const l = o.data[a][h]; l && t.indexOf(l.index) === -1 && (n(l, e), r(l.index, e, o)); }i && s(0, 0, o.width, o.height, o); }; }, function (t, e, i) { const n = i(66); const s = i(40); const r = i(216); t.exports = function (t, e, i, o, a) { if (void 0 === i && (i = !0), void 0 === o && (o = !0), !(t > e)) { for (let h = t; h <= e; h++)r(h, i, a); for (let l = 0; l < a.height; l++) for (let u = 0; u < a.width; u++) { const c = a.data[l][u]; c && c.index >= t && c.index <= e && n(c, i); }o && s(0, 0, a.width, a.height, a); } }; }, function (t, e, i) { const n = i(66); const s = i(40); const r = i(216); t.exports = function (t, e, i, o) { void 0 === e && (e = !0), void 0 === i && (i = !0), Array.isArray(t) || (t = [t]); for (let a = 0; a < t.length; a++)r(t[a], e, o); for (let h = 0; h < o.height; h++) for (let l = 0; l < o.width; l++) { const u = o.data[h][l]; u && t.indexOf(u.index) !== -1 && n(u, e); }i && s(0, 0, o.width, o.height, o); }; }, function (t, e, i) { const n = i(21); const s = i(535); t.exports = function (t, e, i) { void 0 === e && (e = {}); for (let r = void 0 !== e.tileColor ? e.tileColor : new s(105, 210, 231, 150), o = void 0 !== e.collidingTileColor ? e.collidingTileColor : new s(243, 134, 48, 200), a = void 0 !== e.faceColor ? e.faceColor : new s(40, 39, 37, 150), h = n(0, 0, i.width, i.height, null, i), l = 0; l < h.length; l++) { const u = h[l]; let c = u.width; let d = u.height; let f = u.pixelX; let p = u.pixelY; const g = u.collides ? o : r; g !== null && (t.fillStyle(g.color, g.alpha / 255), t.fillRect(f, p, c, d)), f += 1, p += 1, c -= 2, d -= 2, a !== null && (t.lineStyle(1, a.color, a.alpha / 255), u.faceTop && t.lineBetween(f, p, f + c, p), u.faceRight && t.lineBetween(f + c, p, f + c, p + d), u.faceBottom && t.lineBetween(f, p + d, f + c, p + d), u.faceLeft && t.lineBetween(f, p, f, p + d)); } }; }, function (t, e, i) { const n = i(320); const s = i(52); const r = i(51); t.exports = function (t, e, i, o, a, h) { const l = s(t, !0, a, h); const u = r(e, !0, a, h); return n(l, u, i, o, h); }; }, function (t, e, i) { const n = i(21); const s = i(145); t.exports = function (t, e, i, r, o, a) { let h; const l = n(t, e, i, r, null, a); if (void 0 === o) for (o = [], h = 0; h < l.length; h++)o.indexOf(l[h].index) === -1 && o.push(l[h].index); for (h = 0; h < l.length; h++)l[h].index = s(o); }; }, function (t, e, i) { const n = i(40); const s = i(217); t.exports = function (t, e, i, r, o) { if (!Array.isArray(t)) return null; void 0 === r && (r = !0), Array.isArray(t[0]) || (t = [t]); for (var a = t.length, h = t[0].length, l = 0; l < a; l++) for (let u = 0; u < h; u++) { const c = t[l][u]; s(c, e + u, i + l, !1, o); }r && n(e - 1, i - 1, h + 2, a + 2, o); }; }, function (t, e, i) { const n = i(217); const s = i(52); const r = i(51); t.exports = function (t, e, i, o, a, h) { const l = s(e, !0, a, h); const u = r(i, !0, a, h); return n(t, l, u, o, h); }; }, function (t, e, i) { const n = i(321); const s = i(52); const r = i(51); t.exports = function (t, e, i, o) { const a = s(t, !0, i, o); const h = r(e, !0, i, o); return n(a, h, o); }; }, function (t, e, i) { const n = i(21); const s = i(52); const r = i(51); t.exports = function (t, e, i, o, a, h, l) { const u = s(t, !0, h, l); const c = r(e, !0, h, l); const d = Math.ceil(s(t + i, !1, h, l)); const f = Math.ceil(r(e + o, !1, h, l)); return n(u, c, d - u, f - c, a, l); }; }, function (t, e, i) { const n = i(387); const s = i(21); const r = i(386); const o = i(3); const a = i(136); const h = i(135); const l = i(52); const u = i(51); const c = function (t, e) { return r.RectangleToTriangle(e, t); }; t.exports = function (t, e, i, d) { if (void 0 === t) return []; let f = o; t instanceof n.Circle ? f = r.CircleToRectangle : t instanceof n.Rectangle ? f = r.RectangleToRectangle : t instanceof n.Triangle ? f = c : t instanceof n.Line && (f = r.LineToRectangle); const p = l(t.left, !0, i, d); const g = u(t.top, !0, i, d); const v = Math.ceil(l(t.right, !1, i, d)); const y = Math.ceil(u(t.bottom, !1, i, d)); const m = Math.max(v - p, 1); const x = Math.max(y - g, 1); const w = s(p, g, m, x, e, d); let b = d.tileWidth; let T = d.tileHeight; d.tilemapLayer && (b *= d.tilemapLayer.scaleX, T *= d.tilemapLayer.scaleY); for (var S = [], A = new n.Rectangle(0, 0, b, T), C = 0; C < w.length; C++) { const M = w[C]; A.x = a(M.x, i, d), A.y = h(M.y, i, d), f(t, A) && S.push(M); } return S; }; }, function (t, e, i) { const n = i(137); const s = i(52); const r = i(51); t.exports = function (t, e, i, o, a) { const h = s(t, !0, o, a); const l = r(e, !0, o, a); return n(h, l, i, a); }; }, function (t, e, i) { const n = i(21); t.exports = function (t, e, i, s, r, o, a, h) { n(i, s, r, o, a, h).forEach(t, e); }; }, function (t, e, i) { const n = i(21); t.exports = function (t, e, i, s, r, o, a, h) { return n(i, s, r, o, a, h).find(t, e) || null; }; }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === e && (e = 0), void 0 === i && (i = !1); let s; let r; let o; let a = 0; if (i) { for (r = n.height - 1; r >= 0; r--) for (s = n.width - 1; s >= 0; s--) if ((o = n.data[r][s]) && o.index === t) { if (a === e) return o; a += 1; } } else for (r = 0; r < n.height; r++) for (s = 0; s < n.width; s++) if ((o = n.data[r][s]) && o.index === t) { if (a === e) return o; a += 1; } return null; }; }, function (t, e, i) { const n = i(21); t.exports = function (t, e, i, s, r, o, a, h) { return n(i, s, r, o, a, h).filter(t, e); }; }, function (t, e, i) { const n = i(21); const s = i(40); const r = i(66); t.exports = function (t, e, i, o, a, h, l) { void 0 === h && (h = !0); for (let u = l.collideIndexes.indexOf(t) !== -1, c = n(e, i, o, a, null, l), d = 0; d < c.length; d++)c[d].index = t, r(c[d], u); h && s(e - 1, i - 1, o + 2, a + 2, l); }; }, function (t, e) { t.exports = function (t, e, i) { void 0 === i && (i = []), i.length = 0; const n = e.zoom; const s = e.width / 2; const r = e.height / 2; e.matrix.loadIdentity(), e.matrix.translate(e.x + s, e.y + r), e.matrix.rotate(e.rotation), e.matrix.scale(n, n), e.matrix.translate(-s, -r), e.matrix.invert(), e.shakeEffect.preRender(); for (let o = t.tilemapLayer, a = t.tileWidth, h = t.tileHeight, l = e.scrollX * o.scrollFactorX - a, u = e.scrollY * o.scrollFactorY - h, c = l + (e.width + 2 * a), d = u + (e.height + 2 * h), f = t.data, p = t.width, g = t.height, v = e.matrix.matrix, y = v[0], m = v[1], x = v[2], w = v[3], b = v[4], T = v[5], S = l * y + u * x + b, A = l * m + u * w + T, C = c * y + d * x + b, M = c * m + d * w + T, _ = 0; _ < g; ++_) for (let E = 0; E < p; ++E) { const P = f[_][E]; if (P !== null && P.index !== -1) { const L = P.pixelX * y + P.pixelY * x + b; const F = P.pixelX * m + P.pixelY * w + T; P.visible && L >= S && F >= A && L + a <= C && F + h <= M && i.push(P); } } return i; }; }, function (t, e, i) { const n = i(136); const s = i(135); const r = i(21); const o = i(322); t.exports = function (t, e, i, a, h, l) { void 0 === i && (i = {}), Array.isArray(t) || (t = [t]); const u = l.tilemapLayer; void 0 === a && (a = u.scene), void 0 === h && (h = a.cameras.main); let c; const d = r(0, 0, l.width, l.height, null, l); const f = []; for (c = 0; c < d.length; c++) { const p = d[c]; if (t.indexOf(p.index) !== -1) { i.x = n(p.x, h, l), i.y = s(p.y, h, l); const g = a.make.sprite(i); f.push(g); } } if (typeof e === 'number') for (c = 0; c < t.length; c++)o(t[c], e, 0, 0, l.width, l.height, l); else if (Array.isArray(e)) for (c = 0; c < t.length; c++)o(t[c], e[c], 0, 0, l.width, l.height, l); return f; }; }, function (t, e, i) { const n = i(21); const s = i(40); t.exports = function (t, e, i, r, o, a, h, l) { t < 0 && (t = 0), e < 0 && (e = 0), void 0 === h && (h = !0); for (let u = n(t, e, i, r, null, l), c = o - t, d = a - e, f = 0; f < u.length; f++) { const p = u[f].x + c; const g = u[f].y + d; p >= 0 && p < l.width && g >= 0 && g < l.height && l.data[g][p] && l.data[g][p].copy(u[f]); }h && s(o - 1, a - 1, i + 2, r + 2, l); }; }, function (t, e, i) {
  t.exports = {
    Components: i(138), Parsers: i(633), Formats: i(26), ImageCollection: i(315), ParseToTilemap: i(214), Tile: i(65), Tilemap: i(311), TilemapCreator: i(616), TilemapFactory: i(615), Tileset: i(134), LayerData: i(103), MapData: i(102), ObjectLayer: i(313), DynamicTilemapLayer: i(310), StaticTilemapLayer: i(309),
  };
}, function (t, e, i) {
  t.exports = {
    BitmapMaskPipeline: i(259), FlatTintPipeline: i(258), ForwardDiffuseLightPipeline: i(147), TextureTintPipeline: i(126),
  };
}, function (t, e, i) {
  t.exports = {
    Utils: i(27), WebGLPipeline: i(83), WebGLRenderer: i(261), Pipelines: i(664), BYTE: 0, SHORT: 1, UNSIGNED_BYTE: 2, UNSIGNED_SHORT: 3, FLOAT: 4,
  };
}, function (t, e, i) { t.exports = { Canvas: i(264), WebGL: i(260) }; }, function (t, e, i) {
  t.exports = {
    BlitImage: i(265), CanvasRenderer: i(266), DrawImage: i(263), GetBlendModes: i(262),
  };
}, function (t, e, i) { t.exports = { Canvas: i(667), Snapshot: i(666), WebGL: i(665) }; }, function (t, e, i) { const n = {}; t.exports = n; const s = i(219); const r = (i(300), i(49)); n.create = function (t) { const e = s.create(); const i = { label: 'World', gravity: { x: 0, y: 1, scale: 0.001 }, bounds: { min: { x: -1 / 0, y: -1 / 0 }, max: { x: 1 / 0, y: 1 / 0 } } }; return r.extend(e, i, t); }; }, function (t, e, i) {
  const n = {}; t.exports = n; const s = i(49); n._registry = {}, n.register = function (t) { if (n.isPlugin(t) || s.warn('Plugin.register:', n.toString(t), 'does not implement all required fields.'), t.name in n._registry) { const e = n._registry[t.name]; const i = n.versionParse(t.version).number; const r = n.versionParse(e.version).number; i > r ? (s.warn('Plugin.register:', n.toString(e), 'was upgraded to', n.toString(t)), n._registry[t.name] = t) : i < r ? s.warn('Plugin.register:', n.toString(e), 'can not be downgraded to', n.toString(t)) : t !== e && s.warn('Plugin.register:', n.toString(t), 'is already registered to different plugin object'); } else n._registry[t.name] = t; return t; }, n.resolve = function (t) { return n._registry[n.dependencyParse(t).name]; }, n.toString = function (t) { return typeof t === 'string' ? t : `${t.name || 'anonymous'}@${t.version || t.range || '0.0.0'}`; }, n.isPlugin = function (t) { return t && t.name && t.version && t.install; }, n.isUsed = function (t, e) { return t.used.indexOf(e) > -1; }, n.isFor = function (t, e) { const i = t.for && n.dependencyParse(t.for); return !t.for || e.name === i.name && n.versionSatisfies(e.version, i.range); }, n.use = function (t, e) { if (t.uses = (t.uses || []).concat(e || []), t.uses.length !== 0) { for (var i = n.dependencies(t), r = s.topologicalSort(i), o = [], a = 0; a < r.length; a += 1) if (r[a] !== t.name) { var h = n.resolve(r[a]); h ? n.isUsed(t, h.name) || (n.isFor(h, t) || (s.warn('Plugin.use:', n.toString(h), 'is for', h.for, 'but installed on', `${n.toString(t)}.`), h._warned = !0), h.install ? h.install(t) : (s.warn('Plugin.use:', n.toString(h), 'does not specify an install function.'), h._warned = !0), h._warned ? (o.push(` ${n.toString(h)}`), delete h._warned) : o.push(` ${n.toString(h)}`), t.used.push(h.name)) : o.push(` ${r[a]}`); }o.length > 0 && !h.silent && s.info(o.join('  ')); } else s.warn('Plugin.use:', n.toString(t), 'does not specify any dependencies to install.'); }, n.dependencies = function (t, e) { const i = n.dependencyParse(t); const r = i.name; if (!(r in (e = e || {}))) { t = n.resolve(t) || t, e[r] = s.map(t.uses || [], (e) => { n.isPlugin(e) && n.register(e); const r = n.dependencyParse(e); const o = n.resolve(e); return o && !n.versionSatisfies(o.version, r.range) ? (s.warn('Plugin.dependencies:', n.toString(o), 'does not satisfy', n.toString(r), 'used by', `${n.toString(i)}.`), o._warned = !0, t._warned = !0) : o || (s.warn('Plugin.dependencies:', n.toString(e), 'used by', n.toString(i), 'could not be resolved.'), t._warned = !0), r.name; }); for (let o = 0; o < e[r].length; o += 1)n.dependencies(e[r][o], e); return e; } }, n.dependencyParse = function (t) { return s.isString(t) ? (/^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?))?$/.test(t) || s.warn('Plugin.dependencyParse:', t, 'is not a valid dependency string.'), { name: t.split('@')[0], range: t.split('@')[1] || '*' }) : { name: t.name, range: t.range || t.version }; }, n.versionParse = function (t) {
    /^\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?$/.test(t) || s.warn('Plugin.versionParse:', t, 'is not a valid version or range.'); const e = t.split('-'); t = e[0]; const i = isNaN(Number(t[0])); const n = i ? t.substr(1) : t; const r = s.map(n.split('.'), (t) => Number(t)); return {
      isRange: i, version: n, range: t, operator: i ? t[0] : '', parts: r, prerelease: e[1], number: 1e8 * r[0] + 1e4 * r[1] + r[2],
    };
  }, n.versionSatisfies = function (t, e) { e = e || '*'; const i = n.versionParse(e); const s = i.parts; const r = n.versionParse(t); const o = r.parts; if (i.isRange) { if (i.operator === '*' || t === '*') return !0; if (i.operator === '~') return o[0] === s[0] && o[1] === s[1] && o[2] >= s[2]; if (i.operator === '^') return s[0] > 0 ? o[0] === s[0] && r.number >= i.number : s[1] > 0 ? o[1] === s[1] && o[2] >= s[2] : o[2] === s[2]; } return t === e || t === '*'; };
}, function (t, e, i) { const n = i(1009); n.Body = i(80), n.Composite = i(219), n.World = i(669), n.Detector = i(673), n.Grid = i(1008), n.Pairs = i(1007), n.Pair = i(605), n.Query = i(1029), n.Resolver = i(1006), n.SAT = i(672), n.Constraint = i(300), n.Common = i(49), n.Engine = i(1005), n.Events = i(301), n.Sleeping = i(331), n.Plugin = i(670), n.Bodies = i(220), n.Composites = i(1012), n.Axes = i(675), n.Bounds = i(139), n.Svg = i(1027), n.Vector = i(123), n.Vertices = i(140), n.World.add = n.Composite.add, n.World.remove = n.Composite.remove, n.World.addComposite = n.Composite.addComposite, n.World.addBody = n.Composite.addBody, n.World.addConstraint = n.Composite.addConstraint, n.World.clear = n.Composite.clear, t.exports = n; }, function (t, e, i) { const n = {}; t.exports = n; const s = i(140); const r = i(123); !(function () { n.collides = function (e, n, o) { let a; let h; let l; let u; let c = !1; if (o) { const d = e.parent; const f = n.parent; const p = d.speed * d.speed + d.angularSpeed * d.angularSpeed + f.speed * f.speed + f.angularSpeed * f.angularSpeed; c = o && o.collided && p < 0.2, u = o; } else u = { collided: !1, bodyA: e, bodyB: n }; if (o && c) { const g = u.axisBody; const v = g === e ? n : e; const y = [g.axes[o.axisNumber]]; if (l = t(g.vertices, v.vertices, y), u.reused = !0, l.overlap <= 0) return u.collided = !1, u; } else { if ((a = t(e.vertices, n.vertices, e.axes)).overlap <= 0) return u.collided = !1, u; if ((h = t(n.vertices, e.vertices, n.axes)).overlap <= 0) return u.collided = !1, u; a.overlap < h.overlap ? (l = a, u.axisBody = e) : (l = h, u.axisBody = n), u.axisNumber = l.axisNumber; }u.bodyA = e.id < n.id ? e : n, u.bodyB = e.id < n.id ? n : e, u.collided = !0, u.depth = l.overlap, u.parentA = u.bodyA.parent, u.parentB = u.bodyB.parent, e = u.bodyA, n = u.bodyB, r.dot(l.axis, r.sub(n.position, e.position)) < 0 ? u.normal = { x: l.axis.x, y: l.axis.y } : u.normal = { x: -l.axis.x, y: -l.axis.y }, u.tangent = r.perp(u.normal), u.penetration = u.penetration || {}, u.penetration.x = u.normal.x * u.depth, u.penetration.y = u.normal.y * u.depth; const m = i(e, n, u.normal); let x = []; if (s.contains(e.vertices, m[0]) && x.push(m[0]), s.contains(e.vertices, m[1]) && x.push(m[1]), x.length < 2) { const w = i(n, e, r.neg(u.normal)); s.contains(n.vertices, w[0]) && x.push(w[0]), x.length < 2 && s.contains(n.vertices, w[1]) && x.push(w[1]); } return x.length < 1 && (x = [m[0]]), u.supports = x, u; }; var t = function (t, i, n) { for (var s, o, a = r._temp[0], h = r._temp[1], l = { overlap: Number.MAX_VALUE }, u = 0; u < n.length; u++) { if (o = n[u], e(a, t, o), e(h, i, o), (s = Math.min(a.max - h.min, h.max - a.min)) <= 0) return l.overlap = s, l; s < l.overlap && (l.overlap = s, l.axis = o, l.axisNumber = u); } return l; }; var e = function (t, e, i) { for (var n = r.dot(e[0], i), s = n, o = 1; o < e.length; o += 1) { const a = r.dot(e[o], i); a > s ? s = a : a < n && (n = a); }t.min = n, t.max = s; }; var i = function (t, e, i) { for (var n, s, o, a, h = Number.MAX_VALUE, l = r._temp[0], u = e.vertices, c = t.position, d = 0; d < u.length; d++)s = u[d], l.x = s.x - c.x, l.y = s.y - c.y, (n = -r.dot(i, l)) < h && (h = n, o = s); return s = u[o.index - 1 >= 0 ? o.index - 1 : u.length - 1], l.x = s.x - c.x, l.y = s.y - c.y, h = -r.dot(i, l), a = s, s = u[(o.index + 1) % u.length], l.x = s.x - c.x, l.y = s.y - c.y, (n = -r.dot(i, l)) < h && (a = s), [o, a]; }; }()); }, function (t, e, i) { const n = {}; t.exports = n; const s = i(672); const r = i(605); const o = i(139); n.collisions = function (t, e) { for (var i = [], a = e.pairs.table, h = e.metrics, l = 0; l < t.length; l++) { const u = t[l][0]; const c = t[l][1]; if ((!u.isStatic && !u.isSleeping || !c.isStatic && !c.isSleeping) && n.canCollide(u.collisionFilter, c.collisionFilter) && (h.midphaseTests += 1, o.overlaps(u.bounds, c.bounds))) for (let d = u.parts.length > 1 ? 1 : 0; d < u.parts.length; d++) for (let f = u.parts[d], p = c.parts.length > 1 ? 1 : 0; p < c.parts.length; p++) { const g = c.parts[p]; if (f === u && g === c || o.overlaps(f.bounds, g.bounds)) { var v; const y = a[r.id(f, g)]; v = y && y.isActive ? y.collision : null; const m = s.collides(f, g, v); h.narrowphaseTests += 1, m.reused && (h.narrowReuseCount += 1), m.collided && (i.push(m), h.narrowDetections += 1); } } } return i; }, n.canCollide = function (t, e) { return t.group === e.group && t.group !== 0 ? t.group > 0 : (t.mask & e.category) != 0 && (e.mask & t.category) != 0; }; }, function (t, e, i) {
  const n = i(220); const s = i(80); const r = i(0); const o = i(606); const a = i(1); const h = i(108); const l = i(140); const u = new r({
    Mixins: [o.Bounce, o.Collision, o.Friction, o.Gravity, o.Mass, o.Sensor, o.Sleep, o.Static], initialize(t, e, i) { this.tile = e, this.world = t, e.physics.matterBody && e.physics.matterBody.destroy(), e.physics.matterBody = this; const n = a(i, 'body', null); const s = a(i, 'addToWorld', !0); if (n) this.setBody(n, s); else { const r = e.getCollisionGroup(); a(r, 'objects', []).length > 0 ? this.setFromTileCollision(i) : this.setFromTileRectangle(i); } }, setFromTileRectangle(t) { void 0 === t && (t = {}), h(t, 'isStatic') || (t.isStatic = !0), h(t, 'addToWorld') || (t.addToWorld = !0); const e = this.tile.getBounds(); const i = e.x + e.width / 2; const s = e.y + e.height / 2; const r = n.rectangle(i, s, e.width, e.height, t); return this.setBody(r, t.addToWorld), this; }, setFromTileCollision(t) { void 0 === t && (t = {}), h(t, 'isStatic') || (t.isStatic = !0), h(t, 'addToWorld') || (t.addToWorld = !0); for (var e = this.tile.tilemapLayer.scaleX, i = this.tile.tilemapLayer.scaleY, r = this.tile.getLeft(), o = this.tile.getTop(), u = this.tile.getCollisionGroup(), c = a(u, 'objects', []), d = [], f = 0; f < c.length; f++) { const p = c[f]; let g = r + p.x * e; let v = o + p.y * i; const y = p.width * e; const m = p.height * i; let x = null; if (p.rectangle)x = n.rectangle(g + y / 2, v + m / 2, y, m, t); else if (p.ellipse)x = n.circle(g + y / 2, v + m / 2, y / 2, t); else if (p.polygon || p.polyline) { const w = (p.polygon ? p.polygon : p.polyline).map((t) => ({ x: t.x * e, y: t.y * i })); const b = l.create(w); if (l.isConvex(w)) { const T = l.centre(b); g += T.x, v += T.y; }x = n.fromVertices(g, v, b, t); }x && d.push(x); } return d.length === 1 ? this.setBody(d[0], t.addToWorld) : d.length > 1 && (t.parts = d, this.setBody(s.create(t), t.addToWorld)), this; }, setBody(t, e) { return void 0 === e && (e = !0), this.body && this.removeBody(), this.body = t, this.body.gameObject = this, e && this.world.add(this.body), this; }, removeBody() { return this.body && (this.world.remove(this.body), this.body.gameObject = void 0, this.body = void 0), this; }, destroy() { this.removeBody(), this.tile.physics.matterBody = void 0; },
  }); t.exports = u;
}, function (t, e, i) { const n = {}; t.exports = n; const s = i(123); const r = i(49); n.fromVertices = function (t) { for (var e = {}, i = 0; i < t.length; i++) { const n = (i + 1) % t.length; const o = s.normalise({ x: t[n].y - t[i].y, y: t[i].x - t[n].x }); let a = o.y === 0 ? 1 / 0 : o.x / o.y; e[a = a.toFixed(3).toString()] = o; } return r.values(e); }, n.rotate = function (t, e) { if (e !== 0) for (let i = Math.cos(e), n = Math.sin(e), s = 0; s < t.length; s++) { var r; const o = t[s]; r = o.x * i - o.y * n, o.y = o.x * n + o.y * i, o.x = r; } }; }, function (t, e, i) {
  t.exports = {
    Acceleration: i(1060), BodyScale: i(1059), BodyType: i(1058), Bounce: i(1057), CheckAgainst: i(1056), Collides: i(1055), Debug: i(1054), Friction: i(1053), Gravity: i(1052), Offset: i(1051), SetGameObject: i(1050), Velocity: i(1049),
  };
}, function (t, e, i) { const n = i(336); t.exports = function (t, e, i, s) { let r = n(t, e, i, s); if (i || r === 0 || t.immovable && e.immovable || t.customSeparateY || e.customSeparateY) return r !== 0 || t.embedded && e.embedded; const o = t.velocity.y; const a = e.velocity.y; if (t.immovable || e.immovable)t.immovable ? (e.y += r, e.velocity.y = o - a * e.bounce.y, t.moves && (e.x += (t.x - t.prev.x) * t.friction.x)) : (t.y -= r, t.velocity.y = a - o * t.bounce.y, e.moves && (t.x += (e.x - e.prev.x) * e.friction.x)); else { r *= 0.5, t.y -= r, e.y += r; let h = Math.sqrt(a * a * e.mass / t.mass) * (a > 0 ? 1 : -1); let l = Math.sqrt(o * o * t.mass / e.mass) * (o > 0 ? 1 : -1); const u = 0.5 * (h + l); h -= u, l -= u, t.velocity.y = u + h * t.bounce.y, e.velocity.y = u + l * e.bounce.y; } return !0; }; }, function (t, e, i) { const n = i(337); t.exports = function (t, e, i, s) { let r = n(t, e, i, s); if (i || r === 0 || t.immovable && e.immovable || t.customSeparateX || e.customSeparateX) return r !== 0 || t.embedded && e.embedded; const o = t.velocity.x; const a = e.velocity.x; if (t.immovable || e.immovable)t.immovable ? (e.x += r, e.velocity.x = o - a * e.bounce.x, t.moves && (e.y += (t.y - t.prev.y) * t.friction.y)) : (t.x -= r, t.velocity.x = a - o * t.bounce.x, e.moves && (t.y += (e.y - e.prev.y) * e.friction.y)); else { r *= 0.5, t.x -= r, e.x += r; let h = Math.sqrt(a * a * e.mass / t.mass) * (a > 0 ? 1 : -1); let l = Math.sqrt(o * o * t.mass / e.mass) * (o > 0 ? 1 : -1); const u = 0.5 * (h + l); h -= u, l -= u, t.velocity.x = u + h * t.bounce.x, e.velocity.x = u + l * e.bounce.x; } return !0; }; }, function (t, e) { t.exports = function (t, e) { e < 0 ? t.blocked.up = !0 : e > 0 && (t.blocked.down = !0), t.position.y -= e, t.bounce.y === 0 ? t.velocity.y = 0 : t.velocity.y = -t.velocity.y * t.bounce.y; }; }, function (t, e, i) { const n = i(679); t.exports = function (t, e, i, s, r) { let o = 0; return t.deltaY() < 0 && !t.blocked.up && e.collideDown && t.checkCollision.up ? e.faceBottom && t.y < s && (o = t.y - s) < -r && (o = 0) : t.deltaY() > 0 && !t.blocked.down && e.collideUp && t.checkCollision.down && e.faceTop && t.bottom > i && (o = t.bottom - i) > r && (o = 0), o !== 0 && (t.customSeparateY ? t.overlapY = o : n(t, o)), o; }; }, function (t, e) { t.exports = function (t, e) { e < 0 ? t.blocked.left = !0 : e > 0 && (t.blocked.right = !0), t.position.x -= e, t.bounce.x === 0 ? t.velocity.x = 0 : t.velocity.x = -t.velocity.x * t.bounce.x; }; }, function (t, e, i) { const n = i(681); t.exports = function (t, e, i, s, r) { let o = 0; return t.deltaX() < 0 && !t.blocked.left && e.collideRight && t.checkCollision.left ? e.faceRight && t.x < s && (o = t.x - s) < -r && (o = 0) : t.deltaX() > 0 && !t.blocked.right && e.collideLeft && t.checkCollision.right && e.faceLeft && t.right > i && (o = t.right - i) > r && (o = 0), o !== 0 && (t.customSeparateX ? t.overlapX = o : n(t, o)), o; }; }, function (t, e, i) { const n = i(682); const s = i(680); const r = i(335); t.exports = function (t, e, i, o, a, h) { const l = o.left; const u = o.top; const c = o.right; const d = o.bottom; const f = i.faceLeft || i.faceRight; const p = i.faceTop || i.faceBottom; if (!f && !p) return !1; let g = 0; let v = 0; let y = 0; let m = 1; if (e.deltaAbsX() > e.deltaAbsY() ? y = -1 : e.deltaAbsX() < e.deltaAbsY() && (m = -1), e.deltaX() !== 0 && e.deltaY() !== 0 && f && p && (y = Math.min(Math.abs(e.position.x - c), Math.abs(e.right - l)), m = Math.min(Math.abs(e.position.y - d), Math.abs(e.bottom - u))), y < m) { if (f && (g = n(e, i, l, c, h)) !== 0 && !r(o, e)) return !0; p && (v = s(e, i, u, d, h)); } else { if (p && (v = s(e, i, u, d, h)) !== 0 && !r(o, e)) return !0; f && (g = n(e, i, l, c, h)); } return g !== 0 || v !== 0; }; }, function (t, e) { t.exports = function (t, e) { return t.collisionCallback ? !t.collisionCallback.call(t.collisionCallbackContext, e, t) : !t.layer.callbacks[t.index] || !t.layer.callbacks[t.index].callback.call(t.layer.callbacks[t.index].callbackContext, e, t); }; }, function (t, e) {
  t.exports = {
    setVelocity(t, e) { return this.body.velocity.set(t, e), this; }, setVelocityX(t) { return this.body.velocity.x = t, this; }, setVelocityY(t) { return this.body.velocity.y = t, this; }, setMaxVelocity(t, e) { return this.body.maxVelocity.set(t, e), this; },
  };
}, function (t, e) { t.exports = { setOffset(t, e) { return this.body.setOffset(t, e), this; }, setSize(t, e, i) { return this.body.setSize(t, e, i), this; }, setCircle(t, e, i) { return this.body.setCircle(t, e, i), this; } }; }, function (t, e) { t.exports = { setMass(t) { return this.body.mass = t, this; } }; }, function (t, e) { const i = { setImmovable(t) { return void 0 === t && (t = !0), this.body.immovable = t, this; } }; t.exports = i; }, function (t, e) { t.exports = { setGravity(t, e) { return this.body.gravity.set(t, e), this; }, setGravityX(t) { return this.body.gravity.x = t, this; }, setGravityY(t) { return this.body.gravity.y = t, this; } }; }, function (t, e) { t.exports = { setFriction(t, e) { return this.body.friction.set(t, e), this; }, setFrictionX(t) { return this.body.friction.x = t, this; }, setFrictionY(t) { return this.body.friction.y = t, this; } }; }, function (t, e) { const i = { enableBody(t, e, i, n, s) { return t && this.body.reset(e, i), n && (this.body.gameObject.active = !0), s && (this.body.gameObject.visible = !0), this.body.enable = !0, this; }, disableBody(t, e) { return void 0 === t && (t = !1), void 0 === e && (e = !1), this.body.stop(), this.body.enable = !1, t && (this.body.gameObject.active = !1), e && (this.body.gameObject.visible = !1), this; }, refreshBody() { return this.body.updateFromGameObject(), this; } }; t.exports = i; }, function (t, e) { t.exports = { setDrag(t, e) { return this.body.drag.set(t, e), this; }, setDragX(t) { return this.body.drag.x = t, this; }, setDragY(t) { return this.body.drag.y = t, this; } }; }, function (t, e) {
  t.exports = {
    setDebug(t, e, i) { return this.debugShowBody = t, this.debugShowVelocity = e, this.debugBodyColor = i, this; }, setDebugBodyColor(t) { return this.body.debugBodyColor = t, this; }, debugShowBody: { get() { return this.body.debugShowBody; }, set(t) { this.body.debugShowBody = t; } }, debugShowVelocity: { get() { return this.body.debugShowVelocity; }, set(t) { this.body.debugShowVelocity = t; } }, debugBodyColor: { get() { return this.body.debugBodyColor; }, set(t) { this.body.debugBodyColor = t; } },
  };
}, function (t, e) {
  t.exports = {
    setBounce(t, e) { return this.body.bounce.set(t, e), this; }, setBounceX(t) { return this.body.bounce.x = t, this; }, setBounceY(t) { return this.body.bounce.y = t, this; }, setCollideWorldBounds(t) { return this.body.collideWorldBounds = t, this; },
  };
}, function (t, e) { t.exports = { setAngularVelocity(t) { return this.body.angularVelocity = t, this; }, setAngularAcceleration(t) { return this.body.angularAcceleration = t, this; }, setAngularDrag(t) { return this.body.angularDrag = t, this; } }; }, function (t, e) { t.exports = { setAcceleration(t, e) { return this.body.acceleration.set(t, e), this; }, setAccelerationX(t) { return this.body.acceleration.x = t, this; }, setAccelerationY(t) { return this.body.acceleration.y = t, this; } }; }, function (t, e, i) {
  const n = i(0); const s = i(38); const r = i(57); const o = i(345); const a = i(1); const h = i(93); const l = i(12); const u = i(7); const c = i(340); const d = new n({
    initialize(t) { this.scene = t, this.systems = t.sys, this.config = this.getConfig(), this.world, this.add, t.sys.events.once('boot', this.boot, this), t.sys.events.on('start', this.start, this); }, boot() { this.world = new c(this.scene, this.config), this.add = new o(this.world), this.systems.events.once('destroy', this.destroy, this); }, start() { this.world || (this.world = new c(this.scene, this.config), this.add = new o(this.world)); const t = this.systems.events; t.on('update', this.world.update, this.world), t.on('postupdate', this.world.postUpdate, this.world), t.once('shutdown', this.shutdown, this); }, getConfig() { const t = this.systems.game.config.physics; const e = this.systems.settings.physics; return h(a(e, 'arcade', {}), a(t, 'arcade', {})); }, overlap(t, e, i, n, s) { return void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = i), this.world.collideObjects(t, e, i, n, s, !0); }, collide(t, e, i, n, s) { return void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = i), this.world.collideObjects(t, e, i, n, s, !1); }, pause() { return this.world.pause(); }, resume() { return this.world.resume(); }, accelerateTo(t, e, i, n, s, r) { void 0 === n && (n = 60); const o = Math.atan2(i - t.y, e - t.x); return t.body.acceleration.setToPolar(o, n), void 0 !== s && void 0 !== r && t.body.maxVelocity.set(s, r), o; }, accelerateToObject(t, e, i, n, s) { return this.accelerateTo(t, e.x, e.y, i, n, s); }, closest(t) { for (var e = this.tree.all(), i = Number.MAX_VALUE, n = null, s = t.x, o = t.y, a = e.length - 1; a >= 0; a--) { const h = e[a]; const l = r(s, o, h.x, h.y); l < i && (n = h, i = l); } return n; }, furthest(t) { for (var e = this.tree.all(), i = -1, n = null, s = t.x, o = t.y, a = e.length - 1; a >= 0; a--) { const h = e[a]; const l = r(s, o, h.x, h.y); l > i && (n = h, i = l); } return n; }, moveTo(t, e, i, n, s) { void 0 === n && (n = 60), void 0 === s && (s = 0); const o = Math.atan2(i - t.y, e - t.x); return s > 0 && (n = r(t.x, t.y, e, i) / (s / 1e3)), t.body.velocity.setToPolar(o, n), o; }, moveToObject(t, e, i, n) { return this.moveTo(t, e.x, e.y, i, n); }, velocityFromAngle(t, e, i) { return void 0 === e && (e = 60), void 0 === i && (i = new u()), i.setToPolar(s(t), e); }, velocityFromRotation(t, e, i) { return void 0 === e && (e = 60), void 0 === i && (i = new u()), i.setToPolar(t, e); }, shutdown() { const t = this.systems.events; t.off('update', this.world.update, this.world), t.off('postupdate', this.world.postUpdate, this.world), t.off('shutdown', this.shutdown, this), this.add.destroy(), this.world.destroy(), this.add = null, this.world = null; }, destroy() { this.shutdown(), this.scene.sys.events.off('start', this.start, this), this.scene = null, this.systems = null; },
  }); l.register('ArcadePhysics', d, 'arcadePhysics'), t.exports = d;
}, function (t, e, i) {
  const n = i(67); const s = i(18); let r = {
    ArcadePhysics: i(697), Body: i(339), Collider: i(338), Factory: i(345), Group: i(342), Image: i(344), Sprite: i(141), StaticBody: i(334), StaticGroup: i(341), World: i(340),
  }; r = s(!1, r, n), t.exports = r;
}, function (t, e) { t.exports = function (t, e, i) { return Math.abs(t - e) <= i; }; }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === n && (n = 1), n *= Math.PI / t; for (var s = [], r = [], o = 0; o < t; o++)e += (i -= e * n) * n, s[o] = i, r[o] = e; return { sin: r, cos: s, length: t }; }; }, function (t, e) { t.exports = function (t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = 10); const n = Math.pow(i, -e); return Math.round(t * n) / n; }; }, function (t, e) { t.exports = function (t, e) { void 0 === e && (e = 1); const i = 2 * Math.random() * Math.PI; return t.x = Math.cos(i) * e, t.y = Math.sin(i) * e, t; }; }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === i && (i = e + 1); let s = (t - e) / (i - e); return s > 1 ? void 0 !== n ? (s = (n - t) / (n - i)) < 0 && (s = 0) : s = 1 : s < 0 && (s = 0), s; }; }, function (t, e) { t.exports = function (t, e, i) { return Math.max(t - e, i); }; }, function (t, e) { t.exports = function (t, e, i) { return Math.min(t + e, i); }; }, function (t, e) { t.exports = function (t) { return t === parseFloat(t) ? !(t % 2) : void 0; }; }, function (t, e) { t.exports = function (t) { return t == parseFloat(t) ? !(t % 2) : void 0; }; }, function (t, e) { t.exports = function (t, e) { return t / e / 1e3; }; }, function (t, e) { t.exports = function (t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = 10); const n = Math.pow(i, -e); return Math.floor(t * n) / n; }; }, function (t, e) { t.exports = function (t, e) { return Math.abs(t - e); }; }, function (t, e) { t.exports = function (t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = 10); const n = Math.pow(i, -e); return Math.ceil(t * n) / n; }; }, function (t, e) { t.exports = function (t) { for (var e = 0, i = 0; i < t.length; i++)e += +t[i]; return e / t.length; }; }, function (t, e) { t.exports = function (t, e, i) { return void 0 === i && (i = 0), e === 0 ? t : (t -= i, i + (t = e * Math.round(t / e))); }; }, function (t, e) { t.exports = function (t, e, i) { return void 0 === i && (i = 0), e === 0 ? t : (t -= i, i + (t = e * Math.floor(t / e))); }; }, function (t, e) { t.exports = function (t, e, i) { return void 0 === i && (i = 0), e === 0 ? t : (t -= i, i + (t = e * Math.ceil(t / e))); }; }, function (t, e, i) { t.exports = { Ceil: i(715), Floor: i(714), To: i(713) }; }, function (t, e) { t.exports = function (t) { return t > 0 && (t & t - 1) == 0; }; }, function (t, e, i) { t.exports = { GetNext: i(398), IsSize: i(84), IsValue: i(717) }; }, function (t, e, i) { const n = i(287); t.exports = function (t, e, i) { return e + (i - e) * n(t, 0, 1); }; }, function (t, e, i) { const n = i(286); t.exports = function (t, e, i) { return e + (i - e) * n(t, 0, 1); }; }, function (t, e, i) { const n = i(120); t.exports = function (t, e) { const i = t.length - 1; const s = i * e; const r = Math.floor(s); return e < 0 ? n(t[0], t[1], s) : e > 1 ? n(t[i], t[i - 1], i - s) : n(t[r], t[r + 1 > i ? i : r + 1], s - r); }; }, function (t, e, i) { const n = i(273); t.exports = function (t, e) { const i = t.length - 1; let s = i * e; let r = Math.floor(s); return t[0] === t[i] ? (e < 0 && (r = Math.floor(s = i * (1 + e))), n(s - r, t[(r - 1 + i) % i], t[r], t[(r + 1) % i], t[(r + 2) % i])) : e < 0 ? t[0] - (n(-s, t[0], t[0], t[1], t[1]) - t[0]) : e > 1 ? t[i] - (n(s - i, t[i], t[i], t[i - 1], t[i - 1]) - t[i]) : n(s - r, t[r ? r - 1 : 0], t[r], t[i < r + 1 ? i : r + 1], t[i < r + 2 ? i : r + 2]); }; }, function (t, e, i) { const n = i(348); t.exports = function (t, e) { for (var i = 0, s = t.length - 1, r = 0; r <= s; r++)i += Math.pow(1 - e, s - r) * Math.pow(e, r) * t[r] * n(s, r); return i; }; }, function (t, e, i) {
  t.exports = {
    Bezier: i(723), CatmullRom: i(722), CubicBezier: i(543), Linear: i(721), QuadraticBezier: i(539), SmoothStep: i(720), SmootherStep: i(719),
  };
}, function (t, e) { t.exports = function (t, e, i) { return void 0 === i && (i = 1e-4), t < e + i; }; }, function (t, e) { t.exports = function (t, e, i) { return void 0 === i && (i = 1e-4), t > e - i; }; }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = 1e-4), Math.floor(t + e); }; }, function (t, e) { t.exports = function (t, e, i) { return void 0 === i && (i = 1e-4), Math.abs(t - e) < i; }; }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = 1e-4), Math.ceil(t - e); }; }, function (t, e, i) {
  t.exports = {
    Ceil: i(729), Equal: i(728), Floor: i(727), GreaterThan: i(726), LessThan: i(725),
  };
}, function (t, e, i) {
  t.exports = {
    Back: i(246), Bounce: i(245), Circular: i(244), Cubic: i(243), Elastic: i(242), Expo: i(241), Linear: i(240), Quadratic: i(239), Quartic: i(238), Quintic: i(237), Sine: i(236), Stepped: i(235),
  };
}, function (t, e) { t.exports = function (t, e, i, n) { const s = t - i; const r = e - n; return s * s + r * r; }; }, function (t, e) { t.exports = function (t, e, i, n, s) { return void 0 === s && (s = 2), Math.sqrt(Math.pow(i - t, s) + Math.pow(n - e, s)); }; }, function (t, e, i) { t.exports = { Between: i(57), Power: i(733), Squared: i(732) }; }, function (t, e) { t.exports = function (t, e) { const i = e - t; return i === 0 ? 0 : i - 360 * Math.floor((i - -180) / 360); }; }, function (t, e, i) { const n = i(16); t.exports = function (t, e, i) { return void 0 === i && (i = 0.05), t === e ? t : (Math.abs(e - t) <= i || Math.abs(e - t) >= n.PI2 - i ? t = e : (Math.abs(e - t) > Math.PI && (e < t ? e += n.PI2 : e -= n.PI2), e > t ? t += i : e < t && (t -= i)), t); }; }, function (t, e, i) { const n = i(349); t.exports = function (t) { return n(t + Math.PI); }; }, function (t, e) { t.exports = function (t, e) { return Math.atan2(e.x - t.x, e.y - t.y); }; }, function (t, e) { t.exports = function (t, e) { return Math.atan2(e.y - t.y, e.x - t.x); }; }, function (t, e) { t.exports = function (t, e, i, n) { return Math.atan2(i - t, n - e); }; }, function (t, e) { t.exports = function (t, e, i, n) { return Math.atan2(n - e, i - t); }; }, function (t, e, i) {
  t.exports = {
    Between: i(741), BetweenY: i(740), BetweenPoints: i(739), BetweenPointsY: i(738), Reverse: i(737), RotateTo: i(736), ShortestBetween: i(735), Normalize: i(349), Wrap: i(210), WrapDegrees: i(209),
  };
}, function (t, e, i) {
  const n = i(16); const s = i(18); let r = {
    Angle: i(742), Distance: i(734), Easing: i(731), Fuzzy: i(730), Interpolation: i(724), Pow2: i(718), Snap: i(716), RandomDataGenerator: i(297), Average: i(712), Bernstein: i(348), Between: i(271), CatmullRom: i(273), CeilTo: i(711), Clamp: i(23), DegToRad: i(38), Difference: i(710), Factorial: i(347), FloatBetween: i(247), FloorTo: i(709), FromPercent: i(64), GetSpeed: i(708), IsEven: i(707), IsEvenStrict: i(706), Linear: i(120), MaxAdd: i(705), MinSub: i(704), Percent: i(703), RadToDeg: i(148), RandomXY: i(702), RandomXYZ: i(554), RandomXYZW: i(553), Rotate: i(346), RotateAround: i(292), RotateAroundDistance: i(288), RoundAwayFromZero: i(254), RoundTo: i(701), SinCosTableGenerator: i(700), SmootherStep: i(287), SmoothStep: i(286), TransformXY: i(256), Within: i(699), Wrap: i(39), Vector2: i(7), Vector3: i(86), Vector4: i(277), Matrix3: i(550), Matrix4: i(278), Quaternion: i(551), RotateVec3: i(552),
  }; r = s(!1, r, n), t.exports = r;
}, function (t, e, i) {
  const n = i(0); const s = i(6); const r = i(1); const o = i(37); const a = i(8); const h = i(36); const l = i(223); const u = new n({
    Extends: h,
    initialize(t, e, i, n, s, u) {
      let c; let d; if (a(e)) {
        const f = e; c = new o(t, {
          key: e, url: r(f, 'textureURL'), extension: r(f, 'textureExtension', 'png'), normalMap: r(f, 'normalMap'), xhrSettings: r(f, 'textureXhrSettings'),
        }), d = new l(t, {
          key: e, url: r(f, 'atlasURL'), extension: r(f, 'atlasExtension', 'txt'), xhrSettings: r(f, 'atlasXhrSettings'),
        });
      } else c = new o(t, e, i, s), d = new l(t, e, n, u); c.linkFile ? h.call(this, t, 'unityatlas', e, [c, d, c.linkFile]) : h.call(this, t, 'unityatlas', e, [c, d]);
    },
    addToCache() { if (this.failed === 0 && !this.complete) { const t = this.files[0]; const e = this.files[1]; const i = this.files[2] ? this.files[2].data : null; this.loader.textureManager.addUnityAtlas(t.key, t.data, e.data, i), e.addToCache(), this.complete = !0; } },
  }); s.register('unityAtlas', function (t, e, i, n, s) { let r; if (Array.isArray(t)) for (let o = 0; o < t.length; o++)r = new u(this, t[o]), this.addFile(r.files); else r = new u(this, t, e, i, n, s), this.addFile(r.files); return this; }), t.exports = u;
}, function (t, e, i) { const n = i(0); const s = i(6); const r = i(28); const o = i(26); const a = new n({ Extends: r, initialize(t, e, i, n) { r.call(this, t, e, i, n), this.type = 'tilemapJSON', this.cache = t.cacheManager.tilemap; }, addToCache() { const t = { format: o.TILED_JSON, data: this.data }; this.cache.add(this.key, t), this.pendingDestroy(t); } }); s.register('tilemapTiledJSON', function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new a(this, t[n])); else this.addFile(new a(this, t, e, i)); return this; }), t.exports = a; }, function (t, e, i) { const n = i(0); const s = i(6); const r = i(28); const o = i(26); const a = new n({ Extends: r, initialize(t, e, i, n) { r.call(this, t, e, i, n), this.type = 'tilemapJSON', this.cache = t.cacheManager.tilemap; }, addToCache() { const t = { format: o.WELTMEISTER, data: this.data }; this.cache.add(this.key, t), this.pendingDestroy(t); } }); s.register('tilemapImpact', function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new a(this, t[n])); else this.addFile(new a(this, t, e, i)); return this; }), t.exports = a; }, function (t, e, i) {
  const n = i(0); const s = i(17); const r = i(19); const o = i(6); const a = i(1); const h = i(8); const l = i(26); const u = new n({
    Extends: r,
    initialize(t, e, i, n) {
      let s = 'csv'; if (h(e)) { const o = e; e = a(o, 'key'), i = a(o, 'url'), n = a(o, 'xhrSettings'), s = a(o, 'extension', s); } const u = {
        type: 'tilemapCSV', cache: t.cacheManager.tilemap, extension: s, responseType: 'text', key: e, url: i, xhrSettings: n,
      }; r.call(this, t, u), this.tilemapFormat = l.CSV;
    },
    onProcess() { this.state = s.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete(); },
    addToCache() { const t = { format: this.tilemapFormat, data: this.data }; this.cache.add(this.key, t), this.pendingDestroy(t); },
  }); o.register('tilemapCSV', function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new u(this, t[n])); else this.addFile(new u(this, t, e, i)); return this; }), t.exports = u;
}, function (t, e, i) {
  const n = i(0); const s = i(17); const r = i(19); const o = i(6); const a = i(1); const h = i(8); const l = new n({
    Extends: r,
    initialize(t, e, i, n) {
      let s = 'svg'; if (h(e)) { const o = e; e = a(o, 'key'), i = a(o, 'url'), n = a(o, 'xhrSettings'), s = a(o, 'extension', s); } const l = {
        type: 'svg', cache: t.textureManager, extension: s, responseType: 'text', key: e, url: i, xhrSettings: n,
      }; r.call(this, t, l);
    },
    onProcess() { this.state = s.FILE_PROCESSING; const t = [this.xhrLoader.responseText]; try { var e = new window.Blob(t, { type: 'image/svg+xml;charset=utf-8' }); } catch (t) { return void this.onProcessError(); } this.data = new Image(), this.data.crossOrigin = this.crossOrigin; const i = this; let n = !1; this.data.onload = function () { n || r.revokeObjectURL(i.data), i.onProcessComplete(); }, this.data.onerror = function () { n ? i.onProcessError() : (n = !0, r.revokeObjectURL(i.data), i.data.src = `data:image/svg+xml,${encodeURIComponent(t.join(''))}`); }, r.createObjectURL(this.data, e, 'image/svg+xml'); },
    addToCache() { const t = this.cache.addImage(this.key, this.data); this.pendingDestroy(t); },
  }); o.register('svg', function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new l(this, t[n])); else this.addFile(new l(this, t, e, i)); return this; }), t.exports = l;
}, function (t, e, i) {
  const n = i(0); const s = i(17); const r = i(19); const o = i(6); const a = i(1); const h = i(8); const l = new n({
    Extends: r,
    initialize(t, e, i, n, o, l) {
      let u = 'js'; if (h(e)) { const c = e; e = a(c, 'key'), i = a(c, 'url'), l = a(c, 'xhrSettings'), u = a(c, 'extension', u), n = a(c, 'systemKey'), o = a(c, 'sceneKey'); } const d = {
        type: 'scenePlugin', cache: !1, extension: u, responseType: 'text', key: e, url: i, xhrSettings: l, config: { systemKey: n, sceneKey: o },
      }; r.call(this, t, d), typeof i === 'function' && (this.data = i, this.state = s.FILE_POPULATED);
    },
    onProcess() { const t = this.loader.systems.plugins; const e = this.config; const i = this.key; const n = a(e, 'systemKey', i); const r = a(e, 'sceneKey', i); this.state === s.FILE_POPULATED ? t.installScenePlugin(n, this.data, r, this.loader.scene) : (this.state = s.FILE_PROCESSING, this.data = document.createElement('script'), this.data.language = 'javascript', this.data.type = 'text/javascript', this.data.defer = !1, this.data.text = this.xhrLoader.responseText, document.head.appendChild(this.data), t.installScenePlugin(n, window[this.key], r, this.loader.scene)), this.onProcessComplete(); },
  }); o.register('scenePlugin', function (t, e, i, n, s) { if (Array.isArray(t)) for (let r = 0; r < t.length; r++) this.addFile(new l(this, t[r])); else this.addFile(new l(this, t, e, i, n, s)); return this; }), t.exports = l;
}, function (t, e, i) { const n = i(0); const s = i(17); const r = i(6); const o = i(28); const a = new n({ Extends: o, initialize(t, e, i, n, s) { o.call(this, t, e, i, n, s), this.type = 'packfile'; }, onProcess() { this.state !== s.FILE_POPULATED && (this.state = s.FILE_PROCESSING, this.data = JSON.parse(this.xhrLoader.responseText)), this.loader.addPack(this.data, this.config), this.onProcessComplete(); } }); r.register('pack', function (t, e, i, n) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new a(this, t[s])); else this.addFile(new a(this, t, e, n, i)); return this; }), t.exports = a; }, function (t, e, i) {
  const n = i(0); const s = i(17); const r = i(19); const o = i(6); const a = i(1); const h = i(8); const l = new n({
    Extends: r,
    initialize(t, e, i, n, s, o) {
      void 0 === n && (n = 512), void 0 === s && (s = 512); let l = 'html'; if (h(e)) { const u = e; e = a(u, 'key'), i = a(u, 'url'), o = a(u, 'xhrSettings'), l = a(u, 'extension', l), n = a(u, 'width', n), s = a(u, 'height', s); } const c = {
        type: 'html', cache: t.textureManager, extension: l, responseType: 'text', key: e, url: i, xhrSettings: o, config: { width: n, height: s },
      }; r.call(this, t, c);
    },
    onProcess() { this.state = s.FILE_PROCESSING; const t = this.config.width; const e = this.config.height; const i = []; i.push(`<svg width="${t}px" height="${e}px" viewBox="0 0 ${t} ${e}" xmlns="http://www.w3.org/2000/svg">`), i.push('<foreignObject width="100%" height="100%">'), i.push('<body xmlns="http://www.w3.org/1999/xhtml">'), i.push(this.xhrLoader.responseText), i.push('</body>'), i.push('</foreignObject>'), i.push('</svg>'); const n = [i.join('\n')]; const o = this; try { var a = new window.Blob(n, { type: 'image/svg+xml;charset=utf-8' }); } catch (t) { return o.state = s.FILE_ERRORED, void o.onProcessComplete(); } this.data = new Image(), this.data.crossOrigin = this.crossOrigin, this.data.onload = function () { r.revokeObjectURL(o.data), o.onProcessComplete(); }, this.data.onerror = function () { r.revokeObjectURL(o.data), o.onProcessError(); }, r.createObjectURL(this.data, a, 'image/svg+xml'); },
    addToCache() { const t = this.cache.addImage(this.key, this.data); this.pendingDestroy(t); },
  }); o.register('html', function (t, e, i, n, s) { if (Array.isArray(t)) for (let r = 0; r < t.length; r++) this.addFile(new l(this, t[r])); else this.addFile(new l(this, t, e, i, n, s)); return this; }), t.exports = l;
}, function (t, e, i) {
  const n = i(0); const s = i(17); const r = i(19); const o = i(6); const a = i(1); const h = i(8); const l = new n({
    Extends: r,
    initialize(t, e, i, n) {
      let s = 'glsl'; if (h(e)) { const o = e; e = a(o, 'key'), i = a(o, 'url'), n = a(o, 'xhrSettings'), s = a(o, 'extension', s); } const l = {
        type: 'glsl', cache: t.cacheManager.shader, extension: s, responseType: 'text', key: e, url: i, xhrSettings: n,
      }; r.call(this, t, l);
    },
    onProcess() { this.state = s.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete(); },
  }); o.register('glsl', function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new l(this, t[n])); else this.addFile(new l(this, t, e, i)); return this; }), t.exports = l;
}, function (t, e, i) {
  const n = i(0); const s = i(6); const r = i(1); const o = i(37); const a = i(8); const h = i(36); const l = i(461); const u = i(142); const c = new n({
    Extends: h,
    initialize(t, e, i, n, s, l) {
      let c; let d; if (a(e)) {
        const f = e; e = r(f, 'key'), c = new o(t, {
          key: e, url: r(f, 'textureURL'), extension: r(f, 'textureExtension', 'png'), normalMap: r(f, 'normalMap'), xhrSettings: r(f, 'textureXhrSettings'),
        }), d = new u(t, {
          key: e, url: r(f, 'fontDataURL'), extension: r(f, 'fontDataExtension', 'xml'), xhrSettings: r(f, 'fontDataXhrSettings'),
        });
      } else c = new o(t, e, i, s), d = new u(t, e, n, l); c.linkFile ? h.call(this, t, 'bitmapfont', e, [c, d, c.linkFile]) : h.call(this, t, 'bitmapfont', e, [c, d]);
    },
    addToCache() { if (this.isReadyToProcess()) { const t = this.files[0]; const e = this.files[1]; t.addToCache(), e.addToCache(), this.loader.cacheManager.bitmapFont.add(t.key, { data: l(e.data), texture: t.key, frame: null }), this.complete = !0; } },
  }); s.register('bitmapFont', function (t, e, i, n, s) { let r; if (Array.isArray(t)) for (let o = 0; o < t.length; o++)r = new c(this, t[o]), this.addFile(r.files); else r = new c(this, t, e, i, n, s), this.addFile(r.files); return this; }), t.exports = c;
}, function (t, e, i) {
  const n = i(0); const s = i(17); const r = i(19); const o = i(6); const a = i(1); const h = i(8); const l = new n({
    Extends: r,
    initialize(t, e, i, n, s) {
      let o = 'bin'; if (h(e)) { const l = e; e = a(l, 'key'), i = a(l, 'url'), n = a(l, 'xhrSettings'), o = a(l, 'extension', o), s = a(l, 'dataType', s); } const u = {
        type: 'binary', cache: t.cacheManager.binary, extension: o, responseType: 'arraybuffer', key: e, url: i, xhrSettings: n, config: { dataType: s },
      }; r.call(this, t, u);
    },
    onProcess() { this.state = s.FILE_PROCESSING; const t = this.config.dataType; this.data = t ? new t(this.xhrLoader.response) : this.xhrLoader.response, this.onProcessComplete(); },
  }); o.register('binary', function (t, e, i, n) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new l(this, t[s])); else this.addFile(new l(this, t, e, n, i)); return this; }), t.exports = l;
}, function (t, e, i) {
  const n = i(0); const s = i(6); const r = i(1); const o = i(37); const a = i(8); const h = i(36); const l = i(142); const u = new n({
    Extends: h,
    initialize(t, e, i, n, s, u) {
      let c; let d; if (a(e)) {
        const f = e; e = r(f, 'key'), c = new o(t, {
          key: e, url: r(f, 'textureURL'), extension: r(f, 'textureExtension', 'png'), normalMap: r(f, 'normalMap'), xhrSettings: r(f, 'textureXhrSettings'),
        }), d = new l(t, {
          key: e, url: r(f, 'atlasURL'), extension: r(f, 'atlasExtension', 'xml'), xhrSettings: r(f, 'atlasXhrSettings'),
        });
      } else c = new o(t, e, i, s), d = new l(t, e, n, u); c.linkFile ? h.call(this, t, 'atlasxml', e, [c, d, c.linkFile]) : h.call(this, t, 'atlasxml', e, [c, d]);
    },
    addToCache() { if (this.isReadyToProcess()) { const t = this.files[0]; const e = this.files[1]; const i = this.files[2] ? this.files[2].data : null; this.loader.textureManager.addAtlasXML(t.key, t.data, e.data, i), e.addToCache(), this.complete = !0; } },
  }); s.register('atlasXML', function (t, e, i, n, s) { let r; if (Array.isArray(t)) for (let o = 0; o < t.length; o++)r = new u(this, t[o]), this.addFile(r.files); else r = new u(this, t, e, i, n, s), this.addFile(r.files); return this; }), t.exports = u;
}, function (t, e, i) {
  t.exports = {
    AnimationJSONFile: i(357), AtlasJSONFile: i(356), AtlasXMLFile: i(755), AudioFile: i(165), AudioSpriteFile: i(355), BinaryFile: i(754), BitmapFontFile: i(753), GLSLFile: i(752), HTML5AudioFile: i(164), HTMLFile: i(751), ImageFile: i(37), JSONFile: i(28), MultiAtlasFile: i(354), PackFile: i(750), PluginFile: i(353), ScenePluginFile: i(749), ScriptFile: i(352), SpriteSheetFile: i(351), SVGFile: i(748), TextFile: i(223), TilemapCSVFile: i(747), TilemapImpactFile: i(746), TilemapJSONFile: i(745), UnityAtlasFile: i(744), XMLFile: i(142),
  };
}, function (t, e, i) {
  const n = i(17); const s = i(18); let r = {
    FileTypes: i(756), File: i(19), FileTypesManager: i(6), GetURL: i(106), LoaderPlugin: i(350), MergeXHRSettings: i(105), MultiFile: i(36), XHRLoader: i(166), XHRSettings: i(74),
  }; r = s(!1, r, n), t.exports = r;
}, function (t, e, i) { const n = i(224); t.exports = function (t, e, i) { return n(t, e.x, e.y, i); }; }, function (t, e, i) { const n = i(224); const s = i(372); t.exports = function (t, e) { const i = s(t); return n(t, i.x, i.y, e); }; }, function (t, e, i) { const n = i(71); t.exports = function (t) { const e = t.getLineA(); const i = t.getLineB(); const s = t.getLineC(); return n(e) + n(i) + n(s); }; }, function (t, e) { t.exports = function (t, e) { return t.x1 === e.x1 && t.y1 === e.y1 && t.x2 === e.x2 && t.y2 === e.y2 && t.x3 === e.x3 && t.y3 === e.y3; }; }, function (t, e) { t.exports = function (t, e) { return e.setTo(t.x1, t.y1, t.x2, t.y2, t.x3, t.y3); }; }, function (t, e, i) { const n = i(59); t.exports = function (t, e) { return n(t, e.x, e.y); }; }, function (t, e, i) { const n = i(68); t.exports = function (t) { return new n(t.x1, t.y1, t.x2, t.y2, t.x3, t.y3); }; }, function (t, e, i) { const n = i(87); t.exports = function (t, e) { void 0 === e && (e = new n()); let i; let s; const r = t.x1; const o = t.y1; const a = t.x2; const h = t.y2; const l = t.x3; const u = t.y3; const c = a - r; const d = h - o; const f = l - r; const p = u - o; const g = c * (r + a) + d * (o + h); const v = f * (r + l) + p * (o + u); const y = 2 * (c * (u - h) - d * (l - a)); if (Math.abs(y) < 1e-6) { const m = Math.min(r, a, l); const x = Math.min(o, h, u); i = 0.5 * (Math.max(r, a, l) - m), s = 0.5 * (Math.max(o, h, u) - x), e.x = m + i, e.y = x + s, e.radius = Math.sqrt(i * i + s * s); } else e.x = (p * g - d * v) / y, e.y = (c * v - f * g) / y, i = e.x - r, s = e.y - o, e.radius = Math.sqrt(i * i + s * s); return e; }; }, function (t, e, i) { const n = i(7); function s(t, e, i, n) { return t * n - e * i; }t.exports = function (t, e) { void 0 === e && (e = new n()); const i = t.x3; const r = t.y3; const o = t.x1 - i; const a = t.y1 - r; const h = t.x2 - i; const l = t.y2 - r; const u = 2 * s(o, a, h, l); const c = s(a, o * o + a * a, l, h * h + l * l); const d = s(o, o * o + a * a, h, h * h + l * l); return e.x = i - c / u, e.y = r + d / u, e; }; }, function (t, e, i) { const n = i(374); const s = i(373); t.exports = function (t, e, i, r) { void 0 === r && (r = n); const o = r(t); const a = e - o.x; const h = i - o.y; return s(t, a, h); }; }, function (t, e, i) { const n = i(68); t.exports = function (t, e, i, s) { return void 0 === s && (s = i), new n(t, e, t, e - s, t + i, e); }; }, function (t, e, i) { const n = i(257); const s = i(68); t.exports = function (t, e, i, r, o) { void 0 === e && (e = null), void 0 === i && (i = 1), void 0 === r && (r = 1), void 0 === o && (o = []); for (var a, h, l, u, c, d, f, p, g, v = n(t, e), y = 0; y < v.length; y += 3)a = v[y], h = v[y + 1], l = v[y + 2], u = t[2 * a] * i, c = t[2 * a + 1] * r, d = t[2 * h] * i, f = t[2 * h + 1] * r, p = t[2 * l] * i, g = t[2 * l + 1] * r, o.push(new s(u, c, d, f, p, g)); return o; }; }, function (t, e, i) { const n = i(68); t.exports = function (t, e, i) { const s = i * (Math.sqrt(3) / 2); return new n(t, e, t + i / 2, e + s, t - i / 2, e + s); }; }, function (t, e) { t.exports = function (t) { const e = t.x1; const i = t.y1; const n = t.x2; const s = t.y2; const r = t.x3; const o = t.y3; return Math.abs(((r - e) * (s - i) - (n - e) * (o - i)) / 2); }; }, function (t, e, i) { const n = i(68); n.Area = i(771), n.BuildEquilateral = i(770), n.BuildFromPolygon = i(769), n.BuildRight = i(768), n.CenterOn = i(767), n.Centroid = i(374), n.CircumCenter = i(766), n.CircumCircle = i(765), n.Clone = i(764), n.Contains = i(59), n.ContainsArray = i(230), n.ContainsPoint = i(763), n.CopyFrom = i(762), n.Decompose = i(381), n.Equals = i(761), n.GetPoint = i(226), n.GetPoints = i(225), n.InCenter = i(372), n.Perimeter = i(760), n.Offset = i(373), n.Random = i(151), n.Rotate = i(759), n.RotateAroundPoint = i(758), n.RotateAroundXY = i(224), t.exports = n; }, function (t, e) { t.exports = function (t, e, i) { return void 0 === i && (i = e), t.width *= e, t.height *= i, t; }; }, function (t, e, i) { const n = i(5); const s = i(38); t.exports = function (t, e, i) { void 0 === i && (i = new n()), e = s(e); const r = Math.sin(e); const o = Math.cos(e); let a = o > 0 ? t.width / 2 : t.width / -2; let h = r > 0 ? t.height / 2 : t.height / -2; return Math.abs(a * r) < Math.abs(h * o) ? h = a * r / o : a = h * o / r, i.x = a + t.centerX, i.y = h + t.centerY, i; }; }, function (t, e) { t.exports = function (t, e) { return t.x < e.right && t.right > e.x && t.y < e.bottom && t.bottom > e.y; }; }, function (t, e) { t.exports = function (t, e) { return t.x += e.x, t.y += e.y, t; }; }, function (t, e) { t.exports = function (t, e, i) { return t.x += e, t.y += i, t; }; }, function (t, e) { t.exports = function (t, e, i) { const n = Math.min(t.x, e); const s = Math.max(t.right, e); t.x = n, t.width = s - n; const r = Math.min(t.y, i); const o = Math.max(t.bottom, i); return t.y = r, t.height = o - r, t; }; }, function (t, e) { t.exports = function (t, e) { const i = Math.min(t.x, e.x); const n = Math.max(t.right, e.right); t.x = i, t.width = n - i; const s = Math.min(t.y, e.y); const r = Math.max(t.bottom, e.bottom); return t.y = s, t.height = r - s, t; }; }, function (t, e) { t.exports = function (t, e) { for (var i = t.x, n = t.right, s = t.y, r = t.bottom, o = 0; o < e.length; o++)i = Math.min(i, e[o].x), n = Math.max(n, e[o].x), s = Math.min(s, e[o].y), r = Math.max(r, e[o].y); return t.x = i, t.y = s, t.width = n - i, t.height = r - s, t; }; }, function (t, e, i) { const n = i(375); t.exports = function (t, e, i) { const s = t.centerX; const r = t.centerY; return t.setSize(t.width + 2 * e, t.height + 2 * i), n(t, s, r); }; }, function (t, e, i) { const n = i(5); t.exports = function (t, e) { return void 0 === e && (e = new n()), e.x = t.width, e.y = t.height, e; }; }, function (t, e, i) { const n = i(5); t.exports = function (t, e) { return void 0 === e && (e = new n()), e.x = t.centerX, e.y = t.centerY, e; }; }, function (t, e) { t.exports = function (t) { return t.x = Math.floor(t.x), t.y = Math.floor(t.y), t.width = Math.floor(t.width), t.height = Math.floor(t.height), t; }; }, function (t, e) { t.exports = function (t) { return t.x = Math.floor(t.x), t.y = Math.floor(t.y), t; }; }, function (t, e, i) { const n = i(227); t.exports = function (t, e) { const i = n(t); return i > n(e) ? t.setSize(e.height * i, e.height) : t.setSize(e.width, e.width / i), t.setPosition(e.centerX - t.width / 2, e.centerY - t.height / 2); }; }, function (t, e, i) { const n = i(227); t.exports = function (t, e) { const i = n(t); return i < n(e) ? t.setSize(e.height * i, e.height) : t.setSize(e.width, e.width / i), t.setPosition(e.centerX - t.width / 2, e.centerY - t.height / 2); }; }, function (t, e) { t.exports = function (t, e) { return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height; }; }, function (t, e) { t.exports = function (t, e) { return e.setTo(t.x, t.y, t.width, t.height); }; }, function (t, e) { t.exports = function (t, e) { return !(e.width * e.height > t.width * t.height) && e.x > t.x && e.x < t.right && e.right > t.x && e.right < t.right && e.y > t.y && e.y < t.bottom && e.bottom > t.y && e.bottom < t.bottom; }; }, function (t, e, i) { const n = i(31); t.exports = function (t, e) { return n(t, e.x, e.y); }; }, function (t, e, i) { const n = i(14); t.exports = function (t) { return new n(t.x, t.y, t.width, t.height); }; }, function (t, e) { t.exports = function (t) { return t.x = Math.ceil(t.x), t.y = Math.ceil(t.y), t.width = Math.ceil(t.width), t.height = Math.ceil(t.height), t; }; }, function (t, e) { t.exports = function (t) { return t.x = Math.ceil(t.x), t.y = Math.ceil(t.y), t; }; }, function (t, e) { t.exports = function (t) { return t.width * t.height; }; }, function (t, e) { t.exports = function (t, e) { void 0 === e && (e = []); for (let i = 0; i < t.points.length; i++)e.push(t.points[i].x), e.push(t.points[i].y); return e; }; }, function (t, e, i) { const n = i(14); t.exports = function (t, e) { void 0 === e && (e = new n()); for (var i, s = 1 / 0, r = 1 / 0, o = -s, a = -r, h = 0; h < t.points.length; h++)i = t.points[h], s = Math.min(s, i.x), r = Math.min(r, i.y), o = Math.max(o, i.x), a = Math.max(a, i.y); return e.x = s, e.y = r, e.width = o - s, e.height = a - r, e; }; }, function (t, e, i) { const n = i(228); t.exports = function (t, e) { return n(t, e.x, e.y); }; }, function (t, e, i) { const n = i(377); t.exports = function (t) { return new n(t.points); }; }, function (t, e, i) { const n = i(377); n.Clone = i(799), n.Contains = i(228), n.ContainsPoint = i(798), n.GetAABB = i(797), n.GetNumberArray = i(796), t.exports = n; }, function (t, e, i) { const n = i(379); t.exports = function (t, e) { if (t.x !== 0 || t.y !== 0) { const i = n(t); t.x /= i, t.y /= i; } return t.x *= e, t.y *= e, t; }; }, function (t, e, i) { const n = i(5); t.exports = function (t, e, i) { void 0 === i && (i = new n()); const s = t.x * e.x + t.y * e.y; return s !== 0 && (i.x = s * e.x, i.y = s * e.y), i; }; }, function (t, e, i) { const n = i(5); const s = i(378); t.exports = function (t, e, i) { void 0 === i && (i = new n()); const r = (t.x * e.x + t.y * e.y) / s(e); return r !== 0 && (i.x = r * e.x, i.y = r * e.y), i; }; }, function (t, e, i) { const n = i(5); t.exports = function (t, e) { return void 0 === e && (e = new n()), e.setTo(-t.x, -t.y); }; }, function (t, e) { t.exports = function (t) { return t.setTo(t.y, t.x); }; }, function (t, e, i) { const n = i(5); t.exports = function (t, e, i, s) { return void 0 === i && (i = 0), void 0 === s && (s = new n()), s.x = t.x + (e.x - t.x) * i, s.y = t.y + (e.y - t.y) * i, s; }; }, function (t, e, i) { const n = i(14); t.exports = function (t, e) { void 0 === e && (e = new n()); for (var i = Number.NEGATIVE_INFINITY, s = Number.POSITIVE_INFINITY, r = Number.NEGATIVE_INFINITY, o = Number.POSITIVE_INFINITY, a = 0; a < t.length; a++) { const h = t[a]; h.x > i && (i = h.x), h.x < s && (s = h.x), h.y > r && (r = h.y), h.y < o && (o = h.y); } return e.x = s, e.y = o, e.width = i - s, e.height = r - o, e; }; }, function (t, e, i) { const n = i(5); t.exports = function (t, e) { if (void 0 === e && (e = new n()), !Array.isArray(t)) throw new Error('GetCentroid points argument must be an array'); const i = t.length; if (i < 1) throw new Error('GetCentroid points array must not be empty'); if (i === 1)e.x = t[0].x, e.y = t[0].y; else { for (let s = 0; s < i; s++)e.x += t[s].x, e.y += t[s].y; e.x /= i, e.y /= i; } return e; }; }, function (t, e) { t.exports = function (t) { return t.setTo(Math.floor(t.x), Math.floor(t.y)); }; }, function (t, e) { t.exports = function (t, e) { return t.x === e.x && t.y === e.y; }; }, function (t, e) { t.exports = function (t, e) { return e.setTo(t.x, t.y); }; }, function (t, e, i) { const n = i(5); t.exports = function (t) { return new n(t.x, t.y); }; }, function (t, e) { t.exports = function (t) { return t.setTo(Math.ceil(t.x), Math.ceil(t.y)); }; }, function (t, e, i) { const n = i(5); n.Ceil = i(813), n.Clone = i(812), n.CopyFrom = i(811), n.Equals = i(810), n.Floor = i(809), n.GetCentroid = i(808), n.GetMagnitude = i(379), n.GetMagnitudeSq = i(378), n.GetRectangleFromPoints = i(807), n.Interpolate = i(806), n.Invert = i(805), n.Negative = i(804), n.Project = i(803), n.ProjectUnit = i(802), n.SetMagnitude = i(801), t.exports = n; }, function (t, e) { t.exports = function (t) { return Math.abs(t.x1 - t.x2); }; }, function (t, e) { t.exports = function (t) { return (t.y2 - t.y1) / (t.x2 - t.x1); }; }, function (t, e) { t.exports = function (t, e, i, n, s) { return t.x1 = e, t.y1 = i, t.x2 = e + Math.cos(n) * s, t.y2 = i + Math.sin(n) * s, t; }; }, function (t, e, i) { const n = i(229); t.exports = function (t, e, i) { return n(t, e.x, e.y, i); }; }, function (t, e, i) { const n = i(229); t.exports = function (t, e) { const i = (t.x1 + t.x2) / 2; const s = (t.y1 + t.y2) / 2; return n(t, i, s, e); }; }, function (t, e, i) { const n = i(81); const s = i(380); t.exports = function (t, e) { return 2 * s(e) - Math.PI - n(t); }; }, function (t, e) { t.exports = function (t) { return -(t.x2 - t.x1) / (t.y2 - t.y1); }; }, function (t, e) { t.exports = function (t, e, i) { return t.x1 += e, t.y1 += i, t.x2 += e, t.y2 += i, t; }; }, function (t, e, i) { const n = i(16); const s = i(81); t.exports = function (t) { return Math.sin(s(t) - n.TAU); }; }, function (t, e, i) { const n = i(16); const s = i(81); t.exports = function (t) { return Math.cos(s(t) - n.TAU); }; }, function (t, e) { t.exports = function (t) { return Math.abs(t.y1 - t.y2); }; }, function (t, e, i) { const n = i(16); const s = i(81); const r = i(5); t.exports = function (t, e) { void 0 === e && (e = new r()); const i = s(t) - n.TAU; return e.x = Math.cos(i), e.y = Math.sin(i), e; }; }, function (t, e, i) { const n = i(5); t.exports = function (t, e) { return void 0 === e && (e = new n()), e.x = (t.x1 + t.x2) / 2, e.y = (t.y1 + t.y2) / 2, e; }; }, function (t, e) { t.exports = function (t, e) { return t.x1 === e.x1 && t.y1 === e.y1 && t.x2 === e.x2 && t.y2 === e.y2; }; }, function (t, e) { t.exports = function (t, e) { return e.setTo(t.x1, t.y1, t.x2, t.y2); }; }, function (t, e, i) { const n = i(95); t.exports = function (t) { return new n(t.x1, t.y1, t.x2, t.y2); }; }, function (t, e) { t.exports = function (t, e, i) { const n = e - (t.x1 + t.x2) / 2; const s = i - (t.y1 + t.y2) / 2; return t.x1 += n, t.y1 += s, t.x2 += n, t.y2 += s, t; }; }, function (t, e, i) { const n = i(95); n.Angle = i(81), n.BresenhamPoints = i(564), n.CenterOn = i(831), n.Clone = i(830), n.CopyFrom = i(829), n.Equals = i(828), n.GetMidPoint = i(827), n.GetNormal = i(826), n.GetPoint = i(293), n.GetPoints = i(154), n.Height = i(825), n.Length = i(71), n.NormalAngle = i(380), n.NormalX = i(824), n.NormalY = i(823), n.Offset = i(822), n.PerpSlope = i(821), n.Random = i(153), n.ReflectAngle = i(820), n.Rotate = i(819), n.RotateAroundPoint = i(818), n.RotateAroundXY = i(229), n.SetToAngle = i(817), n.Slope = i(816), n.Width = i(815), t.exports = n; }, function (t, e, i) { const n = i(230); const s = i(381); const r = i(143); t.exports = function (t, e) { if (t.left > e.right || t.right < e.left || t.top > e.bottom || t.bottom < e.top) return !1; const i = t.getLineA(); const o = t.getLineB(); const a = t.getLineC(); const h = e.getLineA(); const l = e.getLineB(); const u = e.getLineC(); if (r(i, h) || r(i, l) || r(i, u)) return !0; if (r(o, h) || r(o, l) || r(o, u)) return !0; if (r(a, h) || r(a, l) || r(a, u)) return !0; let c = s(t); let d = n(e, c, !0); return d.length > 0 || (c = s(e), (d = n(t, c, !0)).length > 0); }; }, function (t, e, i) { const n = i(59); const s = i(143); t.exports = function (t, e) { return !!(n(t, e.getPointA()) || n(t, e.getPointB()) || s(t.getLineA(), e) || s(t.getLineB(), e) || s(t.getLineC(), e)); }; }, function (t, e, i) { const n = i(384); const s = i(59); t.exports = function (t, e) { return !(t.left > e.right || t.right < e.left || t.top > e.bottom || t.bottom < e.top || !s(t, e.x, e.y) && !n(t.getLineA(), e) && !n(t.getLineB(), e) && !n(t.getLineC(), e)); }; }, function (t, e) { t.exports = function (t, e, i, n, s, r) { return void 0 === r && (r = 0), !(e > t.right + r || i < t.left - r || n > t.bottom + r || s < t.top - r); }; }, function (t, e, i) { const n = i(143); const s = i(31); const r = i(230); const o = i(382); t.exports = function (t, e) { if (e.left > t.right || e.right < t.left || e.top > t.bottom || e.bottom < t.top) return !1; const i = e.getLineA(); const a = e.getLineB(); const h = e.getLineC(); if (s(t, i.x1, i.y1) || s(t, i.x2, i.y2)) return !0; if (s(t, a.x1, a.y1) || s(t, a.x2, a.y2)) return !0; if (s(t, h.x1, h.y1) || s(t, h.x2, h.y2)) return !0; const l = t.getLineA(); const u = t.getLineB(); const c = t.getLineC(); const d = t.getLineD(); if (n(i, l) || n(i, u) || n(i, c) || n(i, d)) return !0; if (n(a, l) || n(a, u) || n(a, c) || n(a, d)) return !0; if (n(h, l) || n(h, u) || n(h, c) || n(h, d)) return !0; const f = o(t); return r(e, f, !0).length > 0; }; }, function (t, e, i) { const n = i(383); t.exports = function (t, e) { if (!n(t, e)) return !1; const i = Math.min(e.x1, e.x2); const s = Math.max(e.x1, e.x2); const r = Math.min(e.y1, e.y2); const o = Math.max(e.y1, e.y2); return t.x >= i && t.x <= s && t.y >= r && t.y <= o; }; }, function (t, e) { t.exports = function (t, e) { const i = t.x1; const n = t.y1; const s = t.x2; const r = t.y2; const o = e.x; const a = e.y; const h = e.right; const l = e.bottom; let u = 0; if (i >= o && i <= h && n >= a && n <= l || s >= o && s <= h && r >= a && r <= l) return !0; if (i < o && s >= o) { if ((u = n + (r - n) * (o - i) / (s - i)) > a && u <= l) return !0; } else if (i > h && s <= h && (u = n + (r - n) * (h - i) / (s - i)) >= a && u <= l) return !0; if (n < a && r >= a) { if ((u = i + (s - i) * (a - n) / (r - n)) >= o && u <= h) return !0; } else if (n > l && r <= l && (u = i + (s - i) * (l - n) / (r - n)) >= o && u <= h) return !0; return !1; }; }, function (t, e, i) { const n = i(14); const s = i(385); t.exports = function (t, e, i) { return void 0 === i && (i = new n()), s(t, e) && (i.x = Math.max(t.x, e.x), i.y = Math.max(t.y, e.y), i.width = Math.min(t.right, e.right) - i.x, i.height = Math.min(t.bottom, e.bottom) - i.y), i; }; }, function (t, e) { t.exports = function (t, e) { const i = e.width / 2; const n = e.height / 2; const s = Math.abs(t.x - e.x - i); const r = Math.abs(t.y - e.y - n); const o = i + t.radius; const a = n + t.radius; if (s > o || r > a) return !1; if (s <= i || r <= n) return !0; const h = s - i; const l = r - n; return h * h + l * l <= t.radius * t.radius; }; }, function (t, e, i) { const n = i(57); t.exports = function (t, e) { return n(t.x, t.y, e.x, e.y) <= t.radius + e.radius; }; }, function (t, e) { t.exports = function (t, e) { return t.x += e.x, t.y += e.y, t; }; }, function (t, e) { t.exports = function (t, e, i) { return t.x += e, t.y += i, t; }; }, function (t, e, i) { const n = i(14); t.exports = function (t, e) { return void 0 === e && (e = new n()), e.x = t.left, e.y = t.top, e.width = t.diameter, e.height = t.diameter, e; }; }, function (t, e) { t.exports = function (t, e) { return t.x === e.x && t.y === e.y && t.radius === e.radius; }; }, function (t, e) { t.exports = function (t, e) { return e.setTo(t.x, t.y, t.radius); }; }, function (t, e, i) { const n = i(32); t.exports = function (t, e) { return n(t, e.x, e.y) && n(t, e.right, e.y) && n(t, e.x, e.bottom) && n(t, e.right, e.bottom); }; }, function (t, e, i) { const n = i(32); t.exports = function (t, e) { return n(t, e.x, e.y); }; }, function (t, e, i) { const n = i(87); t.exports = function (t) { return new n(t.x, t.y, t.radius); }; }, function (t, e) { t.exports = function (t) { return t.radius > 0 ? Math.PI * t.radius * t.radius : 0; }; }, function (t, e, i) { const n = i(87); n.Area = i(851), n.Circumference = i(295), n.CircumferencePoint = i(133), n.Clone = i(850), n.Contains = i(32), n.ContainsPoint = i(849), n.ContainsRect = i(848), n.CopyFrom = i(847), n.Equals = i(846), n.GetBounds = i(845), n.GetPoint = i(298), n.GetPoints = i(296), n.Offset = i(844), n.OffsetPoint = i(843), n.Random = i(155), t.exports = n; }, function (t, e, i) {
  const n = i(0); const s = i(388); const r = i(12); const o = new n({
    Extends: s, initialize(t) { this.scene = t, this.systems = t.sys, t.sys.settings.isBooted || t.sys.events.once('boot', this.boot, this), s.call(this); }, boot() { const t = this.systems.events; t.on('shutdown', this.shutdown, this), t.on('destroy', this.destroy, this); }, destroy() { this.shutdown(), this.scene = void 0, this.systems = void 0; },
  }); r.register('LightsPlugin', o, 'lights'), t.exports = o;
}, function (t, e, i) { const n = i(24); const s = i(13); const r = i(10); const o = i(231); s.register('quad', function (t, e) { void 0 === t && (t = {}); const i = r(t, 'x', 0); const s = r(t, 'y', 0); const a = r(t, 'key', null); const h = r(t, 'frame', null); const l = new o(this.scene, i, s, a, h); return void 0 !== e && (t.add = e), n(this.scene, l, t), l; }); }, function (t, e, i) { const n = i(24); const s = i(13); const r = i(10); const o = i(4); const a = i(144); s.register('mesh', function (t, e) { void 0 === t && (t = {}); const i = r(t, 'key', null); const s = r(t, 'frame', null); const h = o(t, 'vertices', []); const l = o(t, 'colors', []); const u = o(t, 'alphas', []); const c = o(t, 'uv', []); const d = new a(this.scene, 0, 0, h, c, l, u, i, s); return void 0 !== e && (t.add = e), n(this.scene, d, t), d; }); }, function (t, e, i) { const n = i(231); i(11).register('quad', function (t, e, i, s) { return this.displayList.add(new n(this.scene, t, e, i, s)); }); }, function (t, e, i) { const n = i(144); i(11).register('mesh', function (t, e, i, s, r, o, a, h) { return this.displayList.add(new n(this.scene, t, e, i, s, r, o, a, h)); }); }, function (t, e) { t.exports = function () {}; }, function (t, e, i) { const n = i(2); t.exports = function (t, e, i, s, r) { n.RENDER_MASK !== e.renderFlags || e.cameraFilter > 0 && e.cameraFilter & s._id || this.pipeline.batchMesh(e, s, r); }; }, function (t, e, i) { let n = i(3); let s = i(3); n = i(859), s = i(858), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const n = i(13); const s = i(10); const r = i(156); n.register('zone', function (t) { const e = s(t, 'x', 0); const i = s(t, 'y', 0); const n = s(t, 'width', 1); const o = s(t, 'height', n); return new r(this.scene, e, i, n, o); }); }, function (t, e, i) { const n = i(24); const s = i(13); const r = i(10); const o = i(232); s.register('tileSprite', function (t, e) { void 0 === t && (t = {}); const i = r(t, 'x', 0); const s = r(t, 'y', 0); const a = r(t, 'width', 512); const h = r(t, 'height', 512); const l = r(t, 'key', ''); const u = r(t, 'frame', ''); const c = new o(this.scene, i, s, a, h, l, u); return void 0 !== e && (t.add = e), n(this.scene, c, t), c; }); }, function (t, e, i) { const n = i(252); const s = i(24); const r = i(13); const o = i(10); const a = i(4); r.register('bitmapText', function (t, e) { void 0 === t && (t = {}); const i = a(t, 'font', ''); const r = o(t, 'text', ''); const h = o(t, 'size', !1); const l = new n(this.scene, 0, 0, i, r, h); return void 0 !== e && (t.add = e), s(this.scene, l, t), l; }); }, function (t, e, i) { const n = i(24); const s = i(124); const r = i(13); const o = i(10); const a = i(149); r.register('sprite3D', function (t, e) { void 0 === t && (t = {}); const i = o(t, 'key', null); const r = o(t, 'frame', null); const h = new a(this.scene, 0, 0, i, r); return void 0 !== e && (t.add = e), n(this.scene, h, t), s(h, t), h; }); }, function (t, e, i) { const n = i(24); const s = i(13); const r = i(10); const o = i(233); s.register('renderTexture', function (t, e) { void 0 === t && (t = {}); const i = r(t, 'x', 0); const s = r(t, 'y', 0); const a = r(t, 'width', 32); const h = r(t, 'height', 32); const l = new o(this.scene, i, s, a, h); return void 0 !== e && (t.add = e), n(this.scene, l, t), l; }); }, function (t, e, i) { const n = i(13); const s = i(10); const r = i(1); const o = i(234); n.register('particles', function (t, e) { void 0 === t && (t = {}); const i = s(t, 'key', null); const n = s(t, 'frame', null); const a = r(t, 'emitters', null); const h = new o(this.scene, i, n, a); return void 0 !== e && (t.add = e), r(t, 'add', !1) && this.displayList.add(h), this.updateList.add(h), h; }); }, function (t, e, i) { const n = i(13); const s = i(109); n.register('group', function (t) { return new s(this.scene, null, t); }); }, function (t, e, i) { const n = i(249); const s = i(24); const r = i(13); const o = i(10); r.register('dynamicBitmapText', function (t, e) { void 0 === t && (t = {}); const i = o(t, 'font', ''); const r = o(t, 'text', ''); const a = o(t, 'size', !1); const h = o(t, 'align', 'left'); const l = new n(this.scene, 0, 0, i, r, a, h); return void 0 !== e && (t.add = e), s(this.scene, l, t), l; }); }, function (t, e, i) { const n = i(24); const s = i(250); const r = i(13); const o = i(10); r.register('container', function (t, e) { void 0 === t && (t = {}); const i = o(t, 'x', 0); const r = o(t, 'y', 0); const a = new s(this.scene, i, r); return void 0 !== e && (t.add = e), n(this.scene, a, t), a; }); }, function (t, e, i) { const n = i(251); const s = i(24); const r = i(13); const o = i(10); r.register('blitter', function (t, e) { void 0 === t && (t = {}); const i = o(t, 'key', null); const r = o(t, 'frame', null); const a = new n(this.scene, 0, 0, i, r); return void 0 !== e && (t.add = e), s(this.scene, a, t), a; }); }, function (t, e, i) { const n = i(156); i(11).register('zone', function (t, e, i, s) { return this.displayList.add(new n(this.scene, t, e, i, s)); }); }, function (t, e, i) { const n = i(232); i(11).register('tileSprite', function (t, e, i, s, r, o) { return this.displayList.add(new n(this.scene, t, e, i, s, r, o)); }); }, function (t, e, i) { const n = i(252); i(11).register('bitmapText', function (t, e, i, s, r) { return this.displayList.add(new n(this.scene, t, e, i, s, r)); }); }, function (t, e, i) { const n = i(149); i(11).register('sprite3D', function (t, e, i, s, r) { const o = new n(this.scene, t, e, i, s, r); return this.displayList.add(o.gameObject), this.updateList.add(o.gameObject), o; }); }, function (t, e, i) { const n = i(11); const s = i(233); n.register('renderTexture', function (t, e, i, n) { return this.displayList.add(new s(this.scene, t, e, i, n)); }); }, function (t, e, i) { const n = i(11); const s = i(405); n.register('follower', function (t, e, i, n, r) { const o = new s(this.scene, t, e, i, n, r); return this.displayList.add(o), this.updateList.add(o), o; }); }, function (t, e, i) { const n = i(11); const s = i(234); n.register('particles', function (t, e, i) { const n = new s(this.scene, t, e, i); return this.displayList.add(n), this.updateList.add(n), n; }); }, function (t, e, i) { const n = i(109); i(11).register('group', function (t, e) { return typeof t === 'object' && void 0 === e && (e = t, t = []), this.updateList.add(new n(this.scene, t, e)); }); }, function (t, e, i) { const n = i(249); i(11).register('dynamicBitmapText', function (t, e, i, s, r) { return this.displayList.add(new n(this.scene, t, e, i, s, r)); }); }, function (t, e, i) { const n = i(250); i(11).register('container', function (t, e, i) { return this.displayList.add(new n(this.scene, t, e, i)); }); }, function (t, e, i) { const n = i(251); i(11).register('blitter', function (t, e, i, s) { return this.displayList.add(new n(this.scene, t, e, i, s)); }); }, function (t, e, i) { const n = i(2); t.exports = function (t, e, i, s, r) { if (!(n.RENDER_MASK !== e.renderFlags || e.cameraFilter > 0 && e.cameraFilter & s._id)) { const o = t.currentContext; const a = e.frame; e.updateTileTexture(), t.currentBlendMode !== e.blendMode && (t.currentBlendMode = e.blendMode, o.globalCompositeOperation = t.blendModes[e.blendMode]), t.currentAlpha !== e.alpha && (t.currentAlpha = e.alpha, o.globalAlpha = e.alpha), t.currentScaleMode !== e.scaleMode && (t.currentScaleMode = e.scaleMode); let h = a.x - e.originX * e.width; let l = a.y - e.originY * e.height; let u = e.x - s.scrollX * e.scrollFactorX; let c = e.y - s.scrollY * e.scrollFactorY; let d = 1; let f = 1; if (e.flipX && (d = -1, h += e.width), e.flipY && (f = -1, l += e.height), t.config.roundPixels && (h |= 0, l |= 0, u |= 0, c |= 0), o.save(), void 0 !== r) { const p = r.matrix; o.transform(p[0], p[1], p[2], p[3], p[4], p[5]); }o.translate(h, l), o.translate(u, c), o.scale(d, f), o.translate(e.originX * e.width, e.originY * e.height), o.rotate(d * f * e.rotation), o.scale(this.scaleX, this.scaleY), o.translate(-e.originX * e.width, -e.originY * e.height), o.translate(-this.tilePositionX, -this.tilePositionY), o.fillStyle = e.canvasPattern, o.fillRect(this.tilePositionX, this.tilePositionY, e.width, e.height), o.restore(); } }; }, function (t, e, i) { const n = i(2); t.exports = function (t, e, i, s, r) { n.RENDER_MASK !== e.renderFlags || e.cameraFilter > 0 && e.cameraFilter & s._id || (e.updateTileTexture(), this.pipeline.batchTileSprite(this, s, r)); }; }, function (t, e, i) { let n = i(3); let s = i(3); n = i(883), s = i(882), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) {
  const n = i(4); t.exports = function (t, e) {
    const i = e.width; const s = e.height; const r = Math.floor(i / 2); const o = Math.floor(s / 2); const a = n(e, 'chars', ''); if (a !== '') {
      const h = n(e, 'image', ''); const l = n(e, 'offset.x', 0); const u = n(e, 'offset.y', 0); const c = n(e, 'spacing.x', 0); const d = n(e, 'spacing.y', 0); let f = n(e, 'charsPerRow', null); f === null && (f = t.sys.textures.getFrame(h).width / i) > a.length && (f = a.length); for (var p = l, g = u, v = {
          retroFont: !0, font: h, size: i, lineHeight: s, chars: {},
        }, y = 0, m = 0; m < a.length; m++) {
        const x = a.charCodeAt(m); v.chars[x] = {
          x: p, y: g, width: i, height: s, centerX: r, centerY: o, xOffset: 0, yOffset: 0, xAdvance: i, data: {}, kerning: {},
        }, ++y === f ? (y = 0, p = l, g += s + d) : p += i + c;
      } return { data: v, frame: null, texture: h };
    }
  };
}, function (t, e) {
  t.exports = {
    TEXT_SET1: " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", TEXT_SET2: " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ", TEXT_SET3: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ', TEXT_SET4: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789', TEXT_SET5: "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789", TEXT_SET6: "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ", TEXT_SET7: "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39", TEXT_SET8: '0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ', TEXT_SET9: "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!", TEXT_SET10: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', TEXT_SET11: "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789",
  };
}, function (t, e, i) { const n = i(886); const s = i(18); let r = { Parse: i(885) }; r = s(!1, r, n), t.exports = r; }, function (t, e) { t.exports = { fill(t) { const e = 255 & (t >> 16 | 0); const i = 255 & (t >> 8 | 0); const n = 255 & (0 | t); this.renderer.setFramebuffer(this.framebuffer); const s = this.gl; return s.clearColor(e / 255, i / 255, n / 255, 1), s.clear(s.COLOR_BUFFER_BIT), this.renderer.setFramebuffer(null), this; }, clear() { this.renderer.setFramebuffer(this.framebuffer); const t = this.gl; return t.clearColor(0, 0, 0, 0), t.clear(t.COLOR_BUFFER_BIT), this.renderer.setFramebuffer(null), this; }, draw(t, e, i, n) { const s = t.source[e.sourceIndex].glTexture; const r = (this.globalTint >> 16) + (65280 & this.globalTint) + ((255 & this.globalTint) << 16); return this.renderer.setFramebuffer(this.framebuffer), this.renderer.pipelines.TextureTintPipeline.projOrtho(0, this.renderer.pipelines.TextureTintPipeline.width, 0, this.renderer.pipelines.TextureTintPipeline.height, -1e3, 1e3), this.renderer.pipelines.TextureTintPipeline.drawTexture(s, i, n, r, this.globalAlpha, e.cutX, e.cutY, e.cutWidth, e.cutHeight, this.currentMatrix, null, this), this.renderer.setFramebuffer(null), this.renderer.pipelines.TextureTintPipeline.projOrtho(0, this.renderer.pipelines.TextureTintPipeline.width, this.renderer.pipelines.TextureTintPipeline.height, 0, -1e3, 1e3), this; } }; }, function (t, e) { t.exports = { fill(t) { const e = 255 & (t >> 16 | 0); const i = 255 & (t >> 8 | 0); const n = 255 & (0 | t); return this.context.fillStyle = `rgb(${e},${i},${n})`, this.context.fillRect(0, 0, this.canvas.width, this.canvas.height), this; }, clear() { return this.context.save(), this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), this.context.restore(), this; }, draw(t, e, i, n) { const s = this.currentMatrix; return this.context.globalAlpha = this.globalAlpha, this.context.setTransform(s[0], s[1], s[2], s[3], s[4], s[5]), this.context.drawImage(t.source[e.sourceIndex].image, e.cutX, e.cutY, e.cutWidth, e.cutHeight, i, n, e.cutWidth, e.cutWidth), this; } }; }, function (t, e, i) { const n = i(2); t.exports = function (t, e, i, s, r) { if (!(n.RENDER_MASK !== e.renderFlags || e.cameraFilter > 0 && e.cameraFilter & s._id)) { const o = t.currentContext; t.currentBlendMode !== e.blendMode && (t.currentBlendMode = e.blendMode, o.globalCompositeOperation = t.blendModes[e.blendMode]), t.currentAlpha !== e.alpha && (t.currentAlpha = e.alpha, o.globalAlpha = e.alpha), t.currentScaleMode !== e.scaleMode && (t.currentScaleMode = e.scaleMode); let a = 0; let h = 0; let l = 1; let u = 1; if (e.flipX ? (l = -1, a -= e.canvas.width - e.displayOriginX) : a -= e.displayOriginX, e.flipY ? (u = -1, h -= e.canvas.height - e.displayOriginY) : h -= e.displayOriginY, o.save(), void 0 !== r) { const c = r.matrix; o.transform(c[0], c[1], c[2], c[3], c[4], c[5]); }o.translate(e.x - s.scrollX * e.scrollFactorX, e.y - s.scrollY * e.scrollFactorY), o.rotate(e.rotation), o.scale(e.scaleX, e.scaleY), o.scale(l, u), o.drawImage(e.canvas, a, h), o.restore(); } }; }, function (t, e, i) { const n = i(2); const s = i(27); t.exports = function (t, e, i, r, o) { n.RENDER_MASK !== e.renderFlags || e.cameraFilter > 0 && e.cameraFilter & r._id || this.pipeline.batchTexture(e, e.texture, e.texture.width, e.texture.height, e.x, e.y, e.width, e.height, e.scaleX, e.scaleY, e.rotation, e.flipX, !e.flipY, e.scrollFactorX, e.scrollFactorY, e.displayOriginX, e.displayOriginY, 0, 0, e.texture.width, e.texture.height, s.getTintAppendFloatAlpha(e.tintTopLeft, e.alphaTopLeft), s.getTintAppendFloatAlpha(e.tintTopRight, e.alphaTopRight), s.getTintAppendFloatAlpha(e.tintBottomLeft, e.alphaBottomLeft), s.getTintAppendFloatAlpha(e.tintBottomRight, e.alphaBottomRight), 0, 0, r, o); }; }, function (t, e, i) { let n = i(3); let s = i(3); n = i(891), s = i(890), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { t.exports = { DeathZone: i(442), EdgeZone: i(441), RandomZone: i(406) }; }, function (t, e, i) { const n = i(2); t.exports = function (t, e, i, s, r) { const o = e.emitters.list; if (!(o.length === 0 || n.RENDER_MASK !== e.renderFlags || e.cameraFilter > 0 && e.cameraFilter & s._id)) { const a = t.currentContext; if (a.save(), void 0 !== r) { const h = r.matrix; a.transform(h[0], h[1], h[2], h[3], h[4], h[5]); } for (let l = 0; l < o.length; l++) { const u = o[l]; const c = u.alive; const d = c.length; if (u.visible && d !== 0) { const f = a.globalAlpha; const p = s.scrollX * u.scrollFactorX; const g = s.scrollY * u.scrollFactorY; t.currentBlendMode !== u.blendMode && (t.currentBlendMode = u.blendMode, a.globalCompositeOperation = t.blendModes[u.blendMode]); for (let v = t.config.roundPixels, y = 0; y < d; ++y) { const m = c[y]; const x = (m.color >> 24 & 255) / 255; if (!(x <= 0)) { const w = m.frame; const b = 0.5 * w.width; const T = 0.5 * w.height; const S = w.canvasData; const A = -b; const C = -T; let M = m.x - p; let _ = m.y - g; v && (M |= 0, _ |= 0), a.globalAlpha = x, a.save(), a.translate(M, _), a.rotate(m.rotation), a.scale(m.scaleX, m.scaleY), a.drawImage(w.source.image, S.sx, S.sy, S.sWidth, S.sHeight, A, C, S.dWidth, S.dHeight), a.restore(); } }a.globalAlpha = f; } }a.restore(); } }; }, function (t, e, i) { const n = i(2); t.exports = function (t, e, i, s, r) { e.emitters.length === 0 || n.RENDER_MASK !== e.renderFlags || e.cameraFilter > 0 && e.cameraFilter & s._id || this.pipeline.drawEmitterManager(e, s, r); }; }, function (t, e, i) { let n = i(3); let s = i(3); n = i(895), s = i(894), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) {
  const n = i(0); const s = i(247); const r = i(62); const o = i(1); const a = i(39); const h = new n({
    initialize(t, e, i, n) { void 0 === n && (n = !1), this.propertyKey = e, this.propertyValue = i, this.defaultValue = i, this.steps = 0, this.counter = 0, this.start = 0, this.end = 0, this.ease, this.emitOnly = n, this.onEmit = this.defaultEmit, this.onUpdate = this.defaultUpdate, this.loadConfig(t); }, loadConfig(t, e) { void 0 === t && (t = {}), e && (this.propertyKey = e), this.propertyValue = o(t, this.propertyKey, this.defaultValue), this.setMethods(), this.emitOnly && (this.onUpdate = this.defaultUpdate); }, toJSON() { return this.propertyValue; }, onChange(t) { return this.propertyValue = t, this.setMethods(); }, setMethods() { const t = this.propertyValue; const e = typeof t; if (e === 'number') this.onEmit = this.staticValueEmit, this.onUpdate = this.staticValueUpdate; else if (Array.isArray(t)) this.onEmit = this.randomStaticValueEmit; else if (e === 'function') this.emitOnly ? this.onEmit = t : this.onUpdate = t; else if (e === 'object' && (this.has(t, 'random') || this.hasBoth(t, 'start', 'end') || this.hasBoth(t, 'min', 'max'))) { this.start = this.has(t, 'start') ? t.start : t.min, this.end = this.has(t, 'end') ? t.end : t.max; const i = this.hasBoth(t, 'min', 'max') || this.has(t, 'random'); if (i) { const n = t.random; Array.isArray(n) && (this.start = n[0], this.end = n[1]), this.onEmit = this.randomRangedValueEmit; } if (this.has(t, 'steps')) this.steps = t.steps, this.counter = this.start, this.onEmit = this.steppedEmit; else { const s = this.has(t, 'ease') ? t.ease : 'Linear'; this.ease = r(s), i || (this.onEmit = this.easedValueEmit), this.onUpdate = this.easeValueUpdate; } } else e === 'object' && this.hasEither(t, 'onEmit', 'onUpdate') && (this.has(t, 'onEmit') && (this.onEmit = t.onEmit), this.has(t, 'onUpdate') && (this.onUpdate = t.onUpdate)); return this; }, has(t, e) { return t.hasOwnProperty(e); }, hasBoth(t, e, i) { return t.hasOwnProperty(e) && t.hasOwnProperty(i); }, hasEither(t, e, i) { return t.hasOwnProperty(e) || t.hasOwnProperty(i); }, defaultEmit(t, e, i) { return i; }, defaultUpdate(t, e, i, n) { return n; }, staticValueEmit() { return this.propertyValue; }, staticValueUpdate() { return this.propertyValue; }, randomStaticValueEmit() { const t = Math.floor(Math.random() * this.propertyValue.length); return this.propertyValue[t]; }, randomRangedValueEmit(t, e) { const i = s(this.start, this.end); return t && t.data[e] && (t.data[e].min = i), i; }, steppedEmit() { const t = this.counter; const e = this.counter + (this.end - this.start) / this.steps; return this.counter = a(e, this.start, this.end), t; }, easedValueEmit(t, e) { if (t && t.data[e]) { const i = t.data[e]; i.min = this.start, i.max = this.end; } return this.start; }, easeValueUpdate(t, e, i) { const n = t.data[e]; return (n.max - n.min) * this.ease(i) + n.min; },
  }); t.exports = h;
}, function (t, e, i) {
  t.exports = {
    GravityWell: i(445), Particle: i(444), ParticleEmitter: i(443), ParticleEmitterManager: i(234), Zones: i(893),
  };
}, function (t, e, i) {
  const n = i(2); t.exports = function (t, e, i, s, r) {
    const o = e.text; const a = o.length; if (!(n.RENDER_MASK !== e.renderFlags || a === 0 || e.cameraFilter > 0 && e.cameraFilter & s._id)) {
      const h = e.frame; const l = e.displayCallback; const u = s.scrollX * e.scrollFactorX; const c = s.scrollY * e.scrollFactorY; const d = e.fontData.chars; const f = e.fontData.lineHeight; let p = 0; let g = 0; let v = 0; let y = 0; let m = null; let x = 0; let w = 0; let b = 0; let T = 0; let S = 0; let A = 0; let C = null; let M = 0; const _ = t.currentContext; const E = e.frame.source.image; const P = h.cutX; const L = h.cutY; let F = 0; let k = e.fontSize / e.fontData.size; if (t.currentBlendMode !== e.blendMode && (t.currentBlendMode = e.blendMode, _.globalCompositeOperation = t.blendModes[e.blendMode]), t.currentAlpha !== e.alpha && (t.currentAlpha = e.alpha, _.globalAlpha = e.alpha), t.currentScaleMode !== e.scaleMode && (t.currentScaleMode = e.scaleMode), _.save(), void 0 !== r) { const R = r.matrix; _.transform(R[0], R[1], R[2], R[3], R[4], R[5]); }_.translate(e.x, e.y), _.rotate(e.rotation), _.translate(-e.displayOriginX, -e.displayOriginY), _.scale(e.scaleX, e.scaleY), e.cropWidth > 0 && e.cropHeight > 0 && (_.save(), _.beginPath(), _.rect(0, 0, e.cropWidth, e.cropHeight), _.clip()); for (let O = t.config.roundPixels, B = 0; B < a; ++B) {
        if (k = e.fontSize / e.fontData.size, F = 0, (y = o.charCodeAt(B)) !== 10) {
          if (m = d[y]) {
            if (x = P + m.x, w = L + m.y, b = m.width, T = m.height, S = v + m.xOffset + p - e.scrollX, A = m.yOffset + g - e.scrollY, C !== null) { const D = m.kerning[M]; S += void 0 !== D ? D : 0; } if (l) {
              const I = l({
                tint: {
                  topLeft: 0, topRight: 0, bottomLeft: 0, bottomRight: 0,
                },
                index: B,
                charCode: y,
                x: S,
                y: A,
                scale: k,
                rotation: 0,
                data: m.data,
              }); S = I.x, A = I.y, k = I.scale, F = I.rotation;
            }S *= k, A *= k, S -= u, A -= c, O && (S |= 0, A |= 0), _.save(), _.translate(S, A), _.rotate(F), _.scale(k, k), _.drawImage(E, x, w, b, T, 0, 0, b, T), _.restore(), p += m.xAdvance, v += 1, C = m, M = y;
          }
        } else p = 0, v = 0, g += f, C = null;
      } e.cropWidth > 0 && e.cropHeight > 0 && _.restore(), _.restore();
    }
  };
}, function (t, e, i) { const n = i(2); t.exports = function (t, e, i, s, r) { const o = e.text.length; n.RENDER_MASK !== e.renderFlags || o === 0 || e.cameraFilter > 0 && e.cameraFilter & s._id || this.pipeline.batchDynamicBitmapText(e, s, r); }; }, function (t, e, i) { let n = i(3); let s = i(3); n = i(900), s = i(899), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const n = i(2); t.exports = function (t, e, i, s, r) { if (!(n.RENDER_MASK !== e.renderFlags || e.cameraFilter > 0 && e.cameraFilter & s._id)) { const o = e.list; const a = e.localTransform; void 0 === r ? a.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY) : (a.loadIdentity(), a.multiply(r), a.translate(e.x, e.y), a.rotate(e.rotation), a.scale(e.scaleX, e.scaleY)); for (let h = e._alpha, l = e.scrollFactorX, u = e.scrollFactorY, c = 0; c < o.length; ++c) { const d = o[c]; const f = d._alpha; const p = d.scrollFactorX; const g = d.scrollFactorY; d.setScrollFactor(p * l, g * u), d.setAlpha(f * h), d.renderCanvas(t, d, i, s, a), d.setAlpha(f), d.setScrollFactor(p, g); } } }; }, function (t, e, i) { const n = i(2); t.exports = function (t, e, i, s, r) { if (!(n.RENDER_MASK !== e.renderFlags || e.cameraFilter > 0 && e.cameraFilter & s._id)) { const o = e.list; const a = e.localTransform; void 0 === r ? a.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY) : (a.loadIdentity(), a.multiply(r), a.translate(e.x, e.y), a.rotate(e.rotation), a.scale(e.scaleX, e.scaleY)); for (let h = e._alpha, l = e.scrollFactorX, u = e.scrollFactorY, c = 0; c < o.length; ++c) { const d = o[c]; const f = d._alpha; const p = d.scrollFactorX; const g = d.scrollFactorY; d.setScrollFactor(p * l, g * u), d.setAlpha(f * h), d.renderWebGL(t, d, i, s, a), d.setAlpha(f), d.setScrollFactor(p, g); } } }; }, function (t, e, i) { let n = i(3); let s = i(3); n = i(903), s = i(902), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) {
  const n = new (i(0))({
    initialize(t, e, i, n, s) { this.parent = t, this.x = e, this.y = i, this.frame = n, this.data = {}, this._visible = s, this._alpha = 1, this.flipX = !1, this.flipY = !1; }, setFrame(t) { return t = void 0 === t ? this.parent.frame : this.parent.texture.get(t), this; }, resetFlip() { return this.flipX = !1, this.flipY = !1, this; }, reset(t, e, i) { return this.x = t, this.y = e, this.flipX = !1, this.flipY = !1, this._alpha = 1, this._visible = !0, this.parent.dirty = !0, i && this.setFrame(i), this; }, setFlipX(t) { return this.flipX = t, this; }, setFlipY(t) { return this.flipY = t, this; }, setFlip(t, e) { return this.flipX = t, this.flipY = e, this; }, setVisible(t) { return this.visible = t, this; }, setAlpha(t) { return this.alpha = t, this; }, destroy() { this.parent.dirty = !0, this.parent.children.remove(this), this.parent = void 0, this.frame = void 0, this.data = void 0; }, visible: { get() { return this._visible; }, set(t) { this._visible = t, this.parent.dirty = !0; } }, alpha: { get() { return this._alpha; }, set(t) { this._alpha = t, this.parent.dirty = !0; } },
  }); t.exports = n;
}, function (t, e, i) { const n = i(2); t.exports = function (t, e, i, s, r) { if (!(n.RENDER_MASK !== e.renderFlags || e.cameraFilter > 0 && e.cameraFilter & s._id)) { const o = e.getRenderList(); t.setBlendMode(e.blendMode); const a = t.gameContext; const h = e.x - s.scrollX * e.scrollFactorX; const l = e.y - s.scrollY * e.scrollFactorY; if (a.save(), void 0 !== r) { const u = r.matrix; a.transform(u[0], u[1], u[2], u[3], u[4], u[5]); } for (let c = 0; c < o.length; c++) { const d = o[c]; const f = d.flipX || d.flipY; const p = d.frame; const g = p.canvasData; let v = p.x; let { y } = p; let m = 1; let x = 1; f ? (d.flipX && (m = -1, v -= g.dWidth), d.flipY && (x = -1, y -= g.dHeight), a.save(), a.translate(d.x + h, d.y + l), a.scale(m, x), a.drawImage(p.source.image, g.sx, g.sy, g.sWidth, g.sHeight, v, y, g.dWidth, g.dHeight), a.restore()) : t.blitImage(v + d.x + h, y + d.y + l, d.frame); }a.restore(); } }; }, function (t, e, i) { const n = i(2); t.exports = function (t, e, i, s, r) { n.RENDER_MASK !== e.renderFlags || e.cameraFilter > 0 && e.cameraFilter & s._id || this.pipeline.drawBlitter(e, s, r); }; }, function (t, e, i) { let n = i(3); let s = i(3); n = i(907), s = i(906), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const n = i(2); t.exports = function (t, e, i, s, r) { const o = e.text; const a = o.length; if (!(n.RENDER_MASK !== e.renderFlags || a === 0 || e.cameraFilter > 0 && e.cameraFilter & s._id)) { const h = e.frame; const l = e.fontData.chars; const u = e.fontData.lineHeight; const c = e.letterSpacing; let d = 0; let f = 0; let p = 0; let g = 0; let v = null; let y = 0; let m = 0; let x = 0; let w = 0; let b = 0; let T = 0; let S = null; let A = 0; const C = t.currentContext; const M = e.frame.source.image; const _ = h.cutX; const E = h.cutY; const P = e.fontSize / e.fontData.size; t.currentBlendMode !== e.blendMode && (t.currentBlendMode = e.blendMode, C.globalCompositeOperation = t.blendModes[e.blendMode]), t.currentAlpha !== e.alpha && (t.currentAlpha = e.alpha, C.globalAlpha = e.alpha), t.currentScaleMode !== e.scaleMode && (t.currentScaleMode = e.scaleMode); const L = t.config.roundPixels; let F = e.x - s.scrollX * e.scrollFactorX + e.frame.x; let k = e.y - s.scrollY * e.scrollFactorY + e.frame.y; if (L && (F |= 0, k |= 0), C.save(), void 0 !== r) { const R = r.matrix; C.transform(R[0], R[1], R[2], R[3], R[4], R[5]); }C.translate(F, k), C.rotate(e.rotation), C.translate(-e.displayOriginX, -e.displayOriginY), C.scale(e.scaleX, e.scaleY); for (let O = 0; O < a; ++O) if ((g = o.charCodeAt(O)) !== 10) { if (v = l[g]) { if (y = _ + v.x, m = E + v.y, x = v.width, w = v.height, b = p + v.xOffset + d, T = v.yOffset + f, S !== null) { const B = v.kerning[A]; b += void 0 !== B ? B : 0; }b *= P, T *= P, d += v.xAdvance + c, p += 1, S = v, A = g, x !== 0 && w !== 0 && g !== 32 && (L && (b |= 0, T |= 0), C.save(), C.translate(b, T), C.scale(P, P), C.drawImage(M, y, m, x, w, 0, 0, x, w), C.restore()); } } else d = 0, p = 0, f += u, S = null; C.restore(); } }; }, function (t, e, i) { const n = i(2); t.exports = function (t, e, i, s, r) { const o = e.text.length; n.RENDER_MASK !== e.renderFlags || o === 0 || e.cameraFilter > 0 && e.cameraFilter & s._id || this.pipeline.batchBitmapText(this, s, r); }; }, function (t, e, i) { let n = i(3); let s = i(3); n = i(910), s = i(909), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const n = i(461); t.exports = function (t, e, i, s, r, o, a) { const h = t.sys.textures.getFrame(i, s); const l = t.sys.cache.xml.get(r); if (h && l) { const u = n(l, o, a, h); return t.sys.cache.bitmapFont.add(e, { data: u, texture: i, frame: s }), !0; } return !1; }; }, function (t, e, i) {
  const n = {
    DisplayList: i(491),
    GameObjectCreator: i(13),
    GameObjectFactory: i(11),
    UpdateList: i(463),
    Components: i(15),
    BuildGameObject: i(24),
    BuildGameObjectAnimation: i(124),
    GameObject: i(2),
    BitmapText: i(252),
    Blitter: i(251),
    Container: i(250),
    DynamicBitmapText: i(249),
    Graphics: i(112),
    Group: i(109),
    Image: i(69),
    Particles: i(898),
    PathFollower: i(405),
    RenderTexture: i(233),
    RetroFont: i(887),
    Sprite3D: i(149),
    Sprite: i(34),
    Text: i(107),
    TileSprite: i(232),
    Zone: i(156),
    Factories: {
      Blitter: i(881), Container: i(880), DynamicBitmapText: i(879), Graphics: i(397), Group: i(878), Image: i(396), Particles: i(877), PathFollower: i(876), RenderTexture: i(875), Sprite3D: i(874), Sprite: i(395), StaticBitmapText: i(873), Text: i(394), TileSprite: i(872), Zone: i(871),
    },
    Creators: {
      Blitter: i(870), Container: i(869), DynamicBitmapText: i(868), Graphics: i(393), Group: i(867), Image: i(392), Particles: i(866), RenderTexture: i(865), Sprite3D: i(864), Sprite: i(391), StaticBitmapText: i(863), Text: i(390), TileSprite: i(862), Zone: i(861),
    },
  }; n.Mesh = i(144), n.Quad = i(231), n.Factories.Mesh = i(857), n.Factories.Quad = i(856), n.Creators.Mesh = i(855), n.Creators.Quad = i(854), n.Light = i(389), i(388), i(853), t.exports = n;
}, function (t, e, i) {
  t.exports = {
    AddToDOM: i(127), DOMContentLoaded: i(270), ParseXML: i(269), RemoveFromDOM: i(268), RequestAnimationFrame: i(267),
  };
}, function (t, e, i) { const n = i(534); t.exports = function (t, e, i, s, r) { return void 0 === s && (s = 255), void 0 === r && (r = '#'), r === '#' ? `#${((1 << 24) + (t << 16) + (e << 8) + i).toString(16).slice(1)}` : `0x${n(s)}${n(t)}${n(e)}${n(i)}`; }; }, function (t, e) { t.exports = function (t, e, i) { t /= 255, e /= 255, i /= 255; const n = Math.min(t, e, i); const s = Math.max(t, e, i); const r = s - n; let o = 0; return s !== n && (s === t ? o = (e - i) / r + (e < i ? 6 : 0) : s === e ? o = (i - t) / r + 2 : s === i && (o = (t - e) / r + 4), o /= 6), { h: o, s: s === 0 ? 0 : r / s, v: s }; }; }, function (t, e, i) { const n = i(271); const s = i(30); t.exports = function (t, e) { return void 0 === t && (t = 0), void 0 === e && (e = 255), new s(n(t, e), n(t, e), n(t, e)); }; }, function (t, e, i) { const n = i(120); const s = function (t, e, i, s, r, o, a, h) { void 0 === a && (a = 100), void 0 === h && (h = 0); const l = h / a; return { r: n(t, s, l), g: n(e, r, l), b: n(i, o, l) }; }; t.exports = { RGBWithRGB: s, ColorWithRGB(t, e, i, n, r, o) { return void 0 === r && (r = 100), void 0 === o && (o = 0), s(t.r, t.g, t.b, e, i, n, r, o); }, ColorWithColor(t, e, i, n) { return void 0 === i && (i = 100), void 0 === n && (n = 0), s(t.r, t.g, t.b, e.r, e.g, e.b, i, n); } }; }, function (t, e, i) { const n = i(532); t.exports = function (t, e) { void 0 === t && (t = 1), void 0 === e && (e = 1); for (var i = [], s = 0; s <= 359; s++)i.push(n(s / 359, t, e)); return i; }; }, function (t, e, i) { const n = i(30); const s = i(533); t.exports = function (t, e, i) { let r = i; let o = i; let a = i; if (e !== 0) { const h = i < 0.5 ? i * (1 + e) : i + e - i * e; const l = 2 * i - h; r = s(l, h, t + 1 / 3), o = s(l, h, t), a = s(l, h, t - 1 / 3); } return (new n()).setGLTo(r, o, a, 1); }; }, function (t, e) {
  t.exports = function (t) {
    const e = {
      r: t >> 16 & 255, g: t >> 8 & 255, b: 255 & t, a: 255,
    }; return t > 16777215 && (e.a = t >>> 24), e;
  };
}, function (t, e) { t.exports = function (t, e) { void 0 === e && (e = 'none'); return ['-webkit-', '-khtml-', '-moz-', '-ms-', ''].forEach((i) => { t.style[`${i}user-select`] = e; }), t.style['-webkit-touch-callout'] = e, t.style['-webkit-tap-highlight-color'] = 'rgba(0, 0, 0, 0)', t; }; }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = 'none'), t.style.msTouchAction = e, t.style['ms-touch-action'] = e, t.style['touch-action'] = e, t; }; }, function (t, e, i) {
  t.exports = {
    Interpolation: i(272), Pool: i(22), Smoothing: i(128), TouchAction: i(923), UserSelect: i(922),
  };
}, function (t, e) { t.exports = function (t) { return t.height * t.originY; }; }, function (t, e) { t.exports = function (t) { return t.width * t.originX; }; }, function (t, e, i) {
  t.exports = {
    CenterOn: i(588), GetBottom: i(48), GetCenterX: i(91), GetCenterY: i(88), GetLeft: i(46), GetOffsetX: i(926), GetOffsetY: i(925), GetRight: i(44), GetTop: i(42), SetBottom: i(47), SetCenterX: i(90), SetCenterY: i(89), SetLeft: i(45), SetRight: i(43), SetTop: i(41),
  };
}, function (t, e, i) { const n = i(44); const s = i(42); const r = i(47); const o = i(43); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, n(e) + i), r(t, s(e) - a), t; }; }, function (t, e, i) { const n = i(46); const s = i(42); const r = i(47); const o = i(45); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, n(e) - i), r(t, s(e) - a), t; }; }, function (t, e, i) { const n = i(91); const s = i(42); const r = i(47); const o = i(90); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, n(e) + i), r(t, s(e) - a), t; }; }, function (t, e, i) { const n = i(44); const s = i(42); const r = i(45); const o = i(41); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, n(e) + i), o(t, s(e) - a), t; }; }, function (t, e, i) { const n = i(88); const s = i(44); const r = i(89); const o = i(45); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) + i), r(t, n(e) + a), t; }; }, function (t, e, i) { const n = i(48); const s = i(44); const r = i(47); const o = i(45); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) + i), r(t, n(e) + a), t; }; }, function (t, e, i) { const n = i(46); const s = i(42); const r = i(43); const o = i(41); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, n(e) - i), o(t, s(e) - a), t; }; }, function (t, e, i) { const n = i(88); const s = i(46); const r = i(89); const o = i(43); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) - i), r(t, n(e) + a), t; }; }, function (t, e, i) { const n = i(48); const s = i(46); const r = i(47); const o = i(43); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) - i), r(t, n(e) + a), t; }; }, function (t, e, i) { const n = i(48); const s = i(44); const r = i(43); const o = i(41); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, s(e) + i), o(t, n(e) + a), t; }; }, function (t, e, i) { const n = i(48); const s = i(46); const r = i(45); const o = i(41); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, s(e) - i), o(t, n(e) + a), t; }; }, function (t, e, i) { const n = i(48); const s = i(91); const r = i(90); const o = i(41); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, s(e) + i), o(t, n(e) + a), t; }; }, function (t, e, i) {
  t.exports = {
    BottomCenter: i(939), BottomLeft: i(938), BottomRight: i(937), LeftBottom: i(936), LeftCenter: i(935), LeftTop: i(934), RightBottom: i(933), RightCenter: i(932), RightTop: i(931), TopCenter: i(930), TopLeft: i(929), TopRight: i(928),
  };
}, function (t, e, i) {
  t.exports = {
    BottomCenter: i(592), BottomLeft: i(591), BottomRight: i(590), Center: i(589), LeftCenter: i(587), QuickSet: i(593), RightCenter: i(586), TopCenter: i(585), TopLeft: i(584), TopRight: i(583),
  };
}, function (t, e, i) { const n = i(299); const s = i(18); let r = { In: i(941), To: i(940) }; r = s(!1, r, n), t.exports = r; }, function (t, e, i) {
  t.exports = {
    Align: i(942), Bounds: i(927), Canvas: i(924), Color: i(535), Masks: i(531),
  };
}, function (t, e, i) {
  const n = i(0); const s = i(7); const r = new n({
    initialize(t, e) { this.active = !1, this.p0 = new s(t, e); }, getPoint(t, e) { return void 0 === e && (e = new s()), e.copy(this.p0); }, getPointAt(t, e) { return this.getPoint(t, e); }, getResolution() { return 1; }, getLength() { return 0; }, toJSON() { return { type: 'MoveTo', points: [this.p0.x, this.p0.y] }; },
  }); t.exports = r;
}, function (t, e, i) {
  const n = i(0); const s = i(544); const r = i(542); const o = i(11); const a = i(541); const h = i(944); const l = i(540); const u = i(14); const c = i(538); const d = i(7); const f = new n({
    initialize(t, e) { void 0 === t && (t = 0), void 0 === e && (e = 0), this.name = '', this.curves = [], this.cacheLengths = [], this.autoClose = !1, this.startPoint = new d(), this._tmpVec2A = new d(), this._tmpVec2B = new d(), typeof t === 'object' ? this.fromJSON(t) : this.startPoint.set(t, e); },
    add(t) { return this.curves.push(t), this; },
    circleTo(t, e, i) { return void 0 === e && (e = !1), this.ellipseTo(t, t, 0, 360, e, i); },
    closePath() { const t = this.curves[0].getPoint(0); const e = this.curves[this.curves.length - 1].getPoint(1); return t.equals(e) || this.curves.push(new a(e, t)), this; },
    cubicBezierTo(t, e, i, n, r, o) { let a; let h; let l; const u = this.getEndPoint(); return t instanceof d ? (a = t, h = e, l = i) : (a = new d(i, n), h = new d(r, o), l = new d(t, e)), this.add(new s(u, a, h, l)); },
    quadraticBezierTo(t, e, i, n) { let s; let r; const o = this.getEndPoint(); return t instanceof d ? (s = t, r = e) : (s = new d(i, n), r = new d(t, e)), this.add(new l(o, s, r)); },
    draw(t, e) { for (let i = 0; i < this.curves.length; i++) { const n = this.curves[i]; n.active && n.draw(t, e); } return t; },
    ellipseTo(t, e, i, n, s, o) { const a = new r(0, 0, t, e, i, n, s, o); const h = this.getEndPoint(this._tmpVec2A); const l = a.getStartPoint(this._tmpVec2B); return h.subtract(l), a.x = h.x, a.y = h.y, this.add(a); },
    fromJSON(t) { this.curves = [], this.cacheLengths = [], this.startPoint.set(t.x, t.y), this.autoClose = t.autoClose; for (let e = 0; e < t.curves.length; e++) { const i = t.curves[e]; switch (i.type) { case 'LineCurve': this.add(a.fromJSON(i)); break; case 'EllipseCurve': this.add(r.fromJSON(i)); break; case 'SplineCurve': this.add(c.fromJSON(i)); break; case 'CubicBezierCurve': this.add(s.fromJSON(i)); break; case 'QuadraticBezierCurve': this.add(l.fromJSON(i)); } } return this; },
    getBounds(t, e) { void 0 === t && (t = new u()), void 0 === e && (e = 16), t.x = Number.MAX_VALUE, t.y = Number.MAX_VALUE; for (var i = new u(), n = Number.MIN_SAFE_INTEGER, s = Number.MIN_SAFE_INTEGER, r = 0; r < this.curves.length; r++) { const o = this.curves[r]; o.active && (o.getBounds(i, e), t.x = Math.min(t.x, i.x), t.y = Math.min(t.y, i.y), n = Math.max(n, i.right), s = Math.max(s, i.bottom)); } return t.right = n, t.bottom = s, t; },
    getCurveLengths() { if (this.cacheLengths.length === this.curves.length) return this.cacheLengths; for (var t = [], e = 0, i = 0; i < this.curves.length; i++)e += this.curves[i].getLength(), t.push(e); return this.cacheLengths = t, t; },
    getEndPoint(t) { return void 0 === t && (t = new d()), this.curves.length > 0 ? this.curves[this.curves.length - 1].getPoint(1, t) : t.copy(this.startPoint), t; },
    getLength() { const t = this.getCurveLengths(); return t[t.length - 1]; },
    getPoint(t, e) { void 0 === e && (e = new d()); for (let i = t * this.getLength(), n = this.getCurveLengths(), s = 0; s < n.length;) { if (n[s] >= i) { const r = n[s] - i; const o = this.curves[s]; const a = o.getLength(); const h = a === 0 ? 0 : 1 - r / a; return o.getPointAt(h, e); }s++; } return null; },
    getPoints(t) { void 0 === t && (t = 12); for (var e, i = [], n = 0; n < this.curves.length; n++) { const s = this.curves[n]; if (s.active) for (let r = s.getResolution(t), o = s.getPoints(r), a = 0; a < o.length; a++) { const h = o[a]; e && e.equals(h) || (i.push(h), e = h); } } return this.autoClose && i.length > 1 && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i; },
    getRandomPoint(t) { return void 0 === t && (t = new d()), this.getPoint(Math.random(), t); },
    getSpacedPoints(t) { void 0 === t && (t = 40); for (var e = [], i = 0; i <= t; i++)e.push(this.getPoint(i / t)); return this.autoClose && e.push(e[0]), e; },
    getStartPoint(t) { return void 0 === t && (t = new d()), t.copy(this.startPoint); },
    lineTo(t, e) { t instanceof d ? this._tmpVec2B.copy(t) : this._tmpVec2B.set(t, e); const i = this.getEndPoint(this._tmpVec2A); return this.add(new a([i.x, i.y, this._tmpVec2B.x, this._tmpVec2B.y])); },
    splineTo(t) { return t.unshift(this.getEndPoint()), this.add(new c(t)); },
    moveTo(t, e) { return this.add(new h(t, e)); },
    toJSON() {
      for (var t = [], e = 0; e < this.curves.length; e++)t.push(this.curves[e].toJSON()); return {
        type: 'Path', x: this.startPoint.x, y: this.startPoint.y, autoClose: this.autoClose, curves: t,
      };
    },
    updateArcLengths() { this.cacheLengths = [], this.getCurveLengths(); },
    destroy() { this.curves.length = 0, this.cacheLengths.length = 0, this.startPoint = void 0; },
  }); o.register('path', (t, e) => new f(t, e)), t.exports = f;
}, function (t, e, i) {
  t.exports = {
    Path: i(945), CubicBezier: i(544), Curve: i(85), Ellipse: i(542), Line: i(541), QuadraticBezier: i(540), Spline: i(538),
  };
}, function (t, e) {
  t.exports = {
    0: '#000', 1: '#191028', 2: '#46af45', 3: '#a1d685', 4: '#453e78', 5: '#7664fe', 6: '#833129', 7: '#9ec2e8', 8: '#dc534b', 9: '#e18d79', A: '#d6b97b', B: '#e9d8a1', C: '#216c4b', D: '#d365c8', E: '#afaab9', F: '#fff',
  };
}, function (t, e) {
  t.exports = {
    0: '#000', 1: '#191028', 2: '#46af45', 3: '#a1d685', 4: '#453e78', 5: '#7664fe', 6: '#833129', 7: '#9ec2e8', 8: '#dc534b', 9: '#e18d79', A: '#d6b97b', B: '#e9d8a1', C: '#216c4b', D: '#d365c8', E: '#afaab9', F: '#f5f4eb',
  };
}, function (t, e) {
  t.exports = {
    0: '#000', 1: '#2234d1', 2: '#0c7e45', 3: '#44aacc', 4: '#8a3622', 5: '#5c2e78', 6: '#aa5c3d', 7: '#b5b5b5', 8: '#5e606e', 9: '#4c81fb', A: '#6cd947', B: '#7be2f9', C: '#eb8a60', D: '#e23d69', E: '#ffd93f', F: '#fff',
  };
}, function (t, e) {
  t.exports = {
    0: '#000', 1: '#fff', 2: '#8b4131', 3: '#7bbdc5', 4: '#8b41ac', 5: '#6aac41', 6: '#3931a4', 7: '#d5de73', 8: '#945a20', 9: '#5a4100', A: '#bd736a', B: '#525252', C: '#838383', D: '#acee8b', E: '#7b73de', F: '#acacac',
  };
}, function (t, e, i) {
  t.exports = {
    ARNE16: i(275), C64: i(950), CGA: i(949), JMP: i(948), MSX: i(947),
  };
}, function (t, e, i) { t.exports = { GenerateTexture: i(276), Palettes: i(951) }; }, function (t, e, i) {
  const n = i(0); const s = i(546); const r = i(545); const o = i(12); const a = new n({
    initialize(t) { this.scene = t, this.systems = t.sys, this.cameras = [], t.sys.events.once('boot', this.boot, this), t.sys.events.on('start', this.start, this); }, boot() { this.systems.events.once('destroy', this.destroy, this); }, start() { const t = this.systems.events; t.on('update', this.update, this), t.once('shutdown', this.shutdown, this); }, add(t, e, i) { return this.addPerspectiveCamera(t, e, i); }, addOrthographicCamera(t, e) { const i = this.scene.sys.game.config; void 0 === t && (t = i.width), void 0 === e && (e = i.height); const n = new s(this.scene, t, e); return this.cameras.push(n), n; }, addPerspectiveCamera(t, e, i) { const n = this.scene.sys.game.config; void 0 === t && (t = 80), void 0 === e && (e = n.width), void 0 === i && (i = n.height); const s = new r(this.scene, t, e, i); return this.cameras.push(s), s; }, getCamera(t) { for (let e = 0; e < this.cameras.length; e++) if (this.cameras[e].name === t) return this.cameras[e]; return null; }, removeCamera(t) { const e = this.cameras.indexOf(t); e !== -1 && this.cameras.splice(e, 1); }, removeAll() { for (;this.cameras.length > 0;) { this.cameras.pop().destroy(); } return this.main; }, update(t, e) { for (let i = 0, n = this.cameras.length; i < n; ++i) this.cameras[i].update(t, e); }, shutdown() { const t = this.systems.events; t.off('update', this.update, this), t.off('shutdown', this.shutdown, this), this.removeAll(); }, destroy() { this.shutdown(), this.scene.sys.events.off('start', this.start, this), this.scene = null, this.systems = null; },
  }); o.register('CameraManager3D', a, 'cameras3d'), t.exports = a;
}, function (t, e, i) {
  t.exports = {
    Camera: i(279), CameraManager: i(953), OrthographicCamera: i(546), PerspectiveCamera: i(545),
  };
}, function (t, e, i) {
  t.exports = {
    Fixed: i(561), FixedKeyControl: i(561), Smoothed: i(560), SmoothedKeyControl: i(560),
  };
}, function (t, e, i) { t.exports = { Controls: i(955), Scene2D: i(559), Sprite3D: i(954) }; }, function (t, e, i) { const n = i(39); t.exports = function (t, e, i) { void 0 === i && (i = 0); for (let s = 0; s < t.length; s++) { const r = t[s]; r.x = n(r.x, e.left - i, e.right + i), r.y = n(r.y, e.top - i, e.bottom + i); } return t; }; }, function (t, e) { t.exports = function (t) { for (let e = 0; e < t.length; e++)t[e].visible = !t[e].visible; return t; }; }, function (t, e) { t.exports = function (t, e, i, n, s) { void 0 === s && (s = !1); let r; const o = Math.abs(n - i) / t.length; if (s) for (r = 0; r < t.length; r++)t[r][e] += r * o; else for (r = 0; r < t.length; r++)t[r][e] = r * o; return t; }; }, function (t, e, i) { const n = i(286); t.exports = function (t, e, i, s, r) { void 0 === r && (r = !1); let o; const a = Math.abs(s - i) / t.length; if (r) for (o = 0; o < t.length; o++)t[o][e] += n(o * a, i, s); else for (o = 0; o < t.length; o++)t[o][e] = n(o * a, i, s); return t; }; }, function (t, e, i) { const n = i(287); t.exports = function (t, e, i, s, r) { void 0 === r && (r = !1); let o; const a = Math.abs(s - i) / t.length; if (r) for (o = 0; o < t.length; o++)t[o][e] += n(o * a, i, s); else for (o = 0; o < t.length; o++)t[o][e] = n(o * a, i, s); return t; }; }, function (t, e, i) { const n = i(94); t.exports = function (t) { return n(t); }; }, function (t, e, i) { const n = i(7); t.exports = function (t, e, i, s, r) { let o; let a; let h; let l; let u; let c; if (void 0 === s && (s = 0), void 0 === r && (r = new n()), t.length > 1) if (s === 0) { const d = t.length - 1; for (o = t[d].x, a = t[d].y, h = d - 1; h >= 0; h--)l = (c = t[h]).x, u = c.y, c.x = o, c.y = a, o = l, a = u; t[d].x = e, t[d].y = i; } else { for (o = t[0].x, a = t[0].y, h = 1; h < t.length; h++)l = (c = t[h]).x, u = c.y, c.x = o, c.y = a, o = l, a = u; t[0].x = e, t[0].y = i; } else o = t[0].x, a = t[0].y, t[0].x = e, t[0].y = i; return r.x = o, r.y = a, r; }; }, function (t, e, i) { const n = i(25); t.exports = function (t, e, i, s, r) { return n(t, 'y', e, i, s, r); }; }, function (t, e, i) { const n = i(25); t.exports = function (t, e, i, s, r, o, a) { return void 0 !== i && i !== null || (i = e), n(t, 'x', e, s, o, a), n(t, 'y', i, r, o, a); }; }, function (t, e, i) { const n = i(25); t.exports = function (t, e, i, s, r) { return n(t, 'x', e, i, s, r); }; }, function (t, e, i) { const n = i(25); t.exports = function (t, e, i, s) { return n(t, 'visible', e, 0, i, s); }; }, function (t, e) { t.exports = function (t, e, i, n, s) { for (let r = 0; r < t.length; r++)t[r].setTint(e, i, n, s); return t; }; }, function (t, e, i) { const n = i(25); t.exports = function (t, e, i, s, r) { return n(t, 'scaleY', e, i, s, r); }; }, function (t, e, i) { const n = i(25); t.exports = function (t, e, i, s, r) { return n(t, 'scaleX', e, i, s, r); }; }, function (t, e, i) { const n = i(25); t.exports = function (t, e, i, s, r, o, a) { return void 0 !== i && i !== null || (i = e), n(t, 'scaleX', e, s, o, a), n(t, 'scaleY', i, r, o, a); }; }, function (t, e, i) { const n = i(25); t.exports = function (t, e, i, s, r) { return n(t, 'rotation', e, i, s, r); }; }, function (t, e, i) { const n = i(25); t.exports = function (t, e, i, s, r, o, a) { return void 0 !== i && i !== null || (i = e), n(t, 'originX', e, s, o, a), n(t, 'originY', i, r, o, a); }; }, function (t, e) { t.exports = function (t, e, i) { for (let n = 0; n < t.length; n++)t[n].setInteractive(e, i); return t; }; }, function (t, e, i) { const n = i(25); t.exports = function (t, e, i, s, r) { return n(t, 'depth', e, i, s, r); }; }, function (t, e, i) { const n = i(25); t.exports = function (t, e, i, s) { return n(t, 'blendMode', e, 0, i, s); }; }, function (t, e, i) { const n = i(25); t.exports = function (t, e, i, s, r) { return n(t, 'alpha', e, i, s, r); }; }, function (t, e, i) { const n = i(35); t.exports = function (t, e, i, s, r) { return n(t, 'scaleY', e, i, s, r); }; }, function (t, e, i) { const n = i(35); t.exports = function (t, e, i, s, r, o, a) { return void 0 !== i && i !== null || (i = e), n(t, 'scaleX', e, s, o, a), n(t, 'scaleY', i, r, o, a); }; }, function (t, e, i) { const n = i(35); t.exports = function (t, e, i, s, r) { return n(t, 'scaleX', e, i, s, r); }; }, function (t, e, i) { const n = i(288); t.exports = function (t, e, i, s) { const r = e.x; const o = e.y; if (s === 0) return t; for (let a = 0; a < t.length; a++)n(t[a], r, o, i, s); return t; }; }, function (t, e, i) { const n = i(288); const s = i(57); t.exports = function (t, e, i) { for (let r = e.x, o = e.y, a = 0; a < t.length; a++) { const h = t[a]; n(h, r, o, i, Math.max(1, s(h.x, h.y, r, o))); } return t; }; }, function (t, e, i) { const n = i(35); t.exports = function (t, e, i, s, r) { return n(t, 'rotation', e, i, s, r); }; }, function (t, e, i) { const n = i(151); t.exports = function (t, e) { for (let i = 0; i < t.length; i++)n(e, t[i]); return t; }; }, function (t, e, i) { const n = i(152); t.exports = function (t, e) { for (let i = 0; i < t.length; i++)n(e, t[i]); return t; }; }, function (t, e, i) { const n = i(153); t.exports = function (t, e) { for (let i = 0; i < t.length; i++)n(e, t[i]); return t; }; }, function (t, e, i) { const n = i(131); t.exports = function (t, e) { for (let i = 0; i < t.length; i++)n(e, t[i]); return t; }; }, function (t, e, i) { const n = i(155); t.exports = function (t, e) { for (let i = 0; i < t.length; i++)n(e, t[i]); return t; }; }, function (t, e) { t.exports = function (t, e, i) { for (let n = 0; n < t.length; n++)t[n].anims.play(e, i); return t; }; }, function (t, e, i) {
  const n = i(564); t.exports = function (t, e, i) {
    let s = n({
      x1: e.x1, y1: e.y1, x2: e.x2, y2: e.y2,
    }, i); const r = n({
      x1: e.x2, y1: e.y2, x2: e.x3, y2: e.y3,
    }, i); const o = n({
      x1: e.x3, y1: e.y3, x2: e.x1, y2: e.y1,
    }, i); s.pop(), r.pop(), o.pop(); for (let a = (s = s.concat(r, o)).length / t.length, h = 0, l = 0; l < t.length; l++) { const u = t[l]; const c = s[Math.floor(h)]; u.x = c.x, u.y = c.y, h += a; } return t;
  };
}, function (t, e, i) { const n = i(565); const s = i(290); const r = i(289); t.exports = function (t, e, i) { void 0 === i && (i = 0); const o = n(e, !1, t.length); i > 0 ? s(o, i) : i < 0 && r(o, Math.abs(i)); for (let a = 0; a < t.length; a++)t[a].x = o[a].x, t[a].y = o[a].y; return t; }; }, function (t, e, i) { const n = i(154); t.exports = function (t, e) { for (let i = n(e, t.length), s = 0; s < t.length; s++) { const r = t[s]; const o = i[s]; r.x = o.x, r.y = o.y; } return t; }; }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === i && (i = 0), void 0 === n && (n = 6.28); for (let s = i, r = (n - i) / t.length, o = e.width / 2, a = e.height / 2, h = 0; h < t.length; h++)t[h].x = e.x + o * Math.cos(s), t[h].y = e.y + a * Math.sin(s), s += r; return t; }; }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === i && (i = 0), void 0 === n && (n = 6.28); for (let s = i, r = (n - i) / t.length, o = 0; o < t.length; o++)t[o].x = e.x + e.radius * Math.cos(s), t[o].y = e.y + e.radius * Math.sin(s), s += r; return t; }; }, function (t, e, i) { const n = i(35); t.exports = function (t, e, i, s, r) { return n(t, 'y', e, i, s, r); }; }, function (t, e, i) { const n = i(35); t.exports = function (t, e, i, s, r, o, a) { return void 0 !== i && i !== null || (i = e), n(t, 'x', e, s, o, a), n(t, 'y', i, r, o, a); }; }, function (t, e, i) { const n = i(35); t.exports = function (t, e, i, s, r) { return n(t, 'x', e, i, s, r); }; }, function (t, e, i) { const n = i(35); t.exports = function (t, e, i, s, r) { return n(t, 'alpha', e, i, s, r); }; }, function (t, e, i) { const n = i(593); const s = i(299); const r = i(1); const o = i(3); const a = new (i(156))({ sys: { queueDepthSort: o, events: { once: o } } }, 0, 0, 1, 1); t.exports = function (t, e) { void 0 === e && (e = {}); const i = r(e, 'width', -1); const o = r(e, 'height', -1); const h = r(e, 'cellWidth', 1); const l = r(e, 'cellHeight', h); const u = r(e, 'position', s.TOP_LEFT); const c = r(e, 'x', 0); const d = r(e, 'y', 0); let f = 0; let p = 0; const g = i * h; const v = o * l; a.setPosition(c, d), a.setSize(h, l); for (let y = 0; y < t.length; y++) if (n(t[y], a, u), i === -1)p += l, a.y += l, p === v && (p = 0, a.x += h, a.y = d); else if (o === -1)f += h, a.x += h, f === g && (f = 0, a.x = c, a.y += l); else if (f += h, a.x += h, f === g && (f = 0, p += l, a.x = c, a.y += l, p === v)) break; return t; }; }, function (t, e) { t.exports = function (t, e, i) { void 0 === i && (i = 0); for (let n = i; n < t.length; n++) { const s = t[n]; let r = !0; for (const o in e)s[o] !== e[o] && (r = !1); if (r) return s; } return null; }; }, function (t, e) { t.exports = function (t, e, i) { void 0 === i && (i = 0); for (let n = i; n < t.length; n++) { const s = t[n]; let r = !0; for (const o in e)s[o] !== e[o] && (r = !1); if (r) return s; } return null; }; }, function (t, e) { t.exports = function (t, e, i) { for (let n = 0; n < t.length; n++) { const s = t[n]; e.call(i, s); } return t; }; }, function (t, e, i) { const n = i(35); t.exports = function (t, e, i, s, r) { return n(t, 'angle', e, i, s, r); }; }, function (t, e, i) {
  const n = i(220); const s = i(0); const r = i(49); const o = i(219); const a = i(1005); const h = i(9); const l = i(1); const u = i(4); const c = i(80); const d = i(301); const f = i(674); const p = i(669); const g = i(123); const v = new s({
    Extends: h,
    initialize(t, e) {
      h.call(this), this.scene = t, this.engine = a.create(e), this.localWorld = this.engine.world; const i = u(e, 'gravity', null); if (i && this.setGravity(i.x, i.y, i.scale), this.walls = {
        left: null, right: null, top: null, bottom: null,
      }, l(e, 'setBounds', !1)) { const n = e.setBounds; if (typeof n === 'boolean') this.setBounds(); else { const s = l(n, 'x', 0); const r = l(n, 'y', 0); const o = l(n, 'width', t.sys.game.config.width); const c = l(n, 'height', t.sys.game.config.height); const d = l(n, 'thickness', 64); const f = l(n, 'left', !0); const p = l(n, 'right', !0); const g = l(n, 'top', !0); const v = l(n, 'bottom', !0); this.setBounds(s, r, o, c, d, f, p, g, v); } } this.enabled = u(e, 'enabled', !0), this.correction = u(e, 'correction', 1), this.getDelta = u(e, 'getDelta', this.update60Hz), this.autoUpdate = u(e, 'autoUpdate', !0), this.drawDebug = u(e, 'debug', !1), this.debugGraphic, this.defaults = {
        debugShowBody: u(e, 'debugShowBody', !0), debugShowStaticBody: u(e, 'debugShowStaticBody', !0), debugShowVelocity: u(e, 'debugShowVelocity', !0), bodyDebugColor: u(e, 'debugBodyColor', 16711935), staticBodyDebugColor: u(e, 'debugBodyColor', 255), velocityDebugColor: u(e, 'debugVelocityColor', 65280), debugShowJoint: u(e, 'debugShowJoint', !0), jointDebugColor: u(e, 'debugJointColor', 0),
      }, this.drawDebug && this.createDebugGraphic(), this.setEventsProxy();
    },
    setEventsProxy() { const t = this; const e = this.engine; d.on(e, 'beforeUpdate', (e) => { t.emit('beforeupdate', e); }), d.on(e, 'afterUpdate', (e) => { t.emit('afterupdate', e); }), d.on(e, 'collisionStart', (e) => { let i; let n; const s = e.pairs; s.length > 0 && (i = s[0].bodyA, n = s[0].bodyB), t.emit('collisionstart', e, i, n); }), d.on(e, 'collisionActive', (e) => { let i; let n; const s = e.pairs; s.length > 0 && (i = s[0].bodyA, n = s[0].bodyB), t.emit('collisionactive', e, i, n); }), d.on(e, 'collisionEnd', (e) => { let i; let n; const s = e.pairs; s.length > 0 && (i = s[0].bodyA, n = s[0].bodyB), t.emit('collisionend', e, i, n); }); },
    setBounds(t, e, i, n, s, r, o, a, h) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.scene.sys.game.config.width), void 0 === n && (n = this.scene.sys.game.config.height), void 0 === s && (s = 128), void 0 === r && (r = !0), void 0 === o && (o = !0), void 0 === a && (a = !0), void 0 === h && (h = !0), this.updateWall(r, 'left', t - s, e, s, n), this.updateWall(o, 'right', t + i, e, s, n), this.updateWall(a, 'top', t, e - s, i, s), this.updateWall(h, 'bottom', t, e + n, i, s), this; },
    updateWall(t, e, i, n, s, r) { const o = this.walls[e]; t ? (o && p.remove(this.localWorld, o), i += s / 2, n += r / 2, this.walls[e] = this.create(i, n, s, r, { isStatic: !0, friction: 0, frictionStatic: 0 })) : (o && p.remove(this.localWorld, o), this.walls[e] = null); },
    createDebugGraphic() { const t = this.scene.sys.add.graphics({ x: 0, y: 0 }); return t.setDepth(Number.MAX_VALUE), this.debugGraphic = t, this.drawDebug = !0, t; },
    disableGravity() { return this.localWorld.gravity.x = 0, this.localWorld.gravity.y = 0, this.localWorld.gravity.scale = 0, this; },
    setGravity(t, e, i) { return void 0 === t && (t = 0), void 0 === e && (e = 1), this.localWorld.gravity.x = t, this.localWorld.gravity.y = e, void 0 !== i && (this.localWorld.gravity.scale = i), this; },
    create(t, e, i, s, r) { const o = n.rectangle(t, e, i, s, r); return p.add(this.localWorld, o), o; },
    add(t) { return p.add(this.localWorld, t), this; },
    remove(t, e) { const i = t.body ? t.body : t; return o.removeBody(this.localWorld, i, e), this; },
    removeConstraint(t, e) { return o.remove(this.localWorld, t, e), this; },
    convertTilemapLayer(t, e) { const i = t.layer; const n = t.getTilesWithin(0, 0, i.width, i.height, { isColliding: !0 }); return this.convertTiles(n, e), this; },
    convertTiles(t, e) { if (t.length === 0) return this; for (let i = 0; i < t.length; i++) new f(this, t[i], e); return this; },
    nextGroup(t) { return c.nextGroup(t); },
    nextCategory() { return c.nextCategory(); },
    pause() { return this.enabled = !1, this.emit('pause'), this; },
    resume() { return this.enabled = !0, this.emit('resume'), this; },
    update(t, e) { this.enabled && this.autoUpdate && a.update(this.engine, this.getDelta(t, e), this.correction); },
    step(t, e) { a.update(this.engine, t, e); },
    update60Hz() { return 1e3 / 60; },
    update30Hz() { return 1e3 / 30; },
    postUpdate() { if (this.drawDebug) { let t; let e; const i = this.debugGraphic; const n = o.allBodies(this.localWorld); for (i.clear(), i.lineStyle(1, this.defaults.bodyDebugColor), i.beginPath(), t = 0; t < n.length; t++) { if (!n[t].render.visible) return; for (e = 0; e < n[t].parts.length; e++) { const s = n[t].parts[e].vertices; i.moveTo(s[0].x, s[0].y); for (let a = 1; a < s.length; a++)i.lineTo(s[a].x, s[a].y); i.lineTo(s[0].x, s[0].y), i.strokePath(); } } if (i.closePath(), this.defaults.debugShowJoint) { i.lineStyle(2, this.defaults.jointDebugColor); const h = o.allConstraints(this.localWorld); for (t = 0; t < h.length; t++) { const l = h[t]; if (l.render.visible && l.pointA && l.pointB) { l.render.lineWidth && i.lineStyle(l.render.lineWidth, r.colorToNumber(l.render.strokeStyle)); var u; var c; const d = l.bodyA; const f = l.bodyB; if (u = d ? g.add(d.position, l.pointA) : l.pointA, l.render.type === 'pin')i.beginPath(), i.arc(u.x, u.y, 3, 0, 2 * Math.PI), i.closePath(); else { if (c = f ? g.add(f.position, l.pointB) : l.pointB, i.beginPath(), i.moveTo(u.x, u.y), l.render.type === 'spring') { var p; const v = g.sub(c, u); const y = g.perp(g.normalise(v)); const m = Math.ceil(r.clamp(l.length / 5, 12, 20)); for (e = 1; e < m; e += 1)p = e % 2 == 0 ? 1 : -1, i.lineTo(u.x + v.x * (e / m) + y.x * p * 4, u.y + v.y * (e / m) + y.y * p * 4); }i.lineTo(c.x, c.y); }l.render.lineWidth && i.strokePath(), l.render.anchors && (i.fillStyle(r.colorToNumber(l.render.strokeStyle)), i.beginPath(), i.arc(u.x, u.y, 6, 0, 2 * Math.PI), i.arc(c.x, c.y, 6, 0, 2 * Math.PI), i.closePath(), i.fillPath()); } } } } },
    fromPath(t, e) { void 0 === e && (e = []); return t.replace(/L?\s*([\-\d\.e]+)[\s,]*([\-\d\.e]+)*/gi, (t, i, n) => { e.push({ x: parseFloat(i), y: parseFloat(n) }); }), e; },
    shutdown() { d.off(this.engine), this.removeAllListeners(), p.clear(this.localWorld, !1), a.clear(this.engine); },
    destroy() { this.shutdown(); },
  }); t.exports = v;
}, function (t, e, i) {
  const n = {}; t.exports = n; const s = i(669); const r = i(331); const o = i(1006); const a = i(1007); const h = i(1028); const l = i(1008); const u = i(301); const c = i(219); const d = i(300); const f = i(49); const p = i(80); !(function () {
    n.create = function (t, e) {
      e = f.isElement(t) ? e : t, t = f.isElement(t) ? t : null, e = e || {}, (t || e.render) && f.warn('Engine.create: engine.render is deprecated (see docs)'); const i = {
        positionIterations: 6, velocityIterations: 4, constraintIterations: 2, enableSleeping: !1, events: [], plugin: {}, timing: { timestamp: 0, timeScale: 1 }, broadphase: { controller: l },
      }; const n = f.extend(i, e); return n.world = e.world || s.create(n.world), n.pairs = a.create(), n.broadphase = n.broadphase.controller.create(n.broadphase), n.metrics = n.metrics || { extended: !1 }, n.metrics = h.create(n.metrics), n;
    }, n.update = function (n, s, l) { s = s || 1e3 / 60, l = l || 1; let f; const p = n.world; const g = n.timing; const v = n.broadphase; let y = []; g.timestamp += s * g.timeScale; const m = { timestamp: g.timestamp }; u.trigger(n, 'beforeUpdate', m); const x = c.allBodies(p); const w = c.allConstraints(p); for (h.reset(n.metrics), n.enableSleeping && r.update(x, g.timeScale), e(x, p.gravity), i(x, s, g.timeScale, l, p.bounds), d.preSolveAll(x), f = 0; f < n.constraintIterations; f++)d.solveAll(w, g.timeScale); d.postSolveAll(x), v.controller ? (p.isModified && v.controller.clear(v), v.controller.update(v, x, n, p.isModified), y = v.pairsList) : y = x, p.isModified && c.setModified(p, !1, !1, !0); const b = v.detector(y, n); const T = n.pairs; const S = g.timestamp; for (a.update(T, b, S), a.removeOld(T, S), n.enableSleeping && r.afterCollisions(T.list, g.timeScale), T.collisionStart.length > 0 && u.trigger(n, 'collisionStart', { pairs: T.collisionStart }), o.preSolvePosition(T.list), f = 0; f < n.positionIterations; f++)o.solvePosition(T.list, x, g.timeScale); for (o.postSolvePosition(x), d.preSolveAll(x), f = 0; f < n.constraintIterations; f++)d.solveAll(w, g.timeScale); for (d.postSolveAll(x), o.preSolveVelocity(T.list), f = 0; f < n.velocityIterations; f++)o.solveVelocity(T.list, g.timeScale); return T.collisionActive.length > 0 && u.trigger(n, 'collisionActive', { pairs: T.collisionActive }), T.collisionEnd.length > 0 && u.trigger(n, 'collisionEnd', { pairs: T.collisionEnd }), h.update(n.metrics, n), t(x), u.trigger(n, 'afterUpdate', m), n; }, n.merge = function (t, e) { if (f.extend(t, e), e.world) { t.world = e.world, n.clear(t); for (let i = c.allBodies(t.world), s = 0; s < i.length; s++) { const o = i[s]; r.set(o, !1), o.id = f.nextId(); } } }, n.clear = function (t) { const e = t.world; a.clear(t.pairs); const i = t.broadphase; if (i.controller) { const n = c.allBodies(e); i.controller.clear(i), i.controller.update(i, n, t, !0); } }; var t = function (t) { for (let e = 0; e < t.length; e++) { const i = t[e]; i.force.x = 0, i.force.y = 0, i.torque = 0; } }; var e = function (t, e) { const i = void 0 !== e.scale ? e.scale : 0.001; if ((e.x !== 0 || e.y !== 0) && i !== 0) for (let n = 0; n < t.length; n++) { const s = t[n]; s.ignoreGravity || s.isStatic || s.isSleeping || (s.force.y += s.mass * e.y * i, s.force.x += s.mass * e.x * i); } }; var i = function (t, e, i, n, s) { for (let r = 0; r < t.length; r++) { const o = t[r]; o.isStatic || o.isSleeping || p.update(o, e, i, n); } };
  }());
}, function (t, e, i) { const n = {}; t.exports = n; const s = i(140); const r = i(123); const o = i(49); const a = i(139); n._restingThresh = 4, n._restingThreshTangent = 6, n._positionDampen = 0.9, n._positionWarming = 0.8, n._frictionNormalMultiplier = 5, n.preSolvePosition = function (t) { let e; let i; let n; for (e = 0; e < t.length; e++)(i = t[e]).isActive && (n = i.activeContacts.length, i.collision.parentA.totalContacts += n, i.collision.parentB.totalContacts += n); }, n.solvePosition = function (t, e, i) { let s; let r; let o; let a; let h; let l; let u; let c; let d; let f; let p; let g; let v; let y; let m; let x; const w = i * n._positionDampen; for (s = 0; s < e.length; s++) { const b = e[s]; b.previousPositionImpulse.x = b.positionImpulse.x, b.previousPositionImpulse.y = b.positionImpulse.y; } for (s = 0; s < t.length; s++)(a = t[s]).isActive && !a.isSensor && (l = (h = a.collision).parentA, u = h.parentB, c = h.normal, p = l.previousPositionImpulse, g = u.previousPositionImpulse, f = h.penetration, y = g.x - p.x + f.x, m = g.y - p.y + f.y, d = (r = c.x) * y + (o = c.y) * m, a.separation = d, x = (d - a.slop) * w, (l.isStatic || u.isStatic) && (x *= 2), l.isStatic || l.isSleeping || (v = x / l.totalContacts, l.positionImpulse.x += r * v, l.positionImpulse.y += o * v), u.isStatic || u.isSleeping || (v = x / u.totalContacts, u.positionImpulse.x -= r * v, u.positionImpulse.y -= o * v)); }, n.postSolvePosition = function (t) { for (let e = 0; e < t.length; e++) { const i = t[e]; if (i.totalContacts = 0, i.positionImpulse.x !== 0 || i.positionImpulse.y !== 0) { for (let o = 0; o < i.parts.length; o++) { const h = i.parts[o]; s.translate(h.vertices, i.positionImpulse), a.update(h.bounds, h.vertices, i.velocity), h.position.x += i.positionImpulse.x, h.position.y += i.positionImpulse.y; }i.positionPrev.x += i.positionImpulse.x, i.positionPrev.y += i.positionImpulse.y, r.dot(i.positionImpulse, i.velocity) < 0 ? (i.positionImpulse.x = 0, i.positionImpulse.y = 0) : (i.positionImpulse.x *= n._positionWarming, i.positionImpulse.y *= n._positionWarming); } } }, n.preSolveVelocity = function (t) { let e; let i; let n; let s; let o; let a; let h; let l; let u; let c; let d; let f; let p; let g; const v = r._temp[0]; const y = r._temp[1]; for (e = 0; e < t.length; e++) if ((n = t[e]).isActive && !n.isSensor) for (s = n.activeContacts, a = (o = n.collision).parentA, h = o.parentB, l = o.normal, u = o.tangent, i = 0; i < s.length; i++)d = (c = s[i]).vertex, f = c.normalImpulse, p = c.tangentImpulse, f === 0 && p === 0 || (v.x = l.x * f + u.x * p, v.y = l.y * f + u.y * p, a.isStatic || a.isSleeping || (g = r.sub(d, a.position, y), a.positionPrev.x += v.x * a.inverseMass, a.positionPrev.y += v.y * a.inverseMass, a.anglePrev += r.cross(g, v) * a.inverseInertia), h.isStatic || h.isSleeping || (g = r.sub(d, h.position, y), h.positionPrev.x -= v.x * h.inverseMass, h.positionPrev.y -= v.y * h.inverseMass, h.anglePrev -= r.cross(g, v) * h.inverseInertia)); }, n.solveVelocity = function (t, e) { for (let i = e * e, s = r._temp[0], a = r._temp[1], h = r._temp[2], l = r._temp[3], u = r._temp[4], c = r._temp[5], d = 0; d < t.length; d++) { const f = t[d]; if (f.isActive && !f.isSensor) { const p = f.collision; const g = p.parentA; const v = p.parentB; const y = p.normal; const m = p.tangent; const x = f.activeContacts; const w = 1 / x.length; g.velocity.x = g.position.x - g.positionPrev.x, g.velocity.y = g.position.y - g.positionPrev.y, v.velocity.x = v.position.x - v.positionPrev.x, v.velocity.y = v.position.y - v.positionPrev.y, g.angularVelocity = g.angle - g.anglePrev, v.angularVelocity = v.angle - v.anglePrev; for (let b = 0; b < x.length; b++) { const T = x[b]; const S = T.vertex; const A = r.sub(S, g.position, a); const C = r.sub(S, v.position, h); const M = r.add(g.velocity, r.mult(r.perp(A), g.angularVelocity), l); const _ = r.add(v.velocity, r.mult(r.perp(C), v.angularVelocity), u); const E = r.sub(M, _, c); const P = r.dot(y, E); const L = r.dot(m, E); const F = Math.abs(L); const k = o.sign(L); let R = (1 + f.restitution) * P; const O = o.clamp(f.separation + P, 0, 1) * n._frictionNormalMultiplier; let B = L; let D = 1 / 0; F > f.friction * f.frictionStatic * O * i && (D = F, B = o.clamp(f.friction * k * i, -D, D)); const I = r.cross(A, y); const z = r.cross(C, y); const Y = w / (g.inverseMass + v.inverseMass + g.inverseInertia * I * I + v.inverseInertia * z * z); if (R *= Y, B *= Y, P < 0 && P * P > n._restingThresh * i)T.normalImpulse = 0; else { const X = T.normalImpulse; T.normalImpulse = Math.min(T.normalImpulse + R, 0), R = T.normalImpulse - X; } if (L * L > n._restingThreshTangent * i)T.tangentImpulse = 0; else { const N = T.tangentImpulse; T.tangentImpulse = o.clamp(T.tangentImpulse + B, -D, D), B = T.tangentImpulse - N; }s.x = y.x * R + m.x * B, s.y = y.y * R + m.y * B, g.isStatic || g.isSleeping || (g.positionPrev.x += s.x * g.inverseMass, g.positionPrev.y += s.y * g.inverseMass, g.anglePrev += r.cross(A, s) * g.inverseInertia), v.isStatic || v.isSleeping || (v.positionPrev.x -= s.x * v.inverseMass, v.positionPrev.y -= s.y * v.inverseMass, v.anglePrev -= r.cross(C, s) * v.inverseInertia); } } } }; }, function (t, e, i) {
  const n = {}; t.exports = n; const s = i(605); const r = i(49); n.create = function (t) {
    return r.extend({
      table: {}, list: [], collisionStart: [], collisionActive: [], collisionEnd: [],
    }, t);
  }, n.update = function (t, e, i) { let n; let r; let o; let a; const h = t.list; const l = t.table; const u = t.collisionStart; const c = t.collisionEnd; const d = t.collisionActive; for (u.length = 0, c.length = 0, d.length = 0, a = 0; a < h.length; a++)h[a].confirmedActive = !1; for (a = 0; a < e.length; a++)(n = e[a]).collided && ((o = l[r = s.id(n.bodyA, n.bodyB)]) ? (o.isActive ? d.push(o) : u.push(o), s.update(o, n, i), o.confirmedActive = !0) : (o = s.create(n, i), l[r] = o, u.push(o), h.push(o))); for (a = 0; a < h.length; a++)(o = h[a]).confirmedActive || (s.setActive(o, !1, i), c.push(o)); }, n.removeOld = function (t, e) { let i; let n; let s; let r; const o = t.list; const a = t.table; const h = []; for (r = 0; r < o.length; r++)(n = (i = o[r]).collision).bodyA.isSleeping || n.bodyB.isSleeping ? i.timeUpdated = e : e - i.timeUpdated > 1e3 && h.push(r); for (r = 0; r < h.length; r++) delete a[(i = o[s = h[r] - r]).id], o.splice(s, 1); }, n.clear = function (t) { return t.table = {}, t.list.length = 0, t.collisionStart.length = 0, t.collisionActive.length = 0, t.collisionEnd.length = 0, t; };
}, function (t, e, i) {
  const n = {}; t.exports = n; const s = i(605); const r = i(673); const o = i(49); !(function () {
    n.create = function (t) {
      const e = {
        controller: n, detector: r.collisions, buckets: {}, pairs: {}, pairsList: [], bucketWidth: 48, bucketHeight: 48,
      }; return o.extend(e, t);
    }, n.update = function (i, n, s, r) { let o; let d; let f; let p; let g; const v = s.world; const y = i.buckets; let m = !1; const x = s.metrics; for (x.broadphaseTests = 0, o = 0; o < n.length; o++) { const w = n[o]; if ((!w.isSleeping || r) && !(w.bounds.max.x < v.bounds.min.x || w.bounds.min.x > v.bounds.max.x || w.bounds.max.y < v.bounds.min.y || w.bounds.min.y > v.bounds.max.y)) { const b = e(i, w); if (!w.region || b.id !== w.region.id || r) { x.broadphaseTests += 1, w.region && !r || (w.region = b); const T = t(b, w.region); for (d = T.startCol; d <= T.endCol; d++) for (f = T.startRow; f <= T.endRow; f++) { p = y[g = a(d, f)]; const S = d >= b.startCol && d <= b.endCol && f >= b.startRow && f <= b.endRow; const A = d >= w.region.startCol && d <= w.region.endCol && f >= w.region.startRow && f <= w.region.endRow; !S && A && A && p && u(i, p, w), (w.region === b || S && !A || r) && (p || (p = h(y, g)), l(i, p, w)); }w.region = b, m = !0; } } }m && (i.pairsList = c(i)); }, n.clear = function (t) { t.buckets = {}, t.pairs = {}, t.pairsList = []; }; var t = function (t, e) { const n = Math.min(t.startCol, e.startCol); const s = Math.max(t.endCol, e.endCol); const r = Math.min(t.startRow, e.startRow); const o = Math.max(t.endRow, e.endRow); return i(n, s, r, o); }; var e = function (t, e) { const n = e.bounds; const s = Math.floor(n.min.x / t.bucketWidth); const r = Math.floor(n.max.x / t.bucketWidth); const o = Math.floor(n.min.y / t.bucketHeight); const a = Math.floor(n.max.y / t.bucketHeight); return i(s, r, o, a); }; var i = function (t, e, i, n) {
      return {
        id: `${t},${e},${i},${n}`, startCol: t, endCol: e, startRow: i, endRow: n,
      };
    }; var a = function (t, e) { return `C${t}R${e}`; }; var h = function (t, e) { return t[e] = []; }; var l = function (t, e, i) { for (let n = 0; n < e.length; n++) { const r = e[n]; if (!(i.id === r.id || i.isStatic && r.isStatic)) { const o = s.id(i, r); const a = t.pairs[o]; a ? a[2] += 1 : t.pairs[o] = [i, r, 1]; } }e.push(i); }; var u = function (t, e, i) { e.splice(e.indexOf(i), 1); for (let n = 0; n < e.length; n++) { const r = e[n]; const o = s.id(i, r); const a = t.pairs[o]; a && (a[2] -= 1); } }; var c = function (t) { let e; let i; const n = []; e = o.keys(t.pairs); for (let s = 0; s < e.length; s++)(i = t.pairs[e[s]])[2] > 0 ? n.push(i) : delete t.pairs[e[s]]; return n; };
  }());
}, function (t, e, i) { const n = {}; t.exports = n; const s = i(670); const r = i(49); n.name = 'matter-js', n.version = '0.13.1', n.uses = [], n.used = [], n.use = function () { s.use(n, Array.prototype.slice.call(arguments)); }, n.before = function (t, e) { return t = t.replace(/^Matter./, ''), r.chainPathBefore(n, t, e); }, n.after = function (t, e) { return t = t.replace(/^Matter./, ''), r.chainPathAfter(n, t, e); }; }, function (t, e, i) { const n = i(302); const s = i(0); const r = i(606); const o = i(2); const a = i(1); const h = i(291); const l = i(34); const u = i(7); const c = new s({ Extends: l, Mixins: [r.Bounce, r.Collision, r.Force, r.Friction, r.Gravity, r.Mass, r.Sensor, r.SetBody, r.Sleep, r.Static, r.Transform, r.Velocity, h], initialize(t, e, i, s, r, h) { o.call(this, t.scene, 'Image'), this.anims = new n(this), this.setTexture(s, r), this.setSizeToFrame(), this.setOrigin(), this.world = t, this._tempVec2 = new u(e, i); const l = a(h, 'shape', null); l ? this.setBody(l, h) : this.setRectangle(this.width, this.height, h), this.setPosition(e, i), this.initPipeline('TextureTintPipeline'); } }); t.exports = c; }, function (t, e, i) { const n = i(0); const s = i(606); const r = i(2); const o = i(1); const a = i(69); const h = i(291); const l = i(7); const u = new n({ Extends: a, Mixins: [s.Bounce, s.Collision, s.Force, s.Friction, s.Gravity, s.Mass, s.Sensor, s.SetBody, s.Sleep, s.Static, s.Transform, s.Velocity, h], initialize(t, e, i, n, s, a) { r.call(this, t.scene, 'Image'), this.setTexture(n, s), this.setSizeToFrame(), this.setOrigin(), this.world = t, this._tempVec2 = new l(e, i); const h = o(a, 'shape', null); h ? this.setBody(h, a) : this.setRectangle(this.width, this.height, a), this.setPosition(e, i), this.initPipeline('TextureTintPipeline'); } }); t.exports = u; }, function (t, e, i) {
  const n = {}; t.exports = n; const s = i(219); const r = i(300); const o = i(49); const a = i(80); const h = i(220); n.stack = function (t, e, i, n, r, o, h) { for (var l, u = s.create({ label: 'Stack' }), c = t, d = e, f = 0, p = 0; p < n; p++) { for (var g = 0, v = 0; v < i; v++) { const y = h(c, d, v, p, l, f); if (y) { const m = y.bounds.max.y - y.bounds.min.y; const x = y.bounds.max.x - y.bounds.min.x; m > g && (g = m), a.translate(y, { x: 0.5 * x, y: 0.5 * m }), c = y.bounds.max.x + r, s.addBody(u, y), l = y, f += 1; } else c += r; }d += g + o, c = t; } return u; }, n.chain = function (t, e, i, n, a, h) {
    for (let l = t.bodies, u = 1; u < l.length; u++) {
      const c = l[u - 1]; const d = l[u]; const f = c.bounds.max.y - c.bounds.min.y; const p = c.bounds.max.x - c.bounds.min.x; const g = d.bounds.max.y - d.bounds.min.y; const v = {
        bodyA: c, pointA: { x: p * e, y: f * i }, bodyB: d, pointB: { x: (d.bounds.max.x - d.bounds.min.x) * n, y: g * a },
      }; const y = o.extend(v, h); s.addConstraint(t, r.create(y));
    } return t.label += ' Chain', t;
  }, n.mesh = function (t, e, i, n, a) { let h; let l; let u; let c; let d; const f = t.bodies; for (h = 0; h < i; h++) { for (l = 1; l < e; l++)u = f[l - 1 + h * e], c = f[l + h * e], s.addConstraint(t, r.create(o.extend({ bodyA: u, bodyB: c }, a))); if (h > 0) for (l = 0; l < e; l++)u = f[l + (h - 1) * e], c = f[l + h * e], s.addConstraint(t, r.create(o.extend({ bodyA: u, bodyB: c }, a))), n && l > 0 && (d = f[l - 1 + (h - 1) * e], s.addConstraint(t, r.create(o.extend({ bodyA: d, bodyB: c }, a)))), n && l < e - 1 && (d = f[l + 1 + (h - 1) * e], s.addConstraint(t, r.create(o.extend({ bodyA: d, bodyB: c }, a)))); } return t.label += ' Mesh', t; }, n.pyramid = function (t, e, i, s, r, o, h) { return n.stack(t, e, i, s, r, o, (e, n, o, l, u, c) => { const d = Math.min(s, Math.ceil(i / 2)); const f = u ? u.bounds.max.x - u.bounds.min.x : 0; if (!(l > d || o < (l = d - l) || o > i - 1 - l)) return c === 1 && a.translate(u, { x: (o + (i % 2 == 1 ? 1 : -1)) * f, y: 0 }), h(t + (u ? o * f : 0) + o * r, n, o, l, u, c); }); }, n.newtonsCradle = function (t, e, i, n, o) {
    for (var a = s.create({ label: 'Newtons Cradle' }), l = 0; l < i; l++) {
      const u = h.circle(t + l * (1.9 * n), e + o, n, {
        inertia: 1 / 0, restitution: 1, friction: 0, frictionAir: 1e-4, slop: 1,
      }); const c = r.create({ pointA: { x: t + l * (1.9 * n), y: e }, bodyB: u }); s.addBody(a, u), s.addConstraint(a, c);
    } return a;
  }, n.car = function (t, e, i, n, o) {
    const l = a.nextGroup(!0); const u = 0.5 * -i + 20; const c = 0.5 * i - 20; const d = s.create({ label: 'Car' }); const f = h.rectangle(t, e, i, n, { collisionFilter: { group: l }, chamfer: { radius: 0.5 * n }, density: 2e-4 }); const p = h.circle(t + u, e + 0, o, { collisionFilter: { group: l }, friction: 0.8 }); const g = h.circle(t + c, e + 0, o, { collisionFilter: { group: l }, friction: 0.8 }); const v = r.create({
      bodyB: f, pointB: { x: u, y: 0 }, bodyA: p, stiffness: 1, length: 0,
    }); const y = r.create({
      bodyB: f, pointB: { x: c, y: 0 }, bodyA: g, stiffness: 1, length: 0,
    }); return s.addBody(d, f), s.addBody(d, p), s.addBody(d, g), s.addConstraint(d, v), s.addConstraint(d, y), d;
  }, n.softBody = function (t, e, i, s, r, a, l, u, c, d) { c = o.extend({ inertia: 1 / 0 }, c), d = o.extend({ stiffness: 0.2, render: { type: 'line', anchors: !1 } }, d); const f = n.stack(t, e, i, s, r, a, (t, e) => h.circle(t, e, u, c)); return n.mesh(f, i, s, l, d), f.label = 'Soft Body', f; };
}, function (t, e) {
  function i(t, e, i) { i = i || 0; let n; let s; let r; let o; let a; let h; let l; const u = [0, 0]; return n = t[1][1] - t[0][1], s = t[0][0] - t[1][0], r = n * t[0][0] + s * t[0][1], o = e[1][1] - e[0][1], a = e[0][0] - e[1][0], h = o * e[0][0] + a * e[0][1], b(l = n * a - o * s, 0, i) || (u[0] = (a * r - s * h) / l, u[1] = (n * h - o * r) / l), u; } function n(t, e, i, n) { const s = e[0] - t[0]; const r = e[1] - t[1]; const o = n[0] - i[0]; const a = n[1] - i[1]; if (o * r - a * s == 0) return !1; const h = (s * (i[1] - t[1]) + r * (t[0] - i[0])) / (o * r - a * s); const l = (o * (t[1] - i[1]) + a * (i[0] - t[0])) / (a * s - o * r); return h >= 0 && h <= 1 && l >= 0 && l <= 1; } function s(t, e, i) { return (e[0] - t[0]) * (i[1] - t[1]) - (i[0] - t[0]) * (e[1] - t[1]); } function r(t, e, i) { return s(t, e, i) > 0; } function o(t, e, i) { return s(t, e, i) >= 0; } function a(t, e, i) { return s(t, e, i) < 0; } function h(t, e, i) { return s(t, e, i) <= 0; }t.exports = {
    decomp(t) { const e = (function t(e) { let i = []; let n = []; let s = []; const r = []; let o = Number.MAX_VALUE; for (let a = 0; a < e.length; ++a) if (g(e, a)) for (let h = 0; h < e.length; ++h) if (m(e, a, h)) { n = t(x(e, a, h, r)), s = t(x(e, h, a, r)); for (let l = 0; l < s.length; l++)n.push(s[l]); n.length < o && (i = n, o = n.length, i.push([f(e, a), f(e, h)])); } return i; }(t)); return e.length > 0 ? (function t(e, i) { if (i.length === 0) return [e]; if (i instanceof Array && i.length && i[0] instanceof Array && i[0].length === 2 && i[0][0] instanceof Array) { for (var n = [e], s = 0; s < i.length; s++) for (var r = i[s], o = 0; o < n.length; o++) { const a = n[o]; const h = t(a, r); if (h) { n.splice(o, 1), n.push(h[0], h[1]); break; } } return n; } var r = i; var s = e.indexOf(r[0]); var o = e.indexOf(r[1]); return s !== -1 && o !== -1 && [x(e, s, o), x(e, o, s)]; }(t, e)) : [t]; }, quickDecomp: function t(e, i, n, s, l, u, c) { u = u || 100; c = c || 0; l = l || 25; i = void 0 !== i ? i : []; n = n || []; s = s || []; let v = [0, 0]; let y = [0, 0]; let m = [0, 0]; let x = 0; let b = 0; let T = 0; let S = 0; let A = 0; let C = 0; let M = 0; const _ = []; const E = []; const P = e; const L = e; if (L.length < 3) return i; c++; if (c > u) return console.warn(`quickDecomp: max level (${u}) reached.`), i; for (let F = 0; F < e.length; ++F) if (g(P, F)) { n.push(P[F]), x = b = Number.MAX_VALUE; for (var k = 0; k < e.length; ++k)r(f(P, F - 1), f(P, F), f(P, k)) && h(f(P, F - 1), f(P, F), f(P, k - 1)) && (m = w(f(P, F - 1), f(P, F), f(P, k), f(P, k - 1)), a(f(P, F + 1), f(P, F), m) && (T = d(P[F], m)) < b && (b = T, y = m, C = k)), r(f(P, F + 1), f(P, F), f(P, k + 1)) && h(f(P, F + 1), f(P, F), f(P, k)) && (m = w(f(P, F + 1), f(P, F), f(P, k), f(P, k + 1)), r(f(P, F - 1), f(P, F), m) && (T = d(P[F], m)) < x && (x = T, v = m, A = k)); if (C === (A + 1) % e.length)m[0] = (y[0] + v[0]) / 2, m[1] = (y[1] + v[1]) / 2, s.push(m), F < A ? (p(_, P, F, A + 1), _.push(m), E.push(m), C !== 0 && p(E, P, C, P.length), p(E, P, 0, F + 1)) : (F !== 0 && p(_, P, F, P.length), p(_, P, 0, A + 1), _.push(m), E.push(m), p(E, P, C, F + 1)); else { if (C > A && (A += e.length), S = Number.MAX_VALUE, A < C) return i; for (var k = C; k <= A; ++k)o(f(P, F - 1), f(P, F), f(P, k)) && h(f(P, F + 1), f(P, F), f(P, k)) && (T = d(f(P, F), f(P, k))) < S && (S = T, M = k % e.length); F < M ? (p(_, P, F, M + 1), M !== 0 && p(E, P, M, L.length), p(E, P, 0, F + 1)) : (F !== 0 && p(_, P, F, L.length), p(_, P, 0, M + 1), p(E, P, M, F + 1)); } return _.length < E.length ? (t(_, i, n, s, l, u, c), t(E, i, n, s, l, u, c)) : (t(E, i, n, s, l, u, c), t(_, i, n, s, l, u, c)), i; }i.push(e); return i; }, isSimple(t) { let e; const i = t; for (e = 0; e < i.length - 1; e++) for (let s = 0; s < e - 1; s++) if (n(i[e], i[e + 1], i[s], i[s + 1])) return !1; for (e = 1; e < i.length - 2; e++) if (n(i[0], i[i.length - 1], i[e], i[e + 1])) return !1; return !0; }, removeCollinearPoints(t, e) { for (var i = 0, n = t.length - 1; t.length > 3 && n >= 0; --n)c(f(t, n - 1), f(t, n), f(t, n + 1), e) && (t.splice(n % t.length, 1), i++); return i; }, makeCCW(t) { for (var e = 0, i = t, n = 1; n < t.length; ++n)(i[n][1] < i[e][1] || i[n][1] === i[e][1] && i[n][0] > i[e][0]) && (e = n); r(f(t, e - 1), f(t, e), f(t, e + 1)) || (function (t) { for (var e = [], i = t.length, n = 0; n !== i; n++)e.push(t.pop()); for (var n = 0; n !== i; n++)t[n] = e[n]; }(t)); },
  }; const l = []; const u = []; function c(t, e, i, n) { if (n) { const r = l; const o = u; r[0] = e[0] - t[0], r[1] = e[1] - t[1], o[0] = i[0] - e[0], o[1] = i[1] - e[1]; const a = r[0] * o[0] + r[1] * o[1]; const h = Math.sqrt(r[0] * r[0] + r[1] * r[1]); const c = Math.sqrt(o[0] * o[0] + o[1] * o[1]); return Math.acos(a / (h * c)) < n; } return s(t, e, i) === 0; } function d(t, e) { const i = e[0] - t[0]; const n = e[1] - t[1]; return i * i + n * n; } function f(t, e) { const i = t.length; return t[e < 0 ? e % i + i : e % i]; } function p(t, e, i, n) { for (let s = i; s < n; s++)t.push(e[s]); } function g(t, e) { return a(f(t, e - 1), f(t, e), f(t, e + 1)); } const v = []; const y = []; function m(t, e, n) { let s; let r; const a = v; const l = y; if (o(f(t, e + 1), f(t, e), f(t, n)) && h(f(t, e - 1), f(t, e), f(t, n))) return !1; r = d(f(t, e), f(t, n)); for (let u = 0; u !== t.length; ++u) if ((u + 1) % t.length !== e && u !== e && o(f(t, e), f(t, n), f(t, u + 1)) && h(f(t, e), f(t, n), f(t, u)) && (a[0] = f(t, e), a[1] = f(t, n), l[0] = f(t, u), l[1] = f(t, u + 1), s = i(a, l), d(f(t, e), s) < r)) return !1; return !0; } function x(t, e, i, n) { const s = n || []; if ((function (t) { t.length = 0; }(s)), e < i) for (var r = e; r <= i; r++)s.push(t[r]); else { for (r = 0; r <= i; r++)s.push(t[r]); for (r = e; r < t.length; r++)s.push(t[r]); } return s; } function w(t, e, i, n, s) { s = s || 0; const r = e[1] - t[1]; const o = t[0] - e[0]; const a = r * t[0] + o * t[1]; const h = n[1] - i[1]; const l = i[0] - n[0]; const u = h * i[0] + l * i[1]; const c = r * l - h * o; return b(c, 0, s) ? [0, 0] : [(l * a - o * u) / c, (r * u - h * a) / c]; } function b(t, e, i) { return i = i || 0, Math.abs(t - e) < i; }
}, function (t, e, i) {
  const n = i(220); const s = i(0); const r = i(1012); const o = i(300); const a = i(1043); const h = i(1011); const l = i(1010); const u = i(674); const c = i(1030); const d = new s({
    initialize(t) { this.world = t, this.scene = t.scene, this.sys = t.scene.sys; }, rectangle(t, e, i, s, r) { const o = n.rectangle(t, e, i, s, r); return this.world.add(o), o; }, trapezoid(t, e, i, s, r, o) { const a = n.trapezoid(t, e, i, s, r, o); return this.world.add(a), a; }, circle(t, e, i, s, r) { const o = n.circle(t, e, i, s, r); return this.world.add(o), o; }, polygon(t, e, i, s, r) { const o = n.polygon(t, e, i, s, r); return this.world.add(o), o; }, fromVertices(t, e, i, s, r, o, a) { const h = n.fromVertices(t, e, i, s, r, o, a); return this.world.add(h), h; }, imageStack(t, e, i, n, s, o, a, l, u) { void 0 === a && (a = 0), void 0 === l && (l = 0), void 0 === u && (u = {}); const c = this.world; const d = this.sys.displayList; u.addToWorld = !1; const f = r.stack(i, n, s, o, a, l, (i, n) => { const s = new h(c, i, n, t, e, u); return d.add(s), s.body; }); return c.add(f), f; }, stack(t, e, i, n, s, o, a) { const h = r.stack(t, e, i, n, s, o, a); return this.world.add(h), h; }, pyramid(t, e, i, n, s, o, a) { const h = r.pyramid(t, e, i, n, s, o, a); return this.world.add(h), h; }, chain(t, e, i, n, s, o) { return r.chain(t, e, i, n, s, o); }, mesh(t, e, i, n, s) { return r.mesh(t, e, i, n, s); }, newtonsCradle(t, e, i, n, s) { const o = r.newtonsCradle(t, e, i, n, s); return this.world.add(o), o; }, car(t, e, i, n, s) { const o = r.car(t, e, i, n, s); return this.world.add(o), o; }, softBody(t, e, i, n, s, o, a, h, l, u) { const c = r.softBody(t, e, i, n, s, o, a, h, l, u); return this.world.add(c), c; }, joint(t, e, i, n, s) { return this.constraint(t, e, i, n, s); }, spring(t, e, i, n, s) { return this.constraint(t, e, i, n, s); }, constraint(t, e, i, n, s) { void 0 === n && (n = 1), void 0 === s && (s = {}), s.bodyA = t.type === 'body' ? t : t.body, s.bodyB = e.type === 'body' ? e : e.body, s.length = i, s.stiffness = n; const r = o.create(s); return this.world.add(r), r; }, worldConstraint(t, e, i, n) { void 0 === i && (i = 1), void 0 === n && (n = {}), n.bodyB = t.type === 'body' ? t : t.body, n.length = e, n.stiffness = i; const s = o.create(n); return this.world.add(s), s; }, mouseSpring(t) { return this.pointerConstraint(t); }, pointerConstraint(t) { void 0 === t && (t = {}), t.hasOwnProperty('render') || (t.render = { visible: !1 }); const e = new c(this.scene, this.world, t); return this.world.add(e.constraint), e; }, image(t, e, i, n, s) { const r = new h(this.world, t, e, i, n, s); return this.sys.displayList.add(r), r; }, tileBody(t, e) { return new u(this.world, t, e); }, sprite(t, e, i, n, s) { const r = new l(this.world, t, e, i, n, s); return this.sys.displayList.add(r), this.sys.updateList.add(r), r; }, gameObject(t, e) { return a(this.world, t, e); }, destroy() { this.world = null, this.scene = null, this.sys = null; },
  }); t.exports = d;
}, function (t, e, i) {
  const n = i(1021); const s = i(0); const r = i(333); const o = i(1020); const a = i(9); const h = i(1); const l = i(108); const u = i(70); const c = i(1047); const d = i(26); const f = i(332); const p = new s({
    Extends: a,
    initialize(t, e) {
      a.call(this), this.scene = t, this.bodies = new u(), this.gravity = h(e, 'gravity', 0), this.cellSize = h(e, 'cellSize', 64), this.collisionMap = new o(), this.timeScale = h(e, 'timeScale', 1), this.maxStep = h(e, 'maxStep', 0.05), this.enabled = !0, this.drawDebug = h(e, 'debug', !1), this.debugGraphic; const i = h(e, 'maxVelocity', 100); if (this.defaults = {
        debugShowBody: h(e, 'debugShowBody', !0), debugShowVelocity: h(e, 'debugShowVelocity', !0), bodyDebugColor: h(e, 'debugBodyColor', 16711935), velocityDebugColor: h(e, 'debugVelocityColor', 65280), maxVelocityX: h(e, 'maxVelocityX', i), maxVelocityY: h(e, 'maxVelocityY', i), minBounceVelocity: h(e, 'minBounceVelocity', 40), gravityFactor: h(e, 'gravityFactor', 1), bounciness: h(e, 'bounciness', 0),
      }, this.walls = {
        left: null, right: null, top: null, bottom: null,
      }, this.delta = 0, this._lastId = 0, h(e, 'setBounds', !1)) { const n = e.setBounds; if (typeof n === 'boolean') this.setBounds(); else { const s = h(n, 'x', 0); const r = h(n, 'y', 0); const l = h(n, 'width', t.sys.game.config.width); const c = h(n, 'height', t.sys.game.config.height); const d = h(n, 'thickness', 64); const f = h(n, 'left', !0); const p = h(n, 'right', !0); const g = h(n, 'top', !0); const v = h(n, 'bottom', !0); this.setBounds(s, r, l, c, d, f, p, g, v); } } this.drawDebug && this.createDebugGraphic();
    },
    setCollisionMap(t, e) { if (typeof t === 'string') { const i = this.scene.cache.tilemap.get(t); if (!i || i.format !== d.WELTMEISTER) return console.warn(`The specified key does not correspond to a Weltmeister tilemap: ${t}`), null; for (var n, s = i.data.layer, r = 0; r < s.length; r++) if (s[r].name === 'collision') { n = s[r]; break; } void 0 === e && (e = n.tilesize), this.collisionMap = new o(e, n.data); } else Array.isArray(t) ? this.collisionMap = new o(e, t) : console.warn(`Invalid Weltmeister collision map data: ${t}`); return this.collisionMap; },
    setCollisionMapFromTilemapLayer(t, e) { void 0 === e && (e = {}); for (var i = h(e, 'slopeProperty', null), n = h(e, 'slopeMap', null), s = h(e, 'defaultCollidingSlope', null), r = h(e, 'defaultNonCollidingSlope', 0), a = t.layer, u = a.baseTileWidth, c = [], d = 0; d < a.height; d++) { c[d] = []; for (let f = 0; f < a.width; f++) { const p = a.data[d][f]; p && p.collides ? i !== null && l(p.properties, i) ? c[d][f] = parseInt(p.properties[i], 10) : n !== null && l(n, p.index) ? c[d][f] = n[p.index] : c[d][f] = s !== null ? s : p.index : c[d][f] = r; } } return this.collisionMap = new o(u, c), this.collisionMap; },
    setBounds(t, e, i, n, s, r, o, a, h) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.scene.sys.game.config.width), void 0 === n && (n = this.scene.sys.game.config.height), void 0 === s && (s = 64), void 0 === r && (r = !0), void 0 === o && (o = !0), void 0 === a && (a = !0), void 0 === h && (h = !0), this.updateWall(r, 'left', t - s, e, s, n), this.updateWall(o, 'right', t + i, e, s, n), this.updateWall(a, 'top', t, e - s, i, s), this.updateWall(h, 'bottom', t, e + n, i, s), this; },
    updateWall(t, e, i, n, s, o) { const a = this.walls[e]; t ? a ? a.resetSize(i, n, s, o) : (this.walls[e] = this.create(i, n, s, o), this.walls[e].name = e, this.walls[e].gravityFactor = 0, this.walls[e].collides = r.FIXED) : (a && this.bodies.remove(a), this.walls[e] = null); },
    createDebugGraphic() { const t = this.scene.sys.add.graphics({ x: 0, y: 0 }); return t.setDepth(Number.MAX_VALUE), this.debugGraphic = t, this.drawDebug = !0, t; },
    getNextID() { return this._lastId++; },
    create(t, e, i, s) { const r = new n(this, t, e, i, s); return this.bodies.set(r), r; },
    remove(t) { this.bodies.delete(t); },
    pause() { return this.enabled = !1, this.emit('pause'), this; },
    resume() { return this.enabled = !0, this.emit('resume'), this; },
    update(t, e) { if (this.enabled && this.bodies.size !== 0) { let i; let n; const s = Math.min(e / 1e3, this.maxStep) * this.timeScale; this.delta = s; const r = this.bodies.entries; const o = r.length; const a = {}; const h = this.cellSize; for (i = 0; i < o; i++)(n = r[i]).enabled && n.update(s); for (i = 0; i < o; i++)(n = r[i]) && !n.skipHash() && this.checkHash(n, a, h); if (this.drawDebug) { const l = this.debugGraphic; for (l.clear(), i = 0; i < o; i++)(n = r[i]) && n.willDrawDebug() && n.drawDebug(l); } } },
    checkHash(t, e, i) { for (let n = {}, s = Math.floor(t.pos.x / i), r = Math.floor(t.pos.y / i), o = Math.floor((t.pos.x + t.size.x) / i) + 1, a = Math.floor((t.pos.y + t.size.y) / i) + 1, h = s; h < o; h++) for (let l = r; l < a; l++) if (e[h]) if (e[h][l]) { for (var u = e[h][l], c = 0; c < u.length; c++)t.touches(u[c]) && !n[u[c].id] && (n[u[c].id] = !0, this.checkBodies(t, u[c])); u.push(t); } else e[h][l] = [t]; else e[h] = {}, e[h][l] = [t]; },
    checkBodies(t, e) { t.collides === r.FIXED && e.collides === r.FIXED || (t.checkAgainst & e.type && t.check(e), e.checkAgainst & t.type && e.check(t), t.collides && e.collides && t.collides + e.collides > r.ACTIVE && c(this, t, e)); },
    setCollidesNever(t) { for (let e = 0; e < t.length; e++)t[e].collides = r.NEVER; return this; },
    setLite(t) { for (let e = 0; e < t.length; e++)t[e].collides = r.LITE; return this; },
    setPassive(t) { for (let e = 0; e < t.length; e++)t[e].collides = r.PASSIVE; return this; },
    setActive(t) { for (let e = 0; e < t.length; e++)t[e].collides = r.ACTIVE; return this; },
    setFixed(t) { for (let e = 0; e < t.length; e++)t[e].collides = r.FIXED; return this; },
    setTypeNone(t) { for (let e = 0; e < t.length; e++)t[e].type = f.NONE; return this; },
    setTypeA(t) { for (let e = 0; e < t.length; e++)t[e].type = f.A; return this; },
    setTypeB(t) { for (let e = 0; e < t.length; e++)t[e].type = f.B; return this; },
    setAvsB(t) { for (let e = 0; e < t.length; e++)t[e].type = f.A, t[e].checkAgainst = f.B; return this; },
    setBvsA(t) { for (let e = 0; e < t.length; e++)t[e].type = f.B, t[e].checkAgainst = f.A; return this; },
    setCheckAgainstNone(t) { for (let e = 0; e < t.length; e++)t[e].checkAgainst = f.NONE; return this; },
    setCheckAgainstA(t) { for (let e = 0; e < t.length; e++)t[e].checkAgainst = f.A; return this; },
    setCheckAgainstB(t) { for (let e = 0; e < t.length; e++)t[e].checkAgainst = f.B; return this; },
    shutdown() { this.removeAllListeners(); },
    destroy() { this.removeAllListeners(), this.scene = null, this.bodies.clear(), this.bodies = null, this.collisionMap = null; },
  }); t.exports = p;
}, function (t, e, i) { const n = i(0); const s = i(676); const r = i(34); const o = new n({ Extends: r, Mixins: [s.Acceleration, s.BodyScale, s.BodyType, s.Bounce, s.CheckAgainst, s.Collides, s.Debug, s.Friction, s.Gravity, s.Offset, s.SetGameObject, s.Velocity], initialize(t, e, i, n, s) { r.call(this, t.scene, e, i, n, s), this.body = t.create(e - this.frame.centerX, i - this.frame.centerY, this.width, this.height), this.body.parent = this, this.body.gameObject = this, this.size = this.body.size, this.offset = this.body.offset, this.vel = this.body.vel, this.accel = this.body.accel, this.friction = this.body.friction, this.maxVel = this.body.maxVel; } }); t.exports = o; }, function (t, e, i) { const n = i(0); const s = i(676); const r = i(69); const o = new n({ Extends: r, Mixins: [s.Acceleration, s.BodyScale, s.BodyType, s.Bounce, s.CheckAgainst, s.Collides, s.Debug, s.Friction, s.Gravity, s.Offset, s.SetGameObject, s.Velocity], initialize(t, e, i, n, s) { r.call(this, t.scene, e, i, n, s), this.body = t.create(e - this.frame.centerX, i - this.frame.centerY, this.width, this.height), this.body.parent = this, this.body.gameObject = this, this.size = this.body.size, this.offset = this.body.offset, this.vel = this.body.vel, this.accel = this.body.accel, this.friction = this.body.friction, this.maxVel = this.body.maxVel; } }); t.exports = o; }, function (t, e, i) { const n = i(0); const s = i(676); const r = new n({ Mixins: [s.Acceleration, s.BodyScale, s.BodyType, s.Bounce, s.CheckAgainst, s.Collides, s.Debug, s.Friction, s.Gravity, s.Offset, s.SetGameObject, s.Velocity], initialize(t, e, i, n, s) { this.body = t.create(e, i, n, s), this.body.parent = this, this.size = this.body.size, this.offset = this.body.offset, this.vel = this.body.vel, this.accel = this.body.accel, this.friction = this.body.friction, this.maxVel = this.body.maxVel; } }); t.exports = r; }, function (t, e, i) {
  const n = i(0); const s = i(1018); const r = i(1017); const o = i(1016); const a = new n({
    initialize(t) { this.world = t, this.sys = t.scene.sys; }, body(t, e, i, n) { return new s(this.world, t, e, i, n); }, existing(t) { const e = t.x - t.frame.centerX; const i = t.y - t.frame.centerY; const n = t.width; const s = t.height; return t.body = this.world.create(e, i, n, s), t.body.parent = t, t.body.gameObject = t, t; }, image(t, e, i, n) { const s = new r(this.world, t, e, i, n); return this.sys.displayList.add(s), s; }, sprite(t, e, i, n) { const s = new o(this.world, t, e, i, n); return this.sys.displayList.add(s), this.sys.updateList.add(s), s; }, destroy() { this.world = null, this.sys = null; },
  }); t.exports = a;
}, function (t, e, i) {
  const n = i(0); const s = i(1061); const r = new n({
    initialize(t, e) { void 0 === t && (t = 32), this.tilesize = t, this.data = Array.isArray(e) ? e : [], this.width = Array.isArray(e) ? e[0].length : 0, this.height = Array.isArray(e) ? e.length : 0, this.lastSlope = 55, this.tiledef = s; },
    trace(t, e, i, n, s, r) { const o = { collision: { x: !1, y: !1, slope: !1 }, pos: { x: t + i, y: e + n }, tile: { x: 0, y: 0 } }; if (!this.data) return o; const a = Math.ceil(Math.max(Math.abs(i), Math.abs(n)) / this.tilesize); if (a > 1) for (let h = i / a, l = n / a, u = 0; u < a && (h || l) && (this.step(o, t, e, h, l, s, r, i, n, u), t = o.pos.x, e = o.pos.y, o.collision.x && (h = 0, i = 0), o.collision.y && (l = 0, n = 0), !o.collision.slope); u++);else this.step(o, t, e, i, n, s, r, i, n, 0); return o; },
    step(t, e, i, n, s, r, o, a, h, l) { let u; let c; let d = 0; const f = this.tilesize; const p = this.width; const g = this.height; if (n) { const v = n > 0 ? r : 0; const y = n < 0 ? f : 0; const m = Math.max(Math.floor(i / f), 0); const x = Math.min(Math.ceil((i + o) / f), g); u = Math.floor((t.pos.x + v) / f); let w = Math.floor((e + v) / f); if ((l > 0 || u === w || w < 0 || w >= p) && (w = -1), u >= 0 && u < p) for (c = m; c < x && !(w !== -1 && (d = this.data[c][w]) > 1 && d <= this.lastSlope && this.checkDef(t, d, e, i, a, h, r, o, w, c)); c++) if ((d = this.data[c][u]) === 1 || d > this.lastSlope || d > 1 && this.checkDef(t, d, e, i, a, h, r, o, u, c)) { if (d > 1 && d <= this.lastSlope && t.collision.slope) break; t.collision.x = !0, t.tile.x = d, t.pos.x = u * f - v + y, e = t.pos.x, a = 0; break; } } if (s) { const b = s > 0 ? o : 0; const T = s < 0 ? f : 0; const S = Math.max(Math.floor(t.pos.x / f), 0); const A = Math.min(Math.ceil((t.pos.x + r) / f), p); c = Math.floor((t.pos.y + b) / f); let C = Math.floor((i + b) / f); if ((l > 0 || c === C || C < 0 || C >= g) && (C = -1), c >= 0 && c < g) for (u = S; u < A && !(C !== -1 && (d = this.data[C][u]) > 1 && d <= this.lastSlope && this.checkDef(t, d, e, i, a, h, r, o, u, C)); u++) if ((d = this.data[c][u]) === 1 || d > this.lastSlope || d > 1 && this.checkDef(t, d, e, i, a, h, r, o, u, c)) { if (d > 1 && d <= this.lastSlope && t.collision.slope) break; t.collision.y = !0, t.tile.y = d, t.pos.y = c * f - b + T; break; } } },
    checkDef(t, e, i, n, s, r, o, a, h, l) {
      const u = this.tiledef[e]; if (!u) return !1; const c = this.tilesize; const d = (h + u[0]) * c; const f = (l + u[1]) * c; const p = (u[2] - u[0]) * c; const g = (u[3] - u[1]) * c; const v = u[4]; const y = i + s + (g < 0 ? o : 0) - d; const m = n + r + (p > 0 ? a : 0) - f; if (p * m - g * y > 0) {
        if (s * -g + r * p < 0) return v; const x = Math.sqrt(p * p + g * g); const w = g / x; const b = -p / x; const T = y * w + m * b; const S = w * T; const A = b * T; return S * S + A * A >= s * s + r * r ? v || p * (m - r) - g * (y - s) < 0.5 : (t.pos.x = i + s - S, t.pos.y = n + r - A, t.collision.slope = {
          x: p, y: g, nx: w, ny: b,
        }, !0);
      } return !1;
    },
  }); t.exports = r;
}, function (t, e, i) {
  const n = i(0); const s = i(333); const r = i(1063); const o = i(332); const a = i(1062); const h = new n({
    initialize(t, e, i, n, r) { void 0 === n && (n = 16), void 0 === r && (r = n), this.world = t, this.gameObject = null, this.enabled = !0, this.parent, this.id = t.getNextID(), this.name = '', this.size = { x: n, y: r }, this.offset = { x: 0, y: 0 }, this.pos = { x: e, y: i }, this.last = { x: e, y: i }, this.vel = { x: 0, y: 0 }, this.accel = { x: 0, y: 0 }, this.friction = { x: 0, y: 0 }, this.maxVel = { x: t.defaults.maxVelocityX, y: t.defaults.maxVelocityY }, this.standing = !1, this.gravityFactor = t.defaults.gravityFactor, this.bounciness = t.defaults.bounciness, this.minBounceVelocity = t.defaults.minBounceVelocity, this.accelGround = 0, this.accelAir = 0, this.jumpSpeed = 0, this.type = o.NONE, this.checkAgainst = o.NONE, this.collides = s.NEVER, this.debugShowBody = t.defaults.debugShowBody, this.debugShowVelocity = t.defaults.debugShowVelocity, this.debugBodyColor = t.defaults.bodyDebugColor, this.updateCallback, this.slopeStanding = { min: 0.767944870877505, max: 2.3736477827122884 }; },
    reset(t, e) { this.pos = { x: t, y: e }, this.last = { x: t, y: e }, this.vel = { x: 0, y: 0 }, this.accel = { x: 0, y: 0 }, this.friction = { x: 0, y: 0 }, this.maxVel = { x: 100, y: 100 }, this.standing = !1, this.gravityFactor = 1, this.bounciness = 0, this.minBounceVelocity = 40, this.accelGround = 0, this.accelAir = 0, this.jumpSpeed = 0, this.type = o.NONE, this.checkAgainst = o.NONE, this.collides = s.NEVER; },
    update(t) { const e = this.pos; this.last.x = e.x, this.last.y = e.y, this.vel.y += this.world.gravity * t * this.gravityFactor, this.vel.x = r(t, this.vel.x, this.accel.x, this.friction.x, this.maxVel.x), this.vel.y = r(t, this.vel.y, this.accel.y, this.friction.y, this.maxVel.y); const i = this.vel.x * t; const n = this.vel.y * t; const s = this.world.collisionMap.trace(e.x, e.y, i, n, this.size.x, this.size.y); this.handleMovementTrace(s) && a(this, s); const o = this.gameObject; o && (o.x = e.x - this.offset.x + o.displayOriginX * o.scaleX, o.y = e.y - this.offset.y + o.displayOriginY * o.scaleY), this.updateCallback && this.updateCallback(this); },
    drawDebug(t) { const e = this.pos; if (this.debugShowBody && (t.lineStyle(1, this.debugBodyColor, 1), t.strokeRect(e.x, e.y, this.size.x, this.size.y)), this.debugShowVelocity) { const i = e.x + this.size.x / 2; const n = e.y + this.size.y / 2; t.lineStyle(1, this.world.defaults.velocityDebugColor, 1), t.lineBetween(i, n, i + this.vel.x, n + this.vel.y); } },
    willDrawDebug() { return this.debugShowBody || this.debugShowVelocity; },
    skipHash() { return !this.enabled || this.type === 0 && this.checkAgainst === 0 && this.collides === 0; },
    touches(t) { return !(this.pos.x >= t.pos.x + t.size.x || this.pos.x + this.size.x <= t.pos.x || this.pos.y >= t.pos.y + t.size.y || this.pos.y + this.size.y <= t.pos.y); },
    resetSize(t, e, i, n) { return this.pos.x = t, this.pos.y = e, this.size.x = i, this.size.y = n, this; },
    toJSON() {
      return {
        name: this.name, size: { x: this.size.x, y: this.size.y }, pos: { x: this.pos.x, y: this.pos.y }, vel: { x: this.vel.x, y: this.vel.y }, accel: { x: this.accel.x, y: this.accel.y }, friction: { x: this.friction.x, y: this.friction.y }, maxVel: { x: this.maxVel.x, y: this.maxVel.y }, gravityFactor: this.gravityFactor, bounciness: this.bounciness, minBounceVelocity: this.minBounceVelocity, type: this.type, checkAgainst: this.checkAgainst, collides: this.collides,
      };
    },
    fromJSON() {},
    check() {},
    collideWith(t, e) { this.parent && this.parent._collideCallback && this.parent._collideCallback.call(this.parent._callbackScope, this, t, e); },
    handleMovementTrace() { return !0; },
    destroy() { this.world.remove(this), this.enabled = !1, this.world = null, this.gameObject = null, this.parent = null; },
  }); t.exports = h;
},,, function (t, e, i) {
    const n = i(671); var s = {
      name: 'matter-wrap', version: '0.1.4', for: 'matter-js@^0.13.1', silent: !0, install(t) { t.after('Engine.update', function () { s.Engine.update(this); }); }, Engine: { update(t) { for (var e = t.world, i = n.Composite.allBodies(e), r = n.Composite.allComposites(e), o = 0; o < i.length; o += 1) { const a = i[o]; a.plugin.wrap && s.Body.wrap(a, a.plugin.wrap); } for (o = 0; o < r.length; o += 1) { const h = r[o]; h.plugin.wrap && s.Composite.wrap(h, h.plugin.wrap); } } }, Bounds: { wrap(t, e) { let i = null; let n = null; if (void 0 !== e.min.x && void 0 !== e.max.x && (t.min.x > e.max.x ? i = e.min.x - t.max.x : t.max.x < e.min.x && (i = e.max.x - t.min.x)), void 0 !== e.min.y && void 0 !== e.max.y && (t.min.y > e.max.y ? n = e.min.y - t.max.y : t.max.y < e.min.y && (n = e.max.y - t.min.y)), i !== null || n !== null) return { x: i || 0, y: n || 0 }; } }, Body: { wrap(t, e) { const i = s.Bounds.wrap(t.bounds, e); return i && n.Body.translate(t, i), i; } }, Composite: { bounds(t) { for (var e = n.Composite.allBodies(t), i = [], s = 0; s < e.length; s += 1) { const r = e[s]; i.push(r.bounds.min, r.bounds.max); } return n.Bounds.create(i); }, wrap(t, e) { const i = s.Bounds.wrap(s.Composite.bounds(t), e); return i && n.Composite.translate(t, i), i; } },
    }; t.exports = s;
  }, function (t, e, i) {
    const n = i(671); var s = {
      name: 'matter-attractors', version: '0.1.7', for: 'matter-js@^0.13.1', silent: !0, install(t) { t.after('Body.create', function () { s.Body.init(this); }), t.before('Engine.update', (t) => { s.Engine.update(t); }); }, Body: { init(t) { t.plugin.attractors = t.plugin.attractors || []; } }, Engine: { update(t) { for (let e = t.world, i = n.Composite.allBodies(e), s = 0; s < i.length; s += 1) { const r = i[s]; const o = r.plugin.attractors; if (o && o.length > 0) for (let a = s + 1; a < i.length; a += 1) for (let h = i[a], l = 0; l < o.length; l += 1) { const u = o[l]; let c = u; n.Common.isFunction(u) && (c = u(r, h)), c && n.Body.applyForce(h, h.position, c); } } } }, Attractors: { gravityConstant: 0.001, gravity(t, e) { const i = n.Vector.sub(e.position, t.position); const r = n.Vector.magnitudeSquared(i) || 1e-4; const o = n.Vector.normalise(i); const a = -s.Attractors.gravityConstant * (t.mass * e.mass / r); const h = n.Vector.mult(o, a); n.Body.applyForce(t, t.position, n.Vector.neg(h)), n.Body.applyForce(e, e.position, h); } },
    }; t.exports = s;
  }, function (t, e, i) {
    const n = i(0); const s = i(1014); const r = i(1); const o = i(4); const a = i(1025); const h = i(1009); const l = i(1024); const u = i(93); const c = i(670); const d = i(12); const f = i(1004); const p = new n({
      initialize(t) { this.scene = t, this.systems = t.sys, this.config = this.getConfig(), this.world, this.add, o(this.config, 'plugins.attractors', !1) && (c.register(a), c.use(h, a)), o(this.config, 'plugins.wrap', !1) && (c.register(l), c.use(h, l)), t.sys.events.once('boot', this.boot, this), t.sys.events.on('start', this.start, this); }, boot() { this.world = new f(this.scene, this.config), this.add = new s(this.world), this.systems.events.once('destroy', this.destroy, this); }, start() { this.world || (this.world = new f(this.scene, this.config), this.add = new s(this.world)); const t = this.systems.events; t.on('update', this.world.update, this.world), t.on('postupdate', this.world.postUpdate, this.world), t.once('shutdown', this.shutdown, this); }, getConfig() { const t = this.systems.game.config.physics; const e = this.systems.settings.physics; return u(r(e, 'matter', {}), r(t, 'matter', {})); }, enableAttractorPlugin() { return c.register(a), c.use(h, a), this; }, enableWrapPlugin() { return c.register(l), c.use(h, l), this; }, pause() { return this.world.pause(); }, resume() { return this.world.resume(); }, set60Hz() { return this.world.getDelta = this.world.update60Hz, this.world.autoUpdate = !0, this; }, set30Hz() { return this.world.getDelta = this.world.update30Hz, this.world.autoUpdate = !0, this; }, step(t, e) { this.world.step(t, e); }, shutdown() { const t = this.systems.events; t.off('update', this.world.update, this.world), t.off('postupdate', this.world.postUpdate, this.world), t.off('shutdown', this.shutdown, this), this.add.destroy(), this.world.destroy(), this.add = null, this.world = null; }, destroy() { this.shutdown(), this.scene.sys.events.off('start', this.start, this), this.scene = null, this.systems = null; },
    }); d.register('MatterPhysics', p, 'matterPhysics'), t.exports = p;
  }, function (t, e, i) { const n = {}; t.exports = n; i(139); !(function () { n.pathToVertices = function (e, i) { let n; let s; let r; let o; let a; let h; let l; let u; let c; let d; let f; const p = []; let g = 0; let v = 0; let y = 0; i = i || 15; const m = function (t, e, i) { const n = i % 2 == 1 && i > 1; if (!c || t != c.x || e != c.y) { c && n ? (d = c.x, f = c.y) : (d = 0, f = 0); const s = { x: d + t, y: f + e }; !n && c || (c = s), p.push(s), v = d + t, y = f + e; } }; const x = function (t) { const e = t.pathSegTypeAsLetter.toUpperCase(); if (e !== 'Z') { switch (e) { case 'M': case 'L': case 'T': case 'C': case 'S': case 'Q': v = t.x, y = t.y; break; case 'H': v = t.x; break; case 'V': y = t.y; }m(v, y, t.pathSegType); } }; for (t(e), r = e.getTotalLength(), h = [], n = 0; n < e.pathSegList.numberOfItems; n += 1)h.push(e.pathSegList.getItem(n)); for (l = h.concat(); g < r;) { if ((a = h[e.getPathSegAtLength(g)]) != u) { for (;l.length && l[0] != a;)x(l.shift()); u = a; } switch (a.pathSegTypeAsLetter.toUpperCase()) { case 'C': case 'T': case 'S': case 'Q': case 'A': o = e.getPointAtLength(g), m(o.x, o.y, 0); }g += i; } for (n = 0, s = l.length; n < s; ++n)x(l[n]); return p; }; var t = function (t) { for (var e, i, n, s, r, o, a = t.pathSegList, h = 0, l = 0, u = a.numberOfItems, c = 0; c < u; ++c) { const d = a.getItem(c); const f = d.pathSegTypeAsLetter; if (/[MLHVCSQTA]/.test(f))'x' in d && (h = d.x), 'y' in d && (l = d.y); else switch ('x1' in d && (n = h + d.x1), 'x2' in d && (r = h + d.x2), 'y1' in d && (s = l + d.y1), 'y2' in d && (o = l + d.y2), 'x' in d && (h += d.x), 'y' in d && (l += d.y), f) { case 'm': a.replaceItem(t.createSVGPathSegMovetoAbs(h, l), c); break; case 'l': a.replaceItem(t.createSVGPathSegLinetoAbs(h, l), c); break; case 'h': a.replaceItem(t.createSVGPathSegLinetoHorizontalAbs(h), c); break; case 'v': a.replaceItem(t.createSVGPathSegLinetoVerticalAbs(l), c); break; case 'c': a.replaceItem(t.createSVGPathSegCurvetoCubicAbs(h, l, n, s, r, o), c); break; case 's': a.replaceItem(t.createSVGPathSegCurvetoCubicSmoothAbs(h, l, r, o), c); break; case 'q': a.replaceItem(t.createSVGPathSegCurvetoQuadraticAbs(h, l, n, s), c); break; case 't': a.replaceItem(t.createSVGPathSegCurvetoQuadraticSmoothAbs(h, l), c); break; case 'a': a.replaceItem(t.createSVGPathSegArcAbs(h, l, d.r1, d.r2, d.angle, d.largeArcFlag, d.sweepFlag), c); break; case 'z': case 'Z': h = e, l = i; }f != 'M' && f != 'm' || (e = h, i = l); } }; }()); }, function (t, e, i) {
    const n = {}; t.exports = n; const s = i(219); const r = i(49); n.create = function (t) {
      return r.extend({
        extended: !1, narrowDetections: 0, narrowphaseTests: 0, narrowReuse: 0, narrowReuseCount: 0, midphaseTests: 0, broadphaseTests: 0, narrowEff: 1e-4, midEff: 1e-4, broadEff: 1e-4, collisions: 0, buckets: 0, bodies: 0, pairs: 0,
      }, !1, t);
    }, n.reset = function (t) { t.extended && (t.narrowDetections = 0, t.narrowphaseTests = 0, t.narrowReuse = 0, t.narrowReuseCount = 0, t.midphaseTests = 0, t.broadphaseTests = 0, t.narrowEff = 0, t.midEff = 0, t.broadEff = 0, t.collisions = 0, t.buckets = 0, t.pairs = 0, t.bodies = 0); }, n.update = function (t, e) { if (t.extended) { const i = e.world; const n = s.allBodies(i); t.collisions = t.narrowDetections, t.pairs = e.pairs.list.length, t.bodies = n.length, t.midEff = (t.narrowDetections / (t.midphaseTests || 1)).toFixed(2), t.narrowEff = (t.narrowDetections / (t.narrowphaseTests || 1)).toFixed(2), t.broadEff = (1 - t.broadphaseTests / (n.length || 1)).toFixed(2), t.narrowReuse = (t.narrowReuseCount / (t.narrowphaseTests || 1)).toFixed(2); } };
  }, function (t, e, i) { const n = {}; t.exports = n; const s = i(123); const r = i(672); const o = i(139); const a = i(220); const h = i(140); n.ray = function (t, e, i, n) { n = n || 1e-100; for (var h = s.angle(e, i), l = s.magnitude(s.sub(e, i)), u = 0.5 * (i.x + e.x), c = 0.5 * (i.y + e.y), d = a.rectangle(u, c, l, n, { angle: h }), f = [], p = 0; p < t.length; p++) { const g = t[p]; if (o.overlaps(g.bounds, d.bounds)) for (let v = g.parts.length === 1 ? 0 : 1; v < g.parts.length; v++) { const y = g.parts[v]; if (o.overlaps(y.bounds, d.bounds)) { const m = r.collides(y, d); if (m.collided) { m.body = m.bodyA = m.bodyB = g, f.push(m); break; } } } } return f; }, n.region = function (t, e, i) { for (var n = [], s = 0; s < t.length; s++) { const r = t[s]; const a = o.overlaps(r.bounds, e); (a && !i || !a && i) && n.push(r); } return n; }, n.point = function (t, e) { for (var i = [], n = 0; n < t.length; n++) { const s = t[n]; if (o.contains(s.bounds, e)) for (let r = s.parts.length === 1 ? 0 : 1; r < s.parts.length; r++) { const a = s.parts[r]; if (o.contains(a.bounds, e) && h.contains(a.vertices, e)) { i.push(s); break; } } } return i; }; }, function (t, e, i) {
    const n = i(139); const s = i(0); const r = i(219); const o = i(300); const a = i(673); const h = i(1); const l = i(93); const u = i(331); const c = i(7); const d = i(140); const f = new s({
      initialize(t, e, i) {
        void 0 === i && (i = {}); this.scene = t, this.world = e; const n = h(i, 'camera', null); n ? (this.camera = n, delete i.camera) : this.camera = t.sys.cameras.main, this.pointer = null, this.active = !0, this.position = new c(), this.constraint = o.create(l(i, {
          label: 'Pointer Constraint', pointA: { x: 0, y: 0 }, pointB: { x: 0, y: 0 }, damping: 0, length: 0.01, stiffness: 0.1, angularStiffness: 1, collisionFilter: { category: 1, mask: 4294967295, group: 0 },
        })), this.world.on('beforeupdate', this.update, this), t.sys.input.on('pointerdown', this.onDown, this), t.sys.input.on('pointerup', this.onUp, this);
      },
      onDown(t) { this.pointer = t; },
      onUp() { this.pointer = null; },
      getBodyPart(t, e) { for (let i = this.constraint, n = t.parts.length > 1 ? 1 : 0; n < t.parts.length; n++) { const s = t.parts[n]; if (d.contains(s.vertices, e)) return i.bodyB = t, i.pointA.x = e.x, i.pointA.y = e.y, i.pointB.x = e.x - t.position.x, i.pointB.y = e.y - t.position.y, i.angleB = t.angle, u.set(t, !1), !0; } return !1; },
      update() { if (this.active) { const t = this.pointer; const e = this.constraint; if (t) { const i = this.position; if (this.camera.getWorldPoint(t.x, t.y, i), e.bodyB)u.set(e.bodyB, !1), e.pointA.x = i.x, e.pointA.y = i.y; else for (let s = r.allBodies(this.world.localWorld), o = 0; o < s.length; o++) { const h = s[o]; if (!h.ignorePointer && n.contains(h.bounds, i) && a.canCollide(h.collisionFilter, e.collisionFilter) && this.getBodyPart(h, i)) break; } } else e.bodyB && (e.bodyB = null); } },
      destroy() { this.world.removeConstraint(this.constraint), this.constraint = null, this.world.off('beforeupdate', this.update), this.scene.sys.input.off('pointerdown', this.onDown, this), this.scene.sys.input.off('pointerup', this.onUp, this); },
    }); t.exports = f;
  }, function (t, e, i) {
    const n = i(80); const s = {
      setAngularVelocity(t) { return n.setAngularVelocity(this.body, t), this; }, setVelocityX(t) { return this._tempVec2.set(t, this.body.velocity.y), n.setVelocity(this.body, this._tempVec2), this; }, setVelocityY(t) { return this._tempVec2.set(this.body.velocity.x, t), n.setVelocity(this.body, this._tempVec2), this; }, setVelocity(t, e) { return this._tempVec2.set(t, e), n.setVelocity(this.body, this._tempVec2), this; },
    }; t.exports = s;
  }, function (t, e, i) {
    const n = i(80); const s = i(16); const r = i(210); const o = i(209); const a = {
      x: { get() { return this.body.position.x; }, set(t) { this._tempVec2.set(t, this.y), n.setPosition(this.body, this._tempVec2); } }, y: { get() { return this.body.position.y; }, set(t) { this._tempVec2.set(this.x, t), n.setPosition(this.body, this._tempVec2); } }, scaleX: { get() { return this._scaleX; }, set(t) { this._scaleX = t, this._scaleX === 0 ? this.renderFlags &= -5 : this.renderFlags |= 4, n.scale(this.body, t, this._scaleY); } }, scaleY: { get() { return this._scaleY; }, set(t) { this._scaleY = t, this._scaleY === 0 ? this.renderFlags &= -5 : this.renderFlags |= 4, n.scale(this.body, this._scaleX, t); } }, angle: { get() { return o(this.body.angle * s.RAD_TO_DEG); }, set(t) { this.rotation = o(t) * s.DEG_TO_RAD; } }, rotation: { get() { return this.body.angle; }, set(t) { this._rotation = r(t), n.setAngle(this.body, this._rotation); } }, setPosition(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this._tempVec2.set(t, e), n.setPosition(this.body, this._tempVec2), this; }, setRotation(t) { return void 0 === t && (t = 0), this._rotation = r(t), n.setAngle(this.body, t), this; }, setFixedRotation() { return n.setInertia(this.body, 1 / 0), this; }, setAngle(t) { return void 0 === t && (t = 0), this.angle = t, n.setAngle(this.body, this.rotation), this; }, setScale(t, e, i) { return void 0 === t && (t = 1), void 0 === e && (e = t), this._scaleX = t, this._scaleY = e, n.scale(this.body, t, e, i), this; },
    }; t.exports = a;
  }, function (t, e, i) {
    const n = i(301); const s = {
      setSleepThreshold(t) { return void 0 === t && (t = 60), this.body.sleepThreshold = t, this; }, setSleepEvents(t, e) { return this.setSleepStartEvent(t), this.setSleepEndEvent(e), this; }, setSleepStartEvent(t) { if (t) { const e = this.world; n.on(this.body, 'sleepStart', function (t) { e.emit('sleepstart', t, this); }); } else n.off(this.body, 'sleepStart'); return this; }, setSleepEndEvent(t) { if (t) { const e = this.world; n.on(this.body, 'sleepEnd', function (t) { e.emit('sleepend', t, this); }); } else n.off(this.body, 'sleepEnd'); return this; },
    }; t.exports = s;
  }, function (t, e, i) {
    const n = i(220); const s = i(80); const r = i(1); const o = {
      setRectangle(t, e, i) { return this.setBody({ type: 'rectangle', width: t, height: e }, i); },
      setCircle(t, e) { return this.setBody({ type: 'circle', radius: t }, e); },
      setPolygon(t, e, i) { return this.setBody({ type: 'polygon', sides: e, radius: t }, i); },
      setTrapezoid(t, e, i, n) {
        return this.setBody({
          type: 'trapezoid', width: t, height: e, slope: i,
        }, n);
      },
      setExistingBody(t, e) { void 0 === e && (e = !0), this.body && this.world.remove(this.body), this.body = t, this.body.gameObject = this; const i = this; return t.destroy = function () { i.world.remove(i.body), i.body.gameObject = null; }, e && this.world.add(t), this._originComponent && this.setOrigin(t.render.sprite.xOffset, t.render.sprite.yOffset), this; },
      setBody(t, e) { if (!t) return this; let i; typeof t === 'string' && (t = { type: t }); const o = r(t, 'type', 'rectangle'); const a = r(t, 'x', this._tempVec2.x); const h = r(t, 'y', this._tempVec2.y); const l = r(t, 'width', this.width); const u = r(t, 'height', this.height); switch (o) { case 'rectangle': i = n.rectangle(a, h, l, u, e); break; case 'circle': var c = r(t, 'radius', Math.max(l, u) / 2); var d = r(t, 'maxSides', 25); i = n.circle(a, h, c, e, d); break; case 'trapezoid': var f = r(t, 'slope', 0.5); i = n.trapezoid(a, h, l, u, f, e); break; case 'polygon': var p = r(t, 'sides', 5); var g = r(t, 'radius', Math.max(l, u) / 2); i = n.polygon(a, h, p, g, e); break; case 'fromVertices': case 'fromVerts': var v = r(t, 'verts', []); if (this.body)s.setVertices(this.body, v), i = this.body; else { const y = r(t, 'flagInternal', !1); const m = r(t, 'removeCollinear', 0.01); const x = r(t, 'minimumArea', 10); i = n.fromVertices(a, h, v, e, y, m, x); } } return this.setExistingBody(i, t.addToWorld), this; },
    }; t.exports = o;
  }, function (t, e) { t.exports = { setSensor(t) { return this.body.isSensor = t, this; }, isSensor() { return this.body.isSensor; } }; }, function (t, e, i) { const n = i(80); const s = { setStatic(t) { return n.setStatic(this.body, t), this; }, isStatic() { return this.body.isStatic; } }; t.exports = s; }, function (t, e, i) { const n = i(80); const s = { setMass(t) { return n.setMass(this.body, t), this; }, setDensity(t) { return n.setDensity(this.body, t), this; } }; t.exports = s; }, function (t, e) { t.exports = { setIgnoreGravity(t) { return this.body.ignoreGravity = t, this; } }; }, function (t, e) { const i = { setFriction(t, e, i) { return this.body.friction = t, void 0 !== e && (this.body.frictionAir = e), void 0 !== i && (this.body.frictionStatic = i), this; }, setFrictionAir(t) { return this.body.frictionAir = t, this; }, setFrictionStatic(t) { return this.body.frictionStatic = t, this; } }; t.exports = i; }, function (t, e, i) {
    const n = i(80); const s = {
      applyForce(t) { return this._tempVec2.set(this.body.position.x, this.body.position.y), n.applyForce(this.body, this._tempVec2, t), this; }, applyForceFrom(t, e) { return n.applyForce(this.body, t, e), this; }, thrust(t) { const e = this.body.angle; return this._tempVec2.set(t * Math.cos(e), t * Math.sin(e)), n.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2), this; }, thrustLeft(t) { const e = this.body.angle - Math.PI / 2; return this._tempVec2.set(t * Math.cos(e), t * Math.sin(e)), n.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2), this; }, thrustRight(t) { const e = this.body.angle + Math.PI / 2; return this._tempVec2.set(t * Math.cos(e), t * Math.sin(e)), n.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2), this; }, thrustBack(t) { const e = this.body.angle - Math.PI; return this._tempVec2.set(t * Math.cos(e), t * Math.sin(e)), n.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2), this; },
    }; t.exports = s;
  }, function (t, e) { const i = { setCollisionCategory(t) { return this.body.collisionFilter.category = t, this; }, setCollisionGroup(t) { return this.body.collisionFilter.group = t, this; }, setCollidesWith(t) { let e = 0; if (Array.isArray(t)) for (let i = 0; i < t.length; i++)e |= t[i]; else e = t; return this.body.collisionFilter.mask = e, this; } }; t.exports = i; }, function (t, e) { t.exports = { setBounce(t) { return this.body.restitution = t, this; } }; }, function (t, e, i) { const n = i(606); const s = i(1); const r = i(7); t.exports = function (t, e, i) { void 0 === i && (i = {}); const o = e.x; const a = e.y; e.body = { position: { x: o, y: a } }, [n.Bounce, n.Collision, n.Force, n.Friction, n.Gravity, n.Mass, n.Sensor, n.SetBody, n.Sleep, n.Static, n.Transform, n.Velocity].forEach((t) => { for (const i in t)(n = t[i]).get && typeof n.get === 'function' || n.set && typeof n.set === 'function' ? Object.defineProperty(e, i, { get: t[i].get, set: t[i].set }) : Object.defineProperty(e, i, { value: t[i] }); let n; }), e.world = t, e._tempVec2 = new r(o, a); let h = s(i, 'shape', null); return h || (h = 'rectangle'), e.setBody(h, i), e; }; }, function (t, e, i) {
    t.exports = {
      Factory: i(1014), Image: i(1011), Matter: i(671), MatterPhysics: i(1026), PolyDecomp: i(1013), Sprite: i(1010), TileBody: i(674), World: i(1004),
    };
  }, function (t, e) { t.exports = function (t, e, i, n) { let s; let r; const o = e.pos.y + e.size.y - i.pos.y; if (n) { const a = e === n ? i : e; n.vel.y = -n.vel.y * n.bounciness + a.vel.y, s = 0, n === e && Math.abs(n.vel.y - a.vel.y) < n.minBounceVelocity && (n.standing = !0, s = a.vel.x * t.delta); const h = t.collisionMap.trace(n.pos.x, n.pos.y, s, n === e ? -o : o, n.size.x, n.size.y); n.pos.y = h.pos.y, n.pos.x = h.pos.x; } else if (t.gravity && (i.standing || e.vel.y > 0))r = t.collisionMap.trace(e.pos.x, e.pos.y, 0, -(e.pos.y + e.size.y - i.pos.y), e.size.x, e.size.y), e.pos.y = r.pos.y, e.bounciness > 0 && e.vel.y > e.minBounceVelocity ? e.vel.y *= -e.bounciness : (e.standing = !0, e.vel.y = 0); else { const l = (e.vel.y - i.vel.y) / 2; e.vel.y = -l, i.vel.y = l, s = i.vel.x * t.delta, r = t.collisionMap.trace(e.pos.x, e.pos.y, s, -o / 2, e.size.x, e.size.y), e.pos.y = r.pos.y; const u = t.collisionMap.trace(i.pos.x, i.pos.y, 0, o / 2, i.size.x, i.size.y); i.pos.y = u.pos.y; } }; }, function (t, e) { t.exports = function (t, e, i, n) { const s = e.pos.x + e.size.x - i.pos.x; if (n) { const r = e === n ? i : e; n.vel.x = -n.vel.x * n.bounciness + r.vel.x; const o = t.collisionMap.trace(n.pos.x, n.pos.y, n === e ? -s : s, 0, n.size.x, n.size.y); n.pos.x = o.pos.x; } else { const a = (e.vel.x - i.vel.x) / 2; e.vel.x = -a, i.vel.x = a; const h = t.collisionMap.trace(e.pos.x, e.pos.y, -s / 2, 0, e.size.x, e.size.y); e.pos.x = Math.floor(h.pos.x); const l = t.collisionMap.trace(i.pos.x, i.pos.y, s / 2, 0, i.size.x, i.size.y); i.pos.x = Math.ceil(l.pos.x); } }; }, function (t, e, i) { const n = i(333); const s = i(1046); const r = i(1045); t.exports = function (t, e, i) { let o = null; e.collides === n.LITE || i.collides === n.FIXED ? o = e : i.collides !== n.LITE && e.collides !== n.FIXED || (o = i), e.last.x + e.size.x > i.last.x && e.last.x < i.last.x + i.size.x ? (e.last.y < i.last.y ? r(t, e, i, o) : r(t, i, e, o), e.collideWith(i, 'y'), i.collideWith(e, 'y'), t.emit('collide', e, i, 'y')) : e.last.y + e.size.y > i.last.y && e.last.y < i.last.y + i.size.y && (e.last.x < i.last.x ? s(t, e, i, o) : s(t, i, e, o), e.collideWith(i, 'x'), i.collideWith(e, 'x'), t.emit('collide', e, i, 'x')); }; }, function (t, e, i) {
    const n = i(0); const s = i(1019); const r = i(1); const o = i(93); const a = i(12); const h = i(1015); const l = new n({
      initialize(t) { this.scene = t, this.systems = t.sys, this.config = this.getConfig(), this.world, this.add, t.sys.events.once('boot', this.boot, this), t.sys.events.on('start', this.start, this); }, boot() { this.world = new h(this.scene, this.config), this.add = new s(this.world), this.systems.events.once('destroy', this.destroy, this); }, start() { this.world || (this.world = new h(this.scene, this.config), this.add = new s(this.world)); const t = this.systems.events; t.on('update', this.world.update, this.world), t.once('shutdown', this.shutdown, this); }, getConfig() { const t = this.systems.game.config.physics; const e = this.systems.settings.physics; return o(r(e, 'impact', {}), r(t, 'impact', {})); }, pause() { return this.world.pause(); }, resume() { return this.world.resume(); }, shutdown() { const t = this.systems.events; t.off('update', this.world.update, this.world), t.off('shutdown', this.shutdown, this), this.add.destroy(), this.world.destroy(), this.add = null, this.world = null; }, destroy() { this.shutdown(), this.scene.sys.events.off('start', this.start, this), this.scene = null, this.systems = null; },
    }); a.register('ImpactPhysics', l, 'impactPhysics'), t.exports = l;
  }, function (t, e) {
    const i = {
      setVelocityX(t) { return this.vel.x = t, this; }, setVelocityY(t) { return this.vel.y = t, this; }, setVelocity(t, e) { return void 0 === e && (e = t), this.vel.x = t, this.vel.y = e, this; }, setMaxVelocity(t, e) { return void 0 === e && (e = t), this.maxVel.x = t, this.maxVel.y = e, this; },
    }; t.exports = i;
  }, function (t, e) { const i = { setGameObject(t, e) { return void 0 === e && (e = !0), t ? (this.body.gameObject = t, e && this.syncGameObject()) : this.body.gameObject = null, this; }, syncGameObject() { const t = this.body.gameObject; return t && this.setBodySize(t.width * t.scaleX, t.height * t.scaleY), this; } }; t.exports = i; }, function (t, e) { t.exports = { setOffset(t, e, i, n) { return this.body.offset.x = t, this.body.offset.y = e, i && this.setBodySize(i, n), this; } }; }, function (t, e) { t.exports = { setGravity(t) { return this.body.gravityFactor = t, this; }, gravity: { get() { return this.body.gravityFactor; }, set(t) { this.body.gravityFactor = t; } } }; }, function (t, e) { t.exports = { setFrictionX(t) { return this.friction.x = t, this; }, setFrictionY(t) { return this.friction.y = t, this; }, setFriction(t, e) { return this.friction.x = t, this.friction.y = e, this; } }; }, function (t, e) {
    t.exports = {
      setDebug(t, e, i) { return this.debugShowBody = t, this.debugShowVelocity = e, this.debugBodyColor = i, this; }, setDebugBodyColor(t) { return this.body.debugBodyColor = t, this; }, debugShowBody: { get() { return this.body.debugShowBody; }, set(t) { this.body.debugShowBody = t; } }, debugShowVelocity: { get() { return this.body.debugShowVelocity; }, set(t) { this.body.debugShowVelocity = t; } }, debugBodyColor: { get() { return this.body.debugBodyColor; }, set(t) { this.body.debugBodyColor = t; } },
    };
  }, function (t, e, i) {
    const n = i(333); const s = {
      _collideCallback: null, _callbackScope: null, setCollideCallback(t, e) { return this._collideCallback = t, e && (this._callbackScope = e), this; }, setCollidesNever() { return this.body.collides = n.NEVER, this; }, setLiteCollision() { return this.body.collides = n.LITE, this; }, setPassiveCollision() { return this.body.collides = n.PASSIVE, this; }, setActiveCollision() { return this.body.collides = n.ACTIVE, this; }, setFixedCollision() { return this.body.collides = n.FIXED, this; }, collides: { get() { return this.body.collides; }, set(t) { this.body.collides = t; } },
    }; t.exports = s;
  }, function (t, e, i) {
    const n = i(332); const s = {
      setAvsB() { return this.setTypeA(), this.setCheckAgainstB(); }, setBvsA() { return this.setTypeB(), this.setCheckAgainstA(); }, setCheckAgainstNone() { return this.body.checkAgainst = n.NONE, this; }, setCheckAgainstA() { return this.body.checkAgainst = n.A, this; }, setCheckAgainstB() { return this.body.checkAgainst = n.B, this; }, checkAgainst: { get() { return this.body.checkAgainst; }, set(t) { this.body.checkAgainst = t; } },
    }; t.exports = s;
  }, function (t, e) { t.exports = { setBounce(t) { return this.body.bounciness = t, this; }, setMinBounceVelocity(t) { return this.body.minBounceVelocity = t, this; }, bounce: { get() { return this.body.bounciness; }, set(t) { this.body.bounciness = t; } } }; }, function (t, e, i) {
    const n = i(332); const s = {
      getBodyType() { return this.body.type; }, setTypeNone() { return this.body.type = n.NONE, this; }, setTypeA() { return this.body.type = n.A, this; }, setTypeB() { return this.body.type = n.B, this; },
    }; t.exports = s;
  }, function (t, e) { const i = { setBodySize(t, e) { return void 0 === e && (e = t), this.body.size.x = Math.round(t), this.body.size.y = Math.round(e), this; }, setBodyScale(t, e) { void 0 === e && (e = t); const i = this.body.gameObject; return i ? (i.setScale(t, e), this.setBodySize(i.width * i.scaleX, i.height * i.scaleY)) : this.setBodySize(this.body.size.x * t, this.body.size.y * e); } }; t.exports = i; }, function (t, e) { t.exports = { setAccelerationX(t) { return this.accel.x = t, this; }, setAccelerationY(t) { return this.accel.y = t, this; }, setAcceleration(t, e) { return this.accel.x = t, this.accel.y = e, this; } }; }, function (t, e) {
    const i = 0.5; const n = 1 / 3; const s = 2 / 3; t.exports = {
      2: [0, 1, 1, 0, !0], 3: [0, 1, 1, i, !0], 4: [0, i, 1, 0, !0], 5: [0, 1, 1, s, !0], 6: [0, s, 1, n, !0], 7: [0, n, 1, 0, !0], 8: [i, 1, 0, 0, !0], 9: [1, 0, i, 1, !0], 10: [i, 1, 1, 0, !0], 11: [0, 0, i, 1, !0], 12: [0, 0, 1, 0, !1], 13: [1, 1, 0, 0, !0], 14: [1, i, 0, 0, !0], 15: [1, 1, 0, i, !0], 16: [1, n, 0, 0, !0], 17: [1, s, 0, n, !0], 18: [1, 1, 0, s, !0], 19: [1, 1, i, 0, !0], 20: [i, 0, 0, 1, !0], 21: [0, 1, i, 0, !0], 22: [i, 0, 1, 1, !0], 23: [1, 1, 0, 1, !1], 24: [0, 0, 1, 1, !0], 25: [0, 0, 1, i, !0], 26: [0, i, 1, 1, !0], 27: [0, 0, 1, n, !0], 28: [0, n, 1, s, !0], 29: [0, s, 1, 1, !0], 30: [n, 1, 0, 0, !0], 31: [1, 0, s, 1, !0], 32: [s, 1, 1, 0, !0], 33: [0, 0, n, 1, !0], 34: [1, 0, 1, 1, !1], 35: [1, 0, 0, 1, !0], 36: [1, i, 0, 1, !0], 37: [1, 0, 0, i, !0], 38: [1, s, 0, 1, !0], 39: [1, n, 0, s, !0], 40: [1, 0, 0, n, !0], 41: [s, 1, n, 0, !0], 42: [s, 0, n, 1, !0], 43: [n, 1, s, 0, !0], 44: [n, 0, s, 1, !0], 45: [0, 1, 0, 0, !1], 52: [1, 1, s, 0, !0], 53: [n, 0, 0, 1, !0], 54: [0, 1, n, 0, !0], 55: [s, 0, 1, 1, !0],
    };
  }, function (t, e) { t.exports = function (t, e) { if (t.standing = !1, e.collision.y && (t.bounciness > 0 && Math.abs(t.vel.y) > t.minBounceVelocity ? t.vel.y *= -t.bounciness : (t.vel.y > 0 && (t.standing = !0), t.vel.y = 0)), e.collision.x && (t.bounciness > 0 && Math.abs(t.vel.x) > t.minBounceVelocity ? t.vel.x *= -t.bounciness : t.vel.x = 0), e.collision.slope) { const i = e.collision.slope; if (t.bounciness > 0) { const n = t.vel.x * i.nx + t.vel.y * i.ny; t.vel.x = (t.vel.x - i.nx * n * 2) * t.bounciness, t.vel.y = (t.vel.y - i.ny * n * 2) * t.bounciness; } else { const s = i.x * i.x + i.y * i.y; const r = (t.vel.x * i.x + t.vel.y * i.y) / s; t.vel.x = i.x * r, t.vel.y = i.y * r; const o = Math.atan2(i.x, i.y); o > t.slopeStanding.min && o < t.slopeStanding.max && (t.standing = !0); } }t.pos.x = e.pos.x, t.pos.y = e.pos.y; }; }, function (t, e, i) { const n = i(23); t.exports = function (t, e, i, s, r) { if (i) return n(e + i * t, -r, r); if (s) { const o = s * t; return e - o > 0 ? e - o : e + o < 0 ? e + o : 0; } return n(e, -r, r); }; }, function (t, e, i) {
    t.exports = {
      Body: i(1021), COLLIDES: i(333), CollisionMap: i(1020), Factory: i(1019), Image: i(1017), ImpactBody: i(1018), ImpactPhysics: i(1048), Sprite: i(1016), TYPE: i(332), World: i(1015),
    };
  }, function (t, e, i) { t.exports = { Arcade: i(698), Impact: i(1064), Matter: i(1044) }; }, function (t, e, i) {
    (function (e) {
      i(604); const n = i(20); const s = i(18); let r = {
        Actions: i(594), Animation: i(563), Cache: i(562), Cameras: i(956), Class: i(0), Create: i(952), Curves: i(946), Data: i(537), Display: i(943), DOM: i(914), Events: i(529), Game: i(527), GameObjects: i(913), Geom: i(387), Input: i(371), Loader: i(757), Math: i(743), Physics: i(1065), Plugins: i(330), Renderer: i(668), Scene: i(185), Scenes: i(328), Sound: i(326), Structs: i(325), Textures: i(324), Tilemaps: i(663), Time: i(308), Tweens: i(306), Utils: i(614),
      }; r = s(!1, r, n), t.exports = r, e.Phaser = r;
    }).call(this, i(213));
  }]))));